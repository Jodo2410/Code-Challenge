{
  "id": "balanced-binary-search-tree-validator-mcbt0fnk",
  "title": "Balanced Binary Search Tree Validator",
  "description": "Implementiere eine Funktion, die √ºberpr√ºft, ob ein gegebener bin√§rer Baum ein ausgeglichener (balanced) bin√§rer Suchbaum (BST) ist.\n\nEin ausgeglichener Baum bedeutet, dass f√ºr jeden Knoten der H√∂henunterschied zwischen dem linken und rechten Teilbaum nicht gr√∂√üer als 1 ist.\n\nEin bin√§rer Suchbaum ist ein Baum, bei dem f√ºr jeden Knoten alle Werte im linken Teilbaum kleiner und alle Werte im rechten Teilbaum gr√∂√üer sind als der Wert des Knotens selbst.\n\nBeispiele:\n\n```\nEingabe 1: \n    5\n   / \\\n  3   7\n / \\ / \\\n2  4 6  8\n\nAusgabe 1: true (Der Baum ist ein ausgeglichener BST)\n\nEingabe 2:\n    5\n   / \\\n  3   7\n /     \\\n1       9\n         \\\n         11\n\nAusgabe 2: false (Der Baum ist ein BST, aber nicht ausgeglichen)\n\nEingabe 3:\n    5\n   / \\\n  7   3\n\nAusgabe 3: false (Der Baum ist kein BST, da 7 > 5 aber im linken Teilbaum)\n```",
  "difficulty": "medium",
  "language": "csharp",
  "tags": [
    "binary-tree",
    "data-structures",
    "algorithms",
    "recursion",
    "csharp",
    "medium"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:20:55.417Z",
  "status": "reported",
  "starterCode": "using System;\n\npublic class TreeNode\n{\n    public int Value;\n    public TreeNode Left;\n    public TreeNode Right;\n\n    public TreeNode(int value)\n    {\n        Value = value;\n        Left = null;\n        Right = null;\n    }\n}\n\npublic class BalancedBSTValidator\n{\n    /// <summary>\n    /// √úberpr√ºft, ob der gegebene Baum ein ausgeglichener bin√§rer Suchbaum (BST) ist.\n    /// Ein ausgeglichener Baum bedeutet, dass f√ºr jeden Knoten der H√∂henunterschied zwischen\n    /// dem linken und rechten Teilbaum nicht gr√∂√üer als 1 ist.\n    /// Ein BST bedeutet, dass f√ºr jeden Knoten alle Werte im linken Teilbaum kleiner und\n    /// alle Werte im rechten Teilbaum gr√∂√üer sind als der Wert des Knotens selbst.\n    /// </summary>\n    /// <param name=\"root\">Der Wurzelknoten des zu √ºberpr√ºfenden Baums</param>\n    /// <returns>True, wenn der Baum ein ausgeglichener BST ist, sonst False</returns>\n    public static bool IsBalancedBST(TreeNode root)\n    {\n        // TODO: Implementiere deine L√∂sung hier\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\n\npublic class TreeNode\n{\n    public int Value;\n    public TreeNode Left;\n    public TreeNode Right;\n\n    public TreeNode(int value)\n    {\n        Value = value;\n        Left = null;\n        Right = null;\n    }\n}\n\npublic class BalancedBSTValidator\n{\n    /// <summary>\n    /// √úberpr√ºft, ob der gegebene Baum ein ausgeglichener bin√§rer Suchbaum (BST) ist.\n    /// Ein ausgeglichener Baum bedeutet, dass f√ºr jeden Knoten der H√∂henunterschied zwischen\n    /// dem linken und rechten Teilbaum nicht gr√∂√üer als 1 ist.\n    /// Ein BST bedeutet, dass f√ºr jeden Knoten alle Werte im linken Teilbaum kleiner und\n    /// alle Werte im rechten Teilbaum gr√∂√üer sind als der Wert des Knotens selbst.\n    /// </summary>\n    /// <param name=\"root\">Der Wurzelknoten des zu √ºberpr√ºfenden Baums</param>\n    /// <returns>True, wenn der Baum ein ausgeglichener BST ist, sonst False</returns>\n    public static bool IsBalancedBST(TreeNode root)\n    {\n        // Ein leerer Baum ist per Definition ein ausgeglichener BST\n        if (root == null)\n        {\n            return true;\n        }\n\n        // Pr√ºfe, ob der Baum ein BST ist\n        if (!IsBST(root, int.MinValue, int.MaxValue))\n        {\n            return false;\n        }\n\n        // Pr√ºfe, ob der Baum ausgeglichen ist\n        return IsBalanced(root) != -1;\n    }\n\n    // Hilfsmethode, die √ºberpr√ºft, ob der Baum ein bin√§rer Suchbaum ist\n    private static bool IsBST(TreeNode node, int min, int max)\n    {\n        // Ein leerer Knoten ist ein g√ºltiger BST\n        if (node == null)\n        {\n            return true;\n        }\n\n        // √úberpr√ºfe, ob der aktuelle Knoten im g√ºltigen Bereich liegt\n        if (node.Value <= min || node.Value >= max)\n        {\n            return false;\n        }\n\n        // √úberpr√ºfe rekursiv den linken und rechten Teilbaum\n        // F√ºr den linken Teilbaum: alle Werte m√ºssen kleiner als der aktuelle Knoten sein\n        // F√ºr den rechten Teilbaum: alle Werte m√ºssen gr√∂√üer als der aktuelle Knoten sein\n        return IsBST(node.Left, min, node.Value) && IsBST(node.Right, node.Value, max);\n    }\n\n    // Hilfsmethode, die die H√∂he des Baums berechnet und gleichzeitig pr√ºft,\n    // ob er ausgeglichen ist. Gibt -1 zur√ºck, wenn nicht ausgeglichen.\n    private static int IsBalanced(TreeNode node)\n    {\n        // Ein leerer Knoten hat H√∂he 0\n        if (node == null)\n        {\n            return 0;\n        }\n\n        // Berechne die H√∂he des linken Teilbaums\n        int leftHeight = IsBalanced(node.Left);\n        if (leftHeight == -1)\n        {\n            return -1; // Linker Teilbaum ist nicht ausgeglichen\n        }\n\n        // Berechne die H√∂he des rechten Teilbaums\n        int rightHeight = IsBalanced(node.Right);\n        if (rightHeight == -1)\n        {\n            return -1; // Rechter Teilbaum ist nicht ausgeglichen\n        }\n\n        // √úberpr√ºfe, ob der H√∂henunterschied gr√∂√üer als 1 ist\n        if (Math.Abs(leftHeight - rightHeight) > 1)\n        {\n            return -1; // Baum ist nicht ausgeglichen\n        }\n\n        // Gib die H√∂he des aktuellen Knotens zur√ºck\n        return Math.Max(leftHeight, rightHeight) + 1;\n    }\n}",
  "tests": "using System;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: Balanced Binary Search Tree Validator\");\n        Console.WriteLine(new string('=', 50));\n\n        TestEmptyTree();\n        TestSingleNodeTree();\n        TestBalancedBST();\n        TestUnbalancedBST();\n        TestNonBST();\n        TestComplexBalancedBST();\n        TestComplexUnbalancedBST();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestEmptyTree()\n    {\n        Test(\"Leerer Baum\", () => {\n            TreeNode root = null;\n            bool result = BalancedBSTValidator.IsBalancedBST(root);\n            AssertEqual(true, result, \"Ein leerer Baum sollte als ausgeglichener BST gelten\");\n        });\n    }\n\n    private static void TestSingleNodeTree()\n    {\n        Test(\"Baum mit einem Knoten\", () => {\n            TreeNode root = new TreeNode(5);\n            bool result = BalancedBSTValidator.IsBalancedBST(root);\n            AssertEqual(true, result, \"Ein Baum mit einem Knoten sollte als ausgeglichener BST gelten\");\n        });\n    }\n\n    private static void TestBalancedBST()\n    {\n        Test(\"Ausgeglichener BST\", () => {\n            TreeNode root = new TreeNode(5);\n            root.Left = new TreeNode(3);\n            root.Right = new TreeNode(7);\n            root.Left.Left = new TreeNode(2);\n            root.Left.Right = new TreeNode(4);\n            root.Right.Left = new TreeNode(6);\n            root.Right.Right = new TreeNode(8);\n            \n            bool result = BalancedBSTValidator.IsBalancedBST(root);\n            AssertEqual(true, result, \"Der gegebene Baum sollte ein ausgeglichener BST sein\");\n        });\n    }\n\n    private static void TestUnbalancedBST()\n    {\n        Test(\"Nicht ausgeglichener BST\", () => {\n            TreeNode root = new TreeNode(5);\n            root.Left = new TreeNode(3);\n            root.Right = new TreeNode(7);\n            root.Left.Left = new TreeNode(1);\n            root.Right.Right = new TreeNode(9);\n            root.Right.Right.Right = new TreeNode(11);\n            \n            bool result = BalancedBSTValidator.IsBalancedBST(root);\n            AssertEqual(false, result, \"Der gegebene Baum sollte ein BST, aber nicht ausgeglichen sein\");\n        });\n    }\n\n    private static void TestNonBST()\n    {\n        Test(\"Kein BST\", () => {\n            TreeNode root = new TreeNode(5);\n            root.Left = new TreeNode(7); // Fehler: 7 > 5, sollte nicht im linken Teilbaum sein\n            root.Right = new TreeNode(3); // Fehler: 3 < 5, sollte nicht im rechten Teilbaum sein\n            \n            bool result = BalancedBSTValidator.IsBalancedBST(root);\n            AssertEqual(false, result, \"Der gegebene Baum sollte kein BST sein\");\n        });\n    }\n\n    private static void TestComplexBalancedBST()\n    {\n        Test(\"Komplexer ausgeglichener BST\", () => {\n            TreeNode root = new TreeNode(15);\n            root.Left = new TreeNode(10);\n            root.Right = new TreeNode(20);\n            root.Left.Left = new TreeNode(5);\n            root.Left.Right = new TreeNode(12);\n            root.Right.Left = new TreeNode(17);\n            root.Right.Right = new TreeNode(25);\n            root.Left.Left.Left = new TreeNode(3);\n            root.Left.Left.Right = new TreeNode(7);\n            \n            bool result = BalancedBSTValidator.IsBalancedBST(root);\n            AssertEqual(true, result, \"Der komplexe Baum sollte ein ausgeglichener BST sein\");\n        });\n    }\n\n    private static void TestComplexUnbalancedBST()\n    {\n        Test(\"Komplexer nicht ausgeglichener BST\", () => {\n            TreeNode root = new TreeNode(15);\n            root.Left = new TreeNode(10);\n            root.Right = new TreeNode(20);\n            root.Left.Left = new TreeNode(5);\n            root.Left.Right = new TreeNode(12);\n            root.Left.Left.Left = new TreeNode(3);\n            root.Left.Left.Left.Left = new TreeNode(1); // Unausgeglichen hier\n            \n            bool result = BalancedBSTValidator.IsBalancedBST(root);\n            AssertEqual(false, result, \"Der komplexe Baum sollte ein BST, aber nicht ausgeglichen sein\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEqual<T>(T expected, T actual, string message = null)\n    {\n        if (!Equals(expected, actual))\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {expected}, Erhalten: {actual}\");\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "BalancedBinarySearchTreeValidator",
  "functionName": "BalancedBinarySearchTreeValidator",
  "reportedIssueNumber": 68,
  "reportedIssueUrl": "https://github.com/Jodo2410/Code-Challenge/issues/68",
  "isHidden": true
}