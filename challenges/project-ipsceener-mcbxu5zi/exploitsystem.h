#ifndef EXPLOITSYSTEM_H
#define EXPLOITSYSTEM_H

#include <QtCore/QObject>
#include <QtCore/QThread>
#include <QtCore/QRunnable>
#include <QtCore/QDateTime>
#include <QtNetwork/QTcpSocket>
#include <QtNetwork/QUdpSocket>
#include <QtCore/QProcess>
#include <QtWidgets/QDialog>
#include <QtWidgets/QTextEdit>
#include <QtWidgets/QProgressBar>
#include <QtWidgets/QPushButton>
#include <QtWidgets/QVBoxLayout>
#include <QtWidgets/QHBoxLayout>
#include <QtWidgets/QLabel>
#include <QtWidgets/QComboBox>
#include <QtWidgets/QCheckBox>
#include <QtWidgets/QGroupBox>
#include <QtWidgets/QTabWidget>
#include <QtWidgets/QTableWidget>
#include <QtWidgets/QHeaderView>
#include <QtWidgets/QSpinBox>
#include <QtWidgets/QLineEdit>
#include "VulnerabilityScanner.h"
#include <QTreeWidget>
#include "ipscanner.h"

enum class ExploitType {
    CREDENTIAL_ATTACK,
    BUFFER_OVERFLOW,
    SQL_INJECTION,
    XSS_ATTACK,
    COMMAND_INJECTION,
    PRIVILEGE_ESCALATION,
    DENIAL_OF_SERVICE,
    METASPLOIT_MODULE,
    CUSTOM_SCRIPT
};

struct ExploitInfo {
    QString id;
    QString name;
    QString description;
    ExploitType type;
    QString targetService;
    int targetPort;
    QString payload;
    QString requirements;
    QString author;
    QDateTime created;
    QString cveId;
    double successRate;
    bool requiresAuth;
    QString difficulty; // "easy", "medium", "hard", "expert"
    QStringList platforms;
    QString metasploitModule;
    QString customScript;
};

struct ExploitResult {
    QString exploitId;
    QString targetIp;
    int targetPort;
    bool successful;
    QString output;
    QString errorMessage;
    QDateTime executionTime;
    QString sessionInfo;
    QString gainedAccess;
    QStringList extractedData;
    QString shellType;
    int connectionPort;
};

class ExploitWorker : public QObject, public QRunnable
{
    Q_OBJECT

public:
    ExploitWorker(const VulnerabilityInfo &vulnerability, const ExploitInfo &exploit, const QString &targetIp);
    void run() override;

signals:
    void exploitStarted(const QString &exploitId, const QString &target);
    void exploitProgress(const QString &exploitId, int percentage, const QString &status);
    void exploitCompleted(const QString &exploitId, const ExploitResult &result);
    void exploitFailed(const QString &exploitId, const QString &error);
    void shellObtained(const QString &exploitId, const QString &shellInfo);

private:
    void executeCredentialAttack();
    void executeBufferOverflow();
    void executeSQLInjection();
    void executeCommandInjection();
    void executeMetasploitModule();
    void executeCustomScript();
    void executeDenialOfService();

    // Helper methods
    bool connectToTarget();
    void sendPayload(const QString &payload);
    QString receiveResponse();
    bool checkExploitSuccess();
    void extractSystemInfo();
    void establishReverseShell();

    VulnerabilityInfo m_vulnerability;
    ExploitInfo m_exploit;
    QString m_targetIp;
    QTcpSocket *m_socket;
    ExploitResult m_result;
    QProcess *m_process;
};

class ExploitDialog : public QDialog
{
    Q_OBJECT

public:
    ExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent = nullptr);
    ~ExploitDialog();

private slots:
    void loadAvailableExploits();
    void onExploitSelected();
    void runSelectedExploit();
    void stopExploit();
    void onExploitStarted(const QString &exploitId, const QString &target);
    void onExploitProgress(const QString &exploitId, int percentage, const QString &status);
    void onExploitCompleted(const QString &exploitId, const ExploitResult &result);
    void onExploitFailed(const QString &exploitId, const QString &error);
    void onShellObtained(const QString &exploitId, const QString &shellInfo);
    void saveExploitResults();
    void openReverseShell();

private:
    void setupUI();
    void setupExploitList();
    void updateExploitDetails();
    QStringList getMetasploitModules(const QString &service, int port);
    void showWarningDialog();

    VulnerabilityInfo m_vulnerability;

    // UI Components
    QTabWidget *m_tabWidget;

    // Exploit Selection Tab
    QTableWidget *m_exploitTable;
    QTextEdit *m_exploitDetails;
    QPushButton *m_runExploitButton;
    QPushButton *m_stopExploitButton;
    QLabel *m_statusLabel;
    QProgressBar *m_progressBar;

    // Configuration Tab
    QLineEdit *m_payloadEdit;
    QSpinBox *m_timeoutSpinBox;
    QCheckBox *m_reverseShellCheckBox;
    QLineEdit *m_listenerPortEdit;
    QComboBox *m_shellTypeCombo;
    QCheckBox *m_verboseOutputCheckBox;

    // Results Tab
    QTextEdit *m_outputEdit;
    QTextEdit *m_errorEdit;
    QTableWidget *m_sessionTable;
    QPushButton *m_saveResultsButton;
    QPushButton *m_openShellButton;

    QList<ExploitInfo> m_availableExploits;
    ExploitInfo m_selectedExploit;
    ExploitWorker *m_currentWorker;
    QList<ExploitResult> m_exploitResults;
    bool m_exploitRunning;
};

class ExploitDatabase
{
public:
    static ExploitDatabase* instance();

    QList<ExploitInfo> getExploitsForVulnerability(const VulnerabilityInfo &vuln);
    QList<ExploitInfo> getExploitsForService(const QString &service, int port);
    ExploitInfo getExploitById(const QString &id);

    void addCustomExploit(const ExploitInfo &exploit);
    void updateExploitDatabase();
    void loadMetasploitModules();

private:
    ExploitDatabase();
    void initializeBuiltinExploits();
    void loadExploitsFromFile();

    static ExploitDatabase* s_instance;
    QList<ExploitInfo> m_exploits;
    QMap<QString, QString> m_metasploitModules;
};

// Built-in exploits for common vulnerabilities
class BuiltinExploits
{
public:
    // SSH Brute Force
    static ExploitInfo createSSHBruteForce() {
        ExploitInfo exploit;
        exploit.id = "ssh_bruteforce_001";
        exploit.name = "SSH Brute Force Attack";
        exploit.description = "Attempts to brute force SSH credentials using common username/password combinations";
        exploit.type = ExploitType::CREDENTIAL_ATTACK;
        exploit.targetService = "SSH";
        exploit.targetPort = 22;
        exploit.payload = "hydra -L userlist.txt -P passlist.txt {target} ssh";
        exploit.requirements = "Hydra tool, username/password lists";
        exploit.author = "Built-in";
        exploit.successRate = 0.3;
        exploit.requiresAuth = false;
        exploit.difficulty = "easy";
        exploit.platforms << "Linux" << "Unix" << "Windows";
        return exploit;
    }

    // Weak FTP Login
    static ExploitInfo createFTPBruteForce() {
        ExploitInfo exploit;
        exploit.id = "ftp_bruteforce_001";
        exploit.name = "FTP Brute Force Attack";
        exploit.description = "Tests common FTP credentials and anonymous login";
        exploit.type = ExploitType::CREDENTIAL_ATTACK;
        exploit.targetService = "FTP";
        exploit.targetPort = 21;
        exploit.payload = "ftp_brute_force_script.py";
        exploit.requirements = "Python, ftplib";
        exploit.author = "Built-in";
        exploit.successRate = 0.4;
        exploit.requiresAuth = false;
        exploit.difficulty = "easy";
        exploit.platforms << "All";
        return exploit;
    }

    // HTTP Basic Auth Brute Force
    static ExploitInfo createHTTPBruteForce() {
        ExploitInfo exploit;
        exploit.id = "http_basicauth_001";
        exploit.name = "HTTP Basic Auth Brute Force";
        exploit.description = "Brute forces HTTP Basic Authentication";
        exploit.type = ExploitType::CREDENTIAL_ATTACK;
        exploit.targetService = "HTTP";
        exploit.targetPort = 80;
        exploit.payload = "hydra -L users.txt -P pass.txt {target} http-get /";
        exploit.requirements = "Hydra, wordlists";
        exploit.author = "Built-in";
        exploit.successRate = 0.25;
        exploit.requiresAuth = false;
        exploit.difficulty = "easy";
        exploit.platforms << "All";
        return exploit;
    }

    // SQL Injection Test
    static ExploitInfo createSQLInjection() {
        ExploitInfo exploit;
        exploit.id = "sql_injection_001";
        exploit.name = "SQL Injection Test";
        exploit.description = "Tests for SQL injection vulnerabilities in web forms";
        exploit.type = ExploitType::SQL_INJECTION;
        exploit.targetService = "HTTP";
        exploit.targetPort = 80;
        exploit.payload = "sqlmap -u {target} --batch --dbs";
        exploit.requirements = "SQLMap tool";
        exploit.author = "Built-in";
        exploit.successRate = 0.15;
        exploit.requiresAuth = false;
        exploit.difficulty = "medium";
        exploit.platforms << "All";
        return exploit;
    }

    // SMB Null Session
    static ExploitInfo createSMBNullSession() {
        ExploitInfo exploit;
        exploit.id = "smb_null_session_001";
        exploit.name = "SMB Null Session";
        exploit.description = "Attempts to establish SMB null session for information gathering";
        exploit.type = ExploitType::PRIVILEGE_ESCALATION;
        exploit.targetService = "SMB";
        exploit.targetPort = 445;
        exploit.payload = "smbclient -L {target} -N";
        exploit.requirements = "Samba client tools";
        exploit.author = "Built-in";
        exploit.successRate = 0.2;
        exploit.requiresAuth = false;
        exploit.difficulty = "easy";
        exploit.platforms << "Windows";
        return exploit;
    }

    // Telnet Brute Force
    static ExploitInfo createTelnetBruteForce() {
        ExploitInfo exploit;
        exploit.id = "telnet_bruteforce_001";
        exploit.name = "Telnet Brute Force";
        exploit.description = "Brute forces Telnet login credentials";
        exploit.type = ExploitType::CREDENTIAL_ATTACK;
        exploit.targetService = "Telnet";
        exploit.targetPort = 23;
        exploit.payload = "hydra -L users.txt -P pass.txt {target} telnet";
        exploit.requirements = "Hydra, wordlists";
        exploit.author = "Built-in";
        exploit.successRate = 0.35;
        exploit.requiresAuth = false;
        exploit.difficulty = "easy";
        exploit.platforms << "All";
        return exploit;
    }

    // SNMP Community String Brute Force
    static ExploitInfo createSNMPBruteForce() {
        ExploitInfo exploit;
        exploit.id = "snmp_bruteforce_001";
        exploit.name = "SNMP Community String Brute Force";
        exploit.description = "Tests common SNMP community strings";
        exploit.type = ExploitType::CREDENTIAL_ATTACK;
        exploit.targetService = "SNMP";
        exploit.targetPort = 161;
        exploit.payload = "onesixtyone -c community.txt {target}";
        exploit.requirements = "onesixtyone tool";
        exploit.author = "Built-in";
        exploit.successRate = 0.3;
        exploit.requiresAuth = false;
        exploit.difficulty = "easy";
        exploit.platforms << "All";
        return exploit;
    }
};

// Integration into main IpScanner class
class IpScannerExploitExtension
{
public:
    static void addExploitContextMenu(QTreeWidget *vulnerabilityTree, IpScanner *scanner);
    static void showExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent);
    static void runQuickExploit(const VulnerabilityInfo &vulnerability, const QString &exploitId);
};

#endif // EXPLOITSYSTEM_H
