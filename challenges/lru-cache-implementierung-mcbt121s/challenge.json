{
  "id": "lru-cache-implementierung-mcbt121s",
  "title": "LRU Cache Implementierung",
  "description": "Implementiere eine Least Recently Used (LRU) Cache-Datenstruktur. Der Cache sollte eine festgelegte Kapazit√§t haben und folgende Operationen unterst√ºtzen:\n\n1. `Get(key)`: Gibt den Wert des Schl√ºssels zur√ºck, wenn er im Cache vorhanden ist, sonst -1.\n2. `Put(key, value)`: F√ºgt einen Schl√ºssel-Wert-Paar in den Cache ein. Wenn der Schl√ºssel bereits existiert, aktualisiere seinen Wert. Wenn die Anzahl der Schl√ºssel die Kapazit√§t √ºberschreitet, entferne den am l√§ngsten nicht verwendeten Schl√ºssel.\n\nBeide Operationen sollten in einer durchschnittlichen Zeitkomplexit√§t von O(1) ausgef√ºhrt werden.\n\nBeispiel:\n```\nLRUCache cache = new LRUCache(2); // Kapazit√§t = 2\n\ncache.Put(1, 1);\ncache.Put(2, 2);\ncache.Get(1);       // Gibt 1 zur√ºck\ncache.Put(3, 3);    // Entfernt Schl√ºssel 2, da 1 zuletzt verwendet wurde\ncache.Get(2);       // Gibt -1 zur√ºck (nicht gefunden)\ncache.Put(4, 4);    // Entfernt Schl√ºssel 1\ncache.Get(1);       // Gibt -1 zur√ºck (nicht gefunden)\ncache.Get(3);       // Gibt 3 zur√ºck\ncache.Get(4);       // Gibt 4 zur√ºck\n```",
  "difficulty": "medium",
  "language": "csharp",
  "tags": [
    "data-structures",
    "dictionary",
    "linked-list",
    "algorithms",
    "caching",
    "csharp",
    "medium"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:21:24.479Z",
  "status": "approved",
  "starterCode": "using System;\nusing System.Collections.Generic;\n\npublic class LRUCache\n{\n    // TODO: Implementiere die notwendigen Felder und Datenstrukturen\n    \n    /// <summary>\n    /// Initialisiert einen neuen LRU Cache mit der angegebenen Kapazit√§t.\n    /// </summary>\n    /// <param name=\"capacity\">Die Kapazit√§t des Caches</param>\n    public LRUCache(int capacity)\n    {\n        // TODO: Initialisierung\n    }\n    \n    /// <summary>\n    /// Gibt den Wert des angegebenen Schl√ºssels zur√ºck, wenn er im Cache vorhanden ist.\n    /// Aktualisiert den Schl√ºssel als k√ºrzlich verwendet.\n    /// </summary>\n    /// <param name=\"key\">Der zu suchende Schl√ºssel</param>\n    /// <returns>Den Wert des Schl√ºssels, oder -1 wenn nicht gefunden</returns>\n    public int Get(int key)\n    {\n        // TODO: Implementiere die Get-Methode\n        throw new NotImplementedException();\n    }\n    \n    /// <summary>\n    /// F√ºgt einen Schl√ºssel-Wert-Paar in den Cache ein oder aktualisiert es.\n    /// Wenn die Kapazit√§t √ºberschritten wird, entferne den am l√§ngsten nicht verwendeten Schl√ºssel.\n    /// </summary>\n    /// <param name=\"key\">Der einzuf√ºgende Schl√ºssel</param>\n    /// <param name=\"value\">Der einzuf√ºgende Wert</param>\n    public void Put(int key, int value)\n    {\n        // TODO: Implementiere die Put-Methode\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\nusing System.Collections.Generic;\n\npublic class LRUCache\n{\n    private int capacity;\n    private Dictionary<int, LinkedListNode<CacheItem>> cache;\n    private LinkedList<CacheItem> lruList;\n    \n    // Innere Klasse f√ºr Schl√ºssel-Wert-Paare\n    private class CacheItem\n    {\n        public int Key { get; set; }\n        public int Value { get; set; }\n        \n        public CacheItem(int key, int value)\n        {\n            Key = key;\n            Value = value;\n        }\n    }\n    \n    /// <summary>\n    /// Initialisiert einen neuen LRU Cache mit der angegebenen Kapazit√§t.\n    /// </summary>\n    /// <param name=\"capacity\">Die Kapazit√§t des Caches</param>\n    public LRUCache(int capacity)\n    {\n        this.capacity = capacity;\n        cache = new Dictionary<int, LinkedListNode<CacheItem>>(capacity);\n        lruList = new LinkedList<CacheItem>();\n    }\n    \n    /// <summary>\n    /// Gibt den Wert des angegebenen Schl√ºssels zur√ºck, wenn er im Cache vorhanden ist.\n    /// Aktualisiert den Schl√ºssel als k√ºrzlich verwendet.\n    /// </summary>\n    /// <param name=\"key\">Der zu suchende Schl√ºssel</param>\n    /// <returns>Den Wert des Schl√ºssels, oder -1 wenn nicht gefunden</returns>\n    public int Get(int key)\n    {\n        // Pr√ºfe, ob der Schl√ºssel im Cache vorhanden ist\n        if (!cache.ContainsKey(key))\n        {\n            return -1;\n        }\n        \n        // Hole den Knoten\n        LinkedListNode<CacheItem> node = cache[key];\n        int value = node.Value.Value;\n        \n        // Bewege den Knoten an den Anfang der Liste (als k√ºrzlich verwendet markieren)\n        lruList.Remove(node);\n        lruList.AddFirst(node);\n        \n        return value;\n    }\n    \n    /// <summary>\n    /// F√ºgt einen Schl√ºssel-Wert-Paar in den Cache ein oder aktualisiert es.\n    /// Wenn die Kapazit√§t √ºberschritten wird, entferne den am l√§ngsten nicht verwendeten Schl√ºssel.\n    /// </summary>\n    /// <param name=\"key\">Der einzuf√ºgende Schl√ºssel</param>\n    /// <param name=\"value\">Der einzuf√ºgende Wert</param>\n    public void Put(int key, int value)\n    {\n        // Falls der Schl√ºssel bereits existiert, aktualisiere den Wert und bewege den Knoten\n        if (cache.ContainsKey(key))\n        {\n            LinkedListNode<CacheItem> existingNode = cache[key];\n            existingNode.Value.Value = value;\n            \n            // Bewege den Knoten an den Anfang der Liste\n            lruList.Remove(existingNode);\n            lruList.AddFirst(existingNode);\n        }\n        else\n        {\n            // Pr√ºfe, ob die Kapazit√§t erreicht ist\n            if (cache.Count >= capacity)\n            {\n                // Entferne den am l√§ngsten nicht verwendeten Eintrag (letzter in der Liste)\n                LinkedListNode<CacheItem> lastNode = lruList.Last;\n                lruList.RemoveLast();\n                cache.Remove(lastNode.Value.Key);\n            }\n            \n            // F√ºge den neuen Eintrag hinzu\n            CacheItem newItem = new CacheItem(key, value);\n            LinkedListNode<CacheItem> newNode = new LinkedListNode<CacheItem>(newItem);\n            lruList.AddFirst(newNode);\n            cache.Add(key, newNode);\n        }\n    }\n}",
  "tests": "using System;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: LRU Cache Implementierung\");\n        Console.WriteLine(new string('=', 50));\n\n        TestBasicOperations();\n        TestCapacityLimit();\n        TestUpdateExistingKey();\n        TestLRUEvictionPolicy();\n        TestEmptyCache();\n        TestSingleItemCache();\n        TestEdgeCases();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestBasicOperations()\n    {\n        Test(\"Grundlegende Operationen\", () => {\n            LRUCache cache = new LRUCache(2);\n            \n            cache.Put(1, 1);\n            cache.Put(2, 2);\n            \n            int value1 = cache.Get(1);\n            AssertEqual(1, value1, \"Wert f√ºr Schl√ºssel 1 sollte 1 sein\");\n            \n            cache.Put(3, 3);    // Entfernt Schl√ºssel 2\n            \n            int value2 = cache.Get(2);\n            AssertEqual(-1, value2, \"Schl√ºssel 2 sollte nicht mehr im Cache sein\");\n            \n            int value3 = cache.Get(3);\n            AssertEqual(3, value3, \"Wert f√ºr Schl√ºssel 3 sollte 3 sein\");\n        });\n    }\n\n    private static void TestCapacityLimit()\n    {\n        Test(\"Kapazit√§tsgrenze\", () => {\n            LRUCache cache = new LRUCache(3);\n            \n            cache.Put(1, 1);\n            cache.Put(2, 2);\n            cache.Put(3, 3);\n            cache.Put(4, 4);    // Entfernt Schl√ºssel 1\n            \n            int value1 = cache.Get(1);\n            AssertEqual(-1, value1, \"Schl√ºssel 1 sollte nicht mehr im Cache sein\");\n            \n            int value2 = cache.Get(2);\n            AssertEqual(2, value2, \"Wert f√ºr Schl√ºssel 2 sollte 2 sein\");\n        });\n    }\n\n    private static void TestUpdateExistingKey()\n    {\n        Test(\"Aktualisierung vorhandener Schl√ºssel\", () => {\n            LRUCache cache = new LRUCache(2);\n            \n            cache.Put(1, 1);\n            cache.Put(1, 10);  // Aktualisiere Wert f√ºr Schl√ºssel 1\n            \n            int value = cache.Get(1);\n            AssertEqual(10, value, \"Wert f√ºr Schl√ºssel 1 sollte auf 10 aktualisiert sein\");\n        });\n    }\n\n    private static void TestLRUEvictionPolicy()\n    {\n        Test(\"LRU Verdr√§ngungsrichtlinie\", () => {\n            LRUCache cache = new LRUCache(3);\n            \n            cache.Put(1, 1);\n            cache.Put(2, 2);\n            cache.Put(3, 3);\n            \n            // Zugriff auf Schl√ºssel 1, dadurch wird er als k√ºrzlich verwendet markiert\n            cache.Get(1);\n            \n            // F√ºge einen neuen Schl√ºssel hinzu, der die Kapazit√§t √ºberschreitet\n            cache.Put(4, 4);    // Sollte Schl√ºssel 2 entfernen, nicht 1\n            \n            int value1 = cache.Get(1);\n            AssertEqual(1, value1, \"Schl√ºssel 1 sollte noch im Cache sein\");\n            \n            int value2 = cache.Get(2);\n            AssertEqual(-1, value2, \"Schl√ºssel 2 sollte nicht mehr im Cache sein\");\n            \n            int value3 = cache.Get(3);\n            AssertEqual(3, value3, \"Schl√ºssel 3 sollte noch im Cache sein\");\n            \n            int value4 = cache.Get(4);\n            AssertEqual(4, value4, \"Schl√ºssel 4 sollte im Cache sein\");\n        });\n    }\n\n    private static void TestEmptyCache()\n    {\n        Test(\"Leerer Cache\", () => {\n            LRUCache cache = new LRUCache(0);\n            \n            cache.Put(1, 1);\n            int value = cache.Get(1);\n            \n            AssertEqual(-1, value, \"Schl√ºssel 1 sollte nicht im Cache sein, da die Kapazit√§t 0 ist\");\n        });\n    }\n\n    private static void TestSingleItemCache()\n    {\n        Test(\"Cache mit einem Element\", () => {\n            LRUCache cache = new LRUCache(1);\n            \n            cache.Put(1, 1);\n            int value1 = cache.Get(1);\n            AssertEqual(1, value1, \"Wert f√ºr Schl√ºssel 1 sollte 1 sein\");\n            \n            cache.Put(2, 2);    // Entfernt Schl√ºssel 1\n            int value2 = cache.Get(1);\n            AssertEqual(-1, value2, \"Schl√ºssel 1 sollte nicht mehr im Cache sein\");\n            \n            int value3 = cache.Get(2);\n            AssertEqual(2, value3, \"Wert f√ºr Schl√ºssel 2 sollte 2 sein\");\n        });\n    }\n\n    private static void TestEdgeCases()\n    {\n        Test(\"Grenzf√§lle\", () => {\n            LRUCache cache = new LRUCache(5);\n            \n            // F√ºge doppelte Schl√ºssel hinzu\n            cache.Put(1, 1);\n            cache.Put(1, 2);    // Aktualisiere Schl√ºssel 1\n            int value1 = cache.Get(1);\n            AssertEqual(2, value1, \"Wert f√ºr Schl√ºssel 1 sollte 2 sein\");\n            \n            // Zugriff auf nicht existierenden Schl√ºssel\n            int value2 = cache.Get(999);\n            AssertEqual(-1, value2, \"Nicht existierender Schl√ºssel sollte -1 zur√ºckgeben\");\n            \n            // Abrufen eines Schl√ºssels √§ndert die LRU-Reihenfolge\n            cache.Put(2, 2);\n            cache.Put(3, 3);\n            cache.Put(4, 4);\n            cache.Put(5, 5);\n            \n            // Jetzt ist der Cache voll: [5, 4, 3, 2, 1]\n            // Zugriff auf Schl√ºssel 2 √§ndert die Reihenfolge zu: [2, 5, 4, 3, 1]\n            cache.Get(2);\n            \n            // Hinzuf√ºgen eines neuen Schl√ºssels sollte Schl√ºssel 1 entfernen\n            cache.Put(6, 6);\n            int value3 = cache.Get(1);\n            AssertEqual(-1, value3, \"Schl√ºssel 1 sollte nicht mehr im Cache sein\");\n            \n            // Alle anderen Schl√ºssel sollten noch vorhanden sein\n            AssertEqual(2, cache.Get(2), \"Schl√ºssel 2 sollte noch im Cache sein\");\n            AssertEqual(3, cache.Get(3), \"Schl√ºssel 3 sollte noch im Cache sein\");\n            AssertEqual(4, cache.Get(4), \"Schl√ºssel 4 sollte noch im Cache sein\");\n            AssertEqual(5, cache.Get(5), \"Schl√ºssel 5 sollte noch im Cache sein\");\n            AssertEqual(6, cache.Get(6), \"Schl√ºssel 6 sollte im Cache sein\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEqual<T>(T expected, T actual, string message = null)\n    {\n        if (!Equals(expected, actual))\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {expected}, Erhalten: {actual}\");\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "LruCacheImplementierung",
  "functionName": "LruCacheImplementierung",
  "lastUpdated": 1751006869.330711
}
