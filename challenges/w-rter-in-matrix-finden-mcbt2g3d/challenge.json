{
  "id": "w-rter-in-matrix-finden-mcbt2g3d",
  "title": "W√∂rter in Matrix finden",
  "description": "Implementiere eine Funktion, die pr√ºft, ob ein gegebenes Wort in einer 2D-Matrix (Grid) von Buchstaben gefunden werden kann. Das Wort kann gebildet werden, indem benachbarte Zellen in der Matrix verkn√ºpft werden. Benachbarte Zellen sind horizontal oder vertikal miteinander verbunden (nicht diagonal). Die gleiche Zelle darf nicht mehrfach verwendet werden.\n\nBeispiel:\n\n```\nMatrix:\n['A', 'B', 'C', 'E']\n['S', 'F', 'C', 'S']\n['A', 'D', 'E', 'E']\n\nWort: \"ABCCED\" -> true\nWort: \"SEE\" -> true\nWort: \"ABCB\" -> false\n```\n\nErkl√§rung:\n- \"ABCCED\" kann gefunden werden, beginnend mit 'A' in der oberen linken Ecke, dann nach rechts zu 'B' und 'C', dann nach unten zu 'C', dann diagonal nach unten links zu 'E' und schlie√ülich zu 'D'.\n- \"SEE\" kann gefunden werden, beginnend mit 'S' in der oberen rechten Ecke, dann nach unten zu 'E' und nach rechts zu 'E'.\n- \"ABCB\" kann nicht gefunden werden, weil nach dem Pfad 'A'->'B'->'C' w√ºrde es wieder zur√ºck zu 'B' gehen m√ºssen, aber die Zelle mit 'B' wurde bereits verwendet.",
  "difficulty": "medium",
  "language": "csharp",
  "tags": [
    "graph",
    "dfs",
    "backtracking",
    "matrix",
    "recursion",
    "algorithms",
    "csharp",
    "medium"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:22:29.340Z",
  "status": "reported",
  "starterCode": "using System;\n\npublic class WordFinder\n{\n    /// <summary>\n    /// Pr√ºft, ob ein gegebenes Wort in einer 2D-Matrix gefunden werden kann.\n    /// Das Wort kann gebildet werden, indem benachbarte Zellen in der Matrix verkn√ºpft werden.\n    /// Benachbarte Zellen sind horizontal oder vertikal miteinander verbunden (nicht diagonal).\n    /// Die gleiche Zelle darf nicht mehrfach verwendet werden.\n    /// </summary>\n    /// <param name=\"board\">Die 2D-Matrix von Buchstaben</param>\n    /// <param name=\"word\">Das zu suchende Wort</param>\n    /// <returns>True, wenn das Wort gefunden werden kann, sonst False</returns>\n    public static bool Exist(char[,] board, string word)\n    {\n        // TODO: Implementiere deine L√∂sung hier\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\n\npublic class WordFinder\n{\n    /// <summary>\n    /// Pr√ºft, ob ein gegebenes Wort in einer 2D-Matrix gefunden werden kann.\n    /// Das Wort kann gebildet werden, indem benachbarte Zellen in der Matrix verkn√ºpft werden.\n    /// Benachbarte Zellen sind horizontal oder vertikal miteinander verbunden (nicht diagonal).\n    /// Die gleiche Zelle darf nicht mehrfach verwendet werden.\n    /// </summary>\n    /// <param name=\"board\">Die 2D-Matrix von Buchstaben</param>\n    /// <param name=\"word\">Das zu suchende Wort</param>\n    /// <returns>True, wenn das Wort gefunden werden kann, sonst False</returns>\n    public static bool Exist(char[,] board, string word)\n    {\n        int rows = board.GetLength(0);\n        int cols = board.GetLength(1);\n        \n        // Sonderfall: Leeres Wort ist immer gefunden\n        if (string.IsNullOrEmpty(word))\n        {\n            return true;\n        }\n        \n        // Sonderfall: Leeres Board kann kein Wort enthalten\n        if (rows == 0 || cols == 0)\n        {\n            return false;\n        }\n        \n        // Suche nach dem ersten Buchstaben des Wortes in der Matrix\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < cols; j++)\n            {\n                // Wenn der erste Buchstabe gefunden wurde, starte die Suche\n                if (board[i, j] == word[0])\n                {\n                    // Verwende eine 2D-Matrix, um zu verfolgen, welche Zellen bereits besucht wurden\n                    bool[,] visited = new bool[rows, cols];\n                    \n                    // Markiere die aktuelle Zelle als besucht\n                    visited[i, j] = true;\n                    \n                    // Starte die rekursive Suche nach dem Rest des Wortes\n                    if (DFS(board, word, 1, i, j, visited))\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        \n        // Wort wurde nicht gefunden\n        return false;\n    }\n    \n    /// <summary>\n    /// F√ºhrt eine Tiefensuche (DFS) durch, um zu pr√ºfen, ob der Rest des Wortes in der Matrix gefunden werden kann.\n    /// </summary>\n    /// <param name=\"board\">Die 2D-Matrix von Buchstaben</param>\n    /// <param name=\"word\">Das zu suchende Wort</param>\n    /// <param name=\"index\">Der aktuelle Index im Wort</param>\n    /// <param name=\"row\">Die aktuelle Zeile in der Matrix</param>\n    /// <param name=\"col\">Die aktuelle Spalte in der Matrix</param>\n    /// <param name=\"visited\">Matrix, die angibt, welche Zellen bereits besucht wurden</param>\n    /// <returns>True, wenn der Rest des Wortes gefunden werden kann, sonst False</returns>\n    private static bool DFS(char[,] board, string word, int index, int row, int col, bool[,] visited)\n    {\n        // Wenn wir das Ende des Wortes erreicht haben, wurde das Wort gefunden\n        if (index == word.Length)\n        {\n            return true;\n        }\n        \n        int rows = board.GetLength(0);\n        int cols = board.GetLength(1);\n        \n        // Die vier m√∂glichen Richtungen: oben, rechts, unten, links\n        int[] dx = { -1, 0, 1, 0 };\n        int[] dy = { 0, 1, 0, -1 };\n        \n        // √úberpr√ºfe alle vier Richtungen\n        for (int i = 0; i < 4; i++)\n        {\n            int newRow = row + dx[i];\n            int newCol = col + dy[i];\n            \n            // √úberpr√ºfe, ob die neue Position g√ºltig ist\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols)\n            {\n                // √úberpr√ºfe, ob die Zelle nicht besucht wurde und der Buchstabe √ºbereinstimmt\n                if (!visited[newRow, newCol] && board[newRow, newCol] == word[index])\n                {\n                    // Markiere die Zelle als besucht\n                    visited[newRow, newCol] = true;\n                    \n                    // Rekursiver Aufruf f√ºr den n√§chsten Buchstaben\n                    if (DFS(board, word, index + 1, newRow, newCol, visited))\n                    {\n                        return true;\n                    }\n                    \n                    // Backtracking: Markiere die Zelle wieder als nicht besucht\n                    visited[newRow, newCol] = false;\n                }\n            }\n        }\n        \n        // Keine g√ºltige L√∂sung gefunden\n        return false;\n    }\n}",
  "tests": "using System;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: W√∂rter in Matrix finden\");\n        Console.WriteLine(new string('=', 50));\n\n        TestBasicCases();\n        TestEmptyWordAndBoard();\n        TestWordTooLong();\n        TestNonExistentWord();\n        TestWordWithRepeatedCharacters();\n        TestLargeBoard();\n        TestZigZagPattern();\n        TestSingleCharacterWord();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestBasicCases()\n    {\n        Test(\"Beispiel aus der Aufgabenstellung - ABCCED\", () => {\n            char[,] board = {\n                {'A', 'B', 'C', 'E'},\n                {'S', 'F', 'C', 'S'},\n                {'A', 'D', 'E', 'E'}\n            };\n            bool result = WordFinder.Exist(board, \"ABCCED\");\n            AssertEqual(true, result, \"Das Wort 'ABCCED' sollte in der Matrix gefunden werden\");\n        });\n\n        Test(\"Beispiel aus der Aufgabenstellung - SEE\", () => {\n            char[,] board = {\n                {'A', 'B', 'C', 'E'},\n                {'S', 'F', 'C', 'S'},\n                {'A', 'D', 'E', 'E'}\n            };\n            bool result = WordFinder.Exist(board, \"SEE\");\n            AssertEqual(true, result, \"Das Wort 'SEE' sollte in der Matrix gefunden werden\");\n        });\n\n        Test(\"Beispiel aus der Aufgabenstellung - ABCB\", () => {\n            char[,] board = {\n                {'A', 'B', 'C', 'E'},\n                {'S', 'F', 'C', 'S'},\n                {'A', 'D', 'E', 'E'}\n            };\n            bool result = WordFinder.Exist(board, \"ABCB\");\n            AssertEqual(false, result, \"Das Wort 'ABCB' sollte nicht in der Matrix gefunden werden\");\n        });\n    }\n\n    private static void TestEmptyWordAndBoard()\n    {\n        Test(\"Leeres Wort\", () => {\n            char[,] board = {\n                {'A', 'B'},\n                {'C', 'D'}\n            };\n            bool result = WordFinder.Exist(board, \"\");\n            AssertEqual(true, result, \"Ein leeres Wort sollte immer gefunden werden\");\n        });\n\n        Test(\"Leeres Board\", () => {\n            char[,] board = new char[0, 0];\n            bool result = WordFinder.Exist(board, \"ABC\");\n            AssertEqual(false, result, \"Ein Wort kann in einer leeren Matrix nicht gefunden werden\");\n        });\n    }\n\n    private static void TestWordTooLong()\n    {\n        Test(\"Wort l√§nger als m√∂gliche Pfade\", () => {\n            char[,] board = {\n                {'A', 'B'},\n                {'C', 'D'}\n            };\n            bool result = WordFinder.Exist(board, \"ABCDEFG\");\n            AssertEqual(false, result, \"Ein Wort, das l√§nger ist als m√∂gliche Pfade, sollte nicht gefunden werden\");\n        });\n    }\n\n    private static void TestNonExistentWord()\n    {\n        Test(\"Nicht existierendes Wort\", () => {\n            char[,] board = {\n                {'A', 'B', 'C'},\n                {'D', 'E', 'F'},\n                {'G', 'H', 'I'}\n            };\n            bool result = WordFinder.Exist(board, \"XYZ\");\n            AssertEqual(false, result, \"Ein Wort mit Buchstaben, die nicht im Board vorkommen, sollte nicht gefunden werden\");\n        });\n    }\n\n    private static void TestWordWithRepeatedCharacters()\n    {\n        Test(\"Wort mit wiederholten Zeichen\", () => {\n            char[,] board = {\n                {'A', 'A', 'A'},\n                {'A', 'B', 'A'},\n                {'A', 'A', 'A'}\n            };\n            bool result = WordFinder.Exist(board, \"AAAAA\");\n            AssertEqual(true, result, \"Ein Wort mit wiederholten Zeichen sollte gefunden werden, wenn es einen g√ºltigen Pfad gibt\");\n        });\n    }\n\n    private static void TestLargeBoard()\n    {\n        Test(\"Gro√ües Board\", () => {\n            char[,] board = {\n                {'A', 'B', 'C', 'D', 'E'},\n                {'F', 'G', 'H', 'I', 'J'},\n                {'K', 'L', 'M', 'N', 'O'},\n                {'P', 'Q', 'R', 'S', 'T'},\n                {'U', 'V', 'W', 'X', 'Y'}\n            };\n            bool result = WordFinder.Exist(board, \"FGLQVWST\");\n            AssertEqual(true, result, \"Ein komplexes Wort in einem gro√üen Board sollte gefunden werden\");\n        });\n    }\n\n    private static void TestZigZagPattern()\n    {\n        Test(\"Zick-Zack-Muster\", () => {\n            char[,] board = {\n                {'A', 'B', 'C', 'D'},\n                {'E', 'F', 'G', 'H'},\n                {'I', 'J', 'K', 'L'}\n            };\n            bool result = WordFinder.Exist(board, \"AFJGKL\");\n            AssertEqual(true, result, \"Ein Wort, das einen Zick-Zack-Pfad bildet, sollte gefunden werden\");\n        });\n    }\n\n    private static void TestSingleCharacterWord()\n    {\n        Test(\"Einzelnes Zeichen\", () => {\n            char[,] board = {\n                {'A', 'B'},\n                {'C', 'D'}\n            };\n            bool result = WordFinder.Exist(board, \"A\");\n            AssertEqual(true, result, \"Ein einzelnes Zeichen, das im Board vorkommt, sollte gefunden werden\");\n\n            result = WordFinder.Exist(board, \"Z\");\n            AssertEqual(false, result, \"Ein einzelnes Zeichen, das nicht im Board vorkommt, sollte nicht gefunden werden\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEqual<T>(T expected, T actual, string message = null)\n    {\n        if (!Equals(expected, actual))\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {expected}, Erhalten: {actual}\");\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "WrterInMatrixFinden",
  "functionName": "WrterInMatrixFinden",
  "reportedIssueNumber": 65,
  "reportedIssueUrl": "https://github.com/Jodo2410/Code-Challenge/issues/65",
  "isHidden": true
}