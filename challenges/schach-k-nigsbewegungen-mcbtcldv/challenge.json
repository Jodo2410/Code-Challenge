{
  "id": "schach-k-nigsbewegungen-mcbtcldv",
  "title": "Schach - K√∂nigsbewegungen",
  "description": "In einem Schachspiel m√∂chtest du wissen, ob ein K√∂nig von seiner aktuellen Position zu einer Zielposition gelangen kann, ohne von gegnerischen Figuren geschlagen zu werden.\n\nImplementiere eine Funktion, die √ºberpr√ºft, ob der K√∂nig sicher von Start zu Ziel navigieren kann. Der K√∂nig kann sich in jede angrenzende Position bewegen (horizontal, vertikal oder diagonal), aber er darf sich nicht auf Felder bewegen, die von gegnerischen Figuren bedroht sind.\n\nDas Schachbrett wird als 8x8-Grid dargestellt:\n- 'K' ist die Position des K√∂nigs (Start)\n- 'T' ist die Zielposition\n- 'X' sind Felder, die von gegnerischen Figuren bedroht werden\n- '.' sind freie, sichere Felder\n\nBeispiel:\n```\nSchachbrett:\n[\n  ['.', '.', '.', '.', '.', '.', '.', '.'],\n  ['.', '.', 'X', 'X', '.', '.', '.', '.'],\n  ['.', '.', '.', '.', '.', 'X', '.', '.'],\n  ['.', 'X', 'K', '.', '.', '.', '.', '.'],\n  ['.', '.', '.', '.', '.', 'X', '.', '.'],\n  ['.', '.', '.', '.', '.', '.', '.', '.'],\n  ['.', '.', '.', 'T', '.', '.', '.', '.'],\n  ['.', '.', '.', '.', '.', '.', '.', '.']\n]\n\nAusgabe: true\n```\n\nErkl√§rung: Der K√∂nig kann sicher von (3,2) nach (6,3) gelangen, indem er einen Pfad w√§hlt, der alle bedrohten Felder vermeidet.",
  "difficulty": "easy",
  "language": "csharp",
  "tags": [
    "games",
    "chess",
    "pathfinding",
    "bfs",
    "grid",
    "2d-array",
    "csharp",
    "easy"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:30:22.724Z",
  "status": "approved",
  "starterCode": "using System;\nusing System.Collections.Generic;\n\npublic class ChessKingMoves\n{\n    /// <summary>\n    /// √úberpr√ºft, ob der K√∂nig sicher von seiner Startposition zur Zielposition gelangen kann.\n    /// </summary>\n    /// <param name=\"board\">Das Schachbrett als 8x8 char-Array</param>\n    /// <returns>True, wenn der K√∂nig sicher zum Ziel gelangen kann, sonst False</returns>\n    public static bool CanKingReachTarget(char[,] board)\n    {\n        // TODO: Implementiere deine L√∂sung hier\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\nusing System.Collections.Generic;\n\npublic class ChessKingMoves\n{\n    /// <summary>\n    /// √úberpr√ºft, ob der K√∂nig sicher von seiner Startposition zur Zielposition gelangen kann.\n    /// </summary>\n    /// <param name=\"board\">Das Schachbrett als 8x8 char-Array</param>\n    /// <returns>True, wenn der K√∂nig sicher zum Ziel gelangen kann, sonst False</returns>\n    public static bool CanKingReachTarget(char[,] board)\n    {\n        if (board == null)\n            return false;\n        \n        int rows = board.GetLength(0);\n        int cols = board.GetLength(1);\n        \n        // Finde die Position des K√∂nigs und des Ziels\n        int kingRow = -1, kingCol = -1;\n        int targetRow = -1, targetCol = -1;\n        \n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < cols; j++)\n            {\n                if (board[i, j] == 'K')\n                {\n                    kingRow = i;\n                    kingCol = j;\n                }\n                else if (board[i, j] == 'T')\n                {\n                    targetRow = i;\n                    targetCol = j;\n                }\n            }\n        }\n        \n        // √úberpr√ºfe, ob K√∂nig oder Ziel gefunden wurden\n        if (kingRow == -1 || targetRow == -1)\n            return false;\n        \n        // Breitensuche (BFS) zur Wegfindung\n        Queue<(int, int)> queue = new Queue<(int, int)>();\n        bool[,] visited = new bool[rows, cols];\n        \n        queue.Enqueue((kingRow, kingCol));\n        visited[kingRow, kingCol] = true;\n        \n        // M√∂gliche Bewegungsrichtungen f√ºr den K√∂nig (8 Richtungen)\n        int[] dr = { -1, -1, 0, 1, 1, 1, 0, -1 };\n        int[] dc = { 0, 1, 1, 1, 0, -1, -1, -1 };\n        \n        while (queue.Count > 0)\n        {\n            var (row, col) = queue.Dequeue();\n            \n            // Ziel erreicht\n            if (row == targetRow && col == targetCol)\n                return true;\n            \n            // Pr√ºfe alle acht Richtungen\n            for (int i = 0; i < 8; i++)\n            {\n                int newRow = row + dr[i];\n                int newCol = col + dc[i];\n                \n                // Pr√ºfe, ob die neue Position g√ºltig, sicher und noch nicht besucht ist\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && \n                    !visited[newRow, newCol] && board[newRow, newCol] != 'X')\n                {\n                    queue.Enqueue((newRow, newCol));\n                    visited[newRow, newCol] = true;\n                }\n            }\n        }\n        \n        // Kein Weg gefunden\n        return false;\n    }\n}",
  "tests": "using System;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: Schach - K√∂nigsbewegungen\");\n        Console.WriteLine(new string('=', 50));\n\n        TestExample();\n        TestNoPath();\n        TestDirectPath();\n        TestEmptyBoard();\n        TestBlockedByEnemies();\n        TestComplexPath();\n        TestNullBoard();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestExample()\n    {\n        Test(\"Beispiel aus der Aufgabenstellung\", () => {\n            char[,] board = new char[,]\n            {\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', 'X', 'X', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', 'X', '.', '.'},\n                {'.', 'X', 'K', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', 'X', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', 'T', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'}\n            };\n\n            bool result = ChessKingMoves.CanKingReachTarget(board);\n            AssertEqual(true, result, \"Der K√∂nig sollte das Ziel erreichen k√∂nnen\");\n        });\n    }\n\n    private static void TestNoPath()\n    {\n        Test(\"Kein Weg m√∂glich\", () => {\n            char[,] board = new char[,]\n            {\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', 'X', 'X', '.', '.', '.', '.'},\n                {'.', '.', 'X', 'X', 'X', 'X', '.', '.'},\n                {'.', 'X', 'K', 'X', 'X', 'X', '.', '.'},\n                {'.', '.', 'X', 'X', 'X', 'X', '.', '.'},\n                {'.', '.', 'X', 'X', '.', '.', '.', '.'},\n                {'.', '.', '.', 'T', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'}\n            };\n\n            bool result = ChessKingMoves.CanKingReachTarget(board);\n            AssertEqual(false, result, \"Der K√∂nig sollte durch die Barriere aus bedrohten Feldern nicht zum Ziel gelangen k√∂nnen\");\n        });\n    }\n\n    private static void TestDirectPath()\n    {\n        Test(\"Direkter Weg\", () => {\n            char[,] board = new char[,]\n            {\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', 'K', 'T', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'}\n            };\n\n            bool result = ChessKingMoves.CanKingReachTarget(board);\n            AssertEqual(true, result, \"Der K√∂nig sollte direkt zum benachbarten Zielfeld gehen k√∂nnen\");\n        });\n    }\n\n    private static void TestEmptyBoard()\n    {\n        Test(\"Leeres Brett\", () => {\n            char[,] board = new char[0, 0];\n\n            bool result = ChessKingMoves.CanKingReachTarget(board);\n            AssertEqual(false, result, \"Bei leerem Brett sollte false zur√ºckgegeben werden\");\n        });\n    }\n\n    private static void TestBlockedByEnemies()\n    {\n        Test(\"Von Feinden umzingelt\", () => {\n            char[,] board = new char[,]\n            {\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', 'X', 'X', 'X', '.', '.', '.'},\n                {'.', '.', 'X', 'K', 'X', '.', '.', '.'},\n                {'.', '.', 'X', 'X', 'X', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', 'T', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', '.'}\n            };\n\n            bool result = ChessKingMoves.CanKingReachTarget(board);\n            AssertEqual(false, result, \"Der K√∂nig sollte nicht zum Ziel gelangen k√∂nnen, wenn er von Feinden umzingelt ist\");\n        });\n    }\n\n    private static void TestComplexPath()\n    {\n        Test(\"Komplexer Pfad\", () => {\n            char[,] board = new char[,]\n            {\n                {'K', '.', 'X', '.', '.', '.', '.', '.'},\n                {'.', '.', 'X', 'X', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', 'X', '.', '.'},\n                {'.', 'X', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', 'X', '.', '.'},\n                {'.', '.', 'X', '.', '.', '.', '.', '.'},\n                {'.', 'X', '.', '.', '.', '.', '.', '.'},\n                {'.', '.', '.', '.', '.', '.', '.', 'T'}\n            };\n\n            bool result = ChessKingMoves.CanKingReachTarget(board);\n            AssertEqual(true, result, \"Der K√∂nig sollte einen komplexen Pfad zum Ziel finden k√∂nnen\");\n        });\n    }\n\n    private static void TestNullBoard()\n    {\n        Test(\"Null-Brett\", () => {\n            bool result = ChessKingMoves.CanKingReachTarget(null);\n            AssertEqual(false, result, \"Bei null-Brett sollte false zur√ºckgegeben werden\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEqual<T>(T expected, T actual, string message = null)\n    {\n        if (!Equals(expected, actual))\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {expected}, Erhalten: {actual}\");\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "SchachKnigsbewegungen",
  "functionName": "SchachKnigsbewegungen",
  "lastUpdated": 1751006869.381068
}
