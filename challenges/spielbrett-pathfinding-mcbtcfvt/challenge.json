{
  "id": "spielbrett-pathfinding-mcbtcfvt",
  "title": "Spielbrett-Pathfinding",
  "description": "Du entwickelst ein Brettspiel, in dem ein Spieler von einem Startpunkt zu einem Zielpunkt navigieren muss. Das Spielbrett ist ein Gitter aus Feldern, wobei einige Felder Hindernisse enthalten, die nicht betreten werden k√∂nnen.\n\nImplementiere eine Funktion, die den k√ºrzesten Weg vom Start zum Ziel findet, oder -1 zur√ºckgibt, wenn kein Weg existiert.\n\nDas Spielbrett wird als 2D-Array dargestellt, wobei:\n- 0 f√ºr ein freies Feld steht\n- 1 f√ºr ein Hindernis steht\n- 2 f√ºr den Startpunkt steht\n- 3 f√ºr den Zielpunkt steht\n\nDer Spieler kann sich horizontal und vertikal (nicht diagonal) bewegen.\n\nBeispiel:\n```\nSpielfeld:\n[\n  [0, 0, 0, 0],\n  [0, 1, 1, 0],\n  [2, 0, 0, 0],\n  [1, 1, 0, 3]\n]\n\nAusgabe: 5\n```\n\nErkl√§rung: Der k√ºrzeste Weg vom Start (2,0) zum Ziel (3,3) hat 5 Schritte:\n(2,0) -> (2,1) -> (2,2) -> (2,3) -> (3,3)\n\nBeachte, dass die Koordinaten im Format (Zeile, Spalte) angegeben sind.",
  "difficulty": "medium",
  "language": "csharp",
  "tags": [
    "games",
    "pathfinding",
    "bfs",
    "2d-array",
    "algorithms",
    "grid",
    "csharp",
    "medium"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:30:15.611Z",
  "status": "approved",
  "starterCode": "using System;\nusing System.Collections.Generic;\n\npublic class GamePathfinder\n{\n    /// <summary>\n    /// Findet den k√ºrzesten Weg vom Start- zum Zielpunkt auf dem Spielbrett.\n    /// </summary>\n    /// <param name=\"board\">Das Spielbrett als 2D-Array: 0=frei, 1=Hindernis, 2=Start, 3=Ziel</param>\n    /// <returns>Die minimale Anzahl von Schritten oder -1, wenn kein Weg existiert</returns>\n    public static int FindShortestPath(int[,] board)\n    {\n        // TODO: Implementiere deine L√∂sung hier\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\nusing System.Collections.Generic;\n\npublic class GamePathfinder\n{\n    /// <summary>\n    /// Findet den k√ºrzesten Weg vom Start- zum Zielpunkt auf dem Spielbrett.\n    /// </summary>\n    /// <param name=\"board\">Das Spielbrett als 2D-Array: 0=frei, 1=Hindernis, 2=Start, 3=Ziel</param>\n    /// <returns>Die minimale Anzahl von Schritten oder -1, wenn kein Weg existiert</returns>\n    public static int FindShortestPath(int[,] board)\n    {\n        if (board == null)\n            return -1;\n\n        int rows = board.GetLength(0);\n        int cols = board.GetLength(1);\n\n        // Finde Start- und Zielposition\n        int startRow = -1, startCol = -1;\n        int targetRow = -1, targetCol = -1;\n\n        for (int i = 0; i < rows; i++)\n        {\n            for (int j = 0; j < cols; j++)\n            {\n                if (board[i, j] == 2)  // Start\n                {\n                    startRow = i;\n                    startCol = j;\n                }\n                else if (board[i, j] == 3)  // Ziel\n                {\n                    targetRow = i;\n                    targetCol = j;\n                }\n            }\n        }\n\n        // Wenn Start oder Ziel nicht gefunden wurden\n        if (startRow == -1 || targetRow == -1)\n            return -1;\n\n        // BFS zum Finden des k√ºrzesten Weges\n        Queue<(int, int, int)> queue = new Queue<(int, int, int)>();  // (Zeile, Spalte, Schritte)\n        bool[,] visited = new bool[rows, cols];\n        \n        queue.Enqueue((startRow, startCol, 0));\n        visited[startRow, startCol] = true;\n\n        // M√∂gliche Bewegungsrichtungen: oben, rechts, unten, links\n        int[] dr = { -1, 0, 1, 0 };\n        int[] dc = { 0, 1, 0, -1 };\n\n        while (queue.Count > 0)\n        {\n            var (row, col, steps) = queue.Dequeue();\n\n            // Ziel erreicht\n            if (row == targetRow && col == targetCol)\n                return steps;\n\n            // Pr√ºfe alle vier Richtungen\n            for (int i = 0; i < 4; i++)\n            {\n                int newRow = row + dr[i];\n                int newCol = col + dc[i];\n\n                // Pr√ºfe, ob die neue Position g√ºltig ist\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols \n                    && !visited[newRow, newCol] && board[newRow, newCol] != 1)\n                {\n                    queue.Enqueue((newRow, newCol, steps + 1));\n                    visited[newRow, newCol] = true;\n                }\n            }\n        }\n\n        // Kein Weg gefunden\n        return -1;\n    }\n}",
  "tests": "using System;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: Spielbrett-Pathfinding\");\n        Console.WriteLine(new string('=', 50));\n\n        TestExample();\n        TestNoPath();\n        TestDirectPath();\n        TestEmptyBoard();\n        TestLargeBoard();\n        TestNullBoard();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestExample()\n    {\n        Test(\"Beispiel aus der Aufgabenstellung\", () => {\n            int[,] board = new int[,]\n            {\n                {0, 0, 0, 0},\n                {0, 1, 1, 0},\n                {2, 0, 0, 0},\n                {1, 1, 0, 3}\n            };\n\n            int result = GamePathfinder.FindShortestPath(board);\n            AssertEqual(5, result, \"Der k√ºrzeste Weg sollte 5 Schritte haben\");\n        });\n    }\n\n    private static void TestNoPath()\n    {\n        Test(\"Kein Weg m√∂glich\", () => {\n            int[,] board = new int[,]\n            {\n                {0, 1, 0, 0},\n                {0, 1, 1, 0},\n                {2, 1, 0, 0},\n                {1, 1, 0, 3}\n            };\n\n            int result = GamePathfinder.FindShortestPath(board);\n            AssertEqual(-1, result, \"Es sollte kein Weg gefunden werden\");\n        });\n    }\n\n    private static void TestDirectPath()\n    {\n        Test(\"Direkter Weg\", () => {\n            int[,] board = new int[,]\n            {\n                {2, 0, 0, 3},\n            };\n\n            int result = GamePathfinder.FindShortestPath(board);\n            AssertEqual(3, result, \"Der k√ºrzeste Weg sollte 3 Schritte haben\");\n        });\n    }\n\n    private static void TestEmptyBoard()\n    {\n        Test(\"Leeres Brett\", () => {\n            int[,] board = new int[,] {};\n\n            int result = GamePathfinder.FindShortestPath(board);\n            AssertEqual(-1, result, \"Bei leerem Brett sollte -1 zur√ºckgegeben werden\");\n        });\n    }\n\n    private static void TestLargeBoard()\n    {\n        Test(\"Gro√ües Brett\", () => {\n            int[,] board = new int[10, 10];\n            // Setze Start- und Zielpunkt\n            board[0, 0] = 2;\n            board[9, 9] = 3;\n            // Erstelle ein Labyrinth\n            for (int i = 1; i < 9; i += 2)\n            {\n                for (int j = 0; j < 9; j++)\n                {\n                    board[i, j] = 1;\n                }\n                // Lasse eine L√ºcke\n                board[i, i] = 0;\n            }\n\n            int result = GamePathfinder.FindShortestPath(board);\n            AssertEqual(18, result, \"Der k√ºrzeste Weg durch das Labyrinth sollte 18 Schritte haben\");\n        });\n    }\n\n    private static void TestNullBoard()\n    {\n        Test(\"Null-Brett\", () => {\n            int result = GamePathfinder.FindShortestPath(null);\n            AssertEqual(-1, result, \"Bei null-Brett sollte -1 zur√ºckgegeben werden\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEqual<T>(T expected, T actual, string message = null)\n    {\n        if (!Equals(expected, actual))\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {expected}, Erhalten: {actual}\");\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "Spielbrettpathfinding",
  "functionName": "Spielbrettpathfinding",
  "reportedIssueNumber": 58,
  "reportedIssueUrl": "https://github.com/Jodo2410/Code-Challenge/issues/58",
  "isHidden": true
}
