{
  "id": "minimale-editierdistanz-mcbt9gqx",
  "title": "Minimale Editierdistanz",
  "description": "Gegeben sind zwei Strings word1 und word2. Berechne die minimale Anzahl von Operationen, die ben√∂tigt werden, um word1 in word2 umzuwandeln.\n\nDu darfst die folgenden drei Operationen auf einem String ausf√ºhren:\n- Einf√ºgen eines Zeichens\n- L√∂schen eines Zeichens\n- Ersetzen eines Zeichens\n\nBeispiele:\n\n```\nword1 = \"horse\", word2 = \"ros\"\nAusgabe: 3\nErkl√§rung: \nhorse -> rorse (ersetze 'h' durch 'r')\nrorse -> rose (l√∂sche 'r')\nrose -> ros (l√∂sche 'e')\n\nword1 = \"intention\", word2 = \"execution\"\nAusgabe: 5\nErkl√§rung: \nintention -> inention (l√∂sche 't')\ninention -> enention (ersetze 'i' durch 'e')\nenention -> exention (ersetze 'n' durch 'x')\nexention -> exection (ersetze 'n' durch 'c')\nexection -> execution (f√ºge 'u' ein)\n```\n\nDieses Problem ist auch bekannt als Levenshtein-Distanz und hat wichtige Anwendungen in der Textverarbeitung, Spracherkennung und der DNA-Sequenzanalyse.",
  "difficulty": "hard",
  "language": "csharp",
  "tags": [
    "dynamic-programming",
    "strings",
    "algorithms",
    "levenshtein-distance",
    "csharp",
    "hard"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:27:56.781Z",
  "status": "approved",
  "starterCode": "using System;\n\npublic class EditDistance\n{\n    /// <summary>\n    /// Berechnet die minimale Anzahl von Operationen, die ben√∂tigt werden, um word1 in word2 umzuwandeln.\n    /// </summary>\n    /// <param name=\"word1\">Das erste Wort</param>\n    /// <param name=\"word2\">Das zweite Wort</param>\n    /// <returns>Die minimale Editierdistanz</returns>\n    public static int MinDistance(string word1, string word2)\n    {\n        // TODO: Implementiere deine L√∂sung hier\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\n\npublic class EditDistance\n{\n    /// <summary>\n    /// Berechnet die minimale Anzahl von Operationen, die ben√∂tigt werden, um word1 in word2 umzuwandeln.\n    /// </summary>\n    /// <param name=\"word1\">Das erste Wort</param>\n    /// <param name=\"word2\">Das zweite Wort</param>\n    /// <returns>Die minimale Editierdistanz</returns>\n    public static int MinDistance(string word1, string word2)\n    {\n        // Behandle null-Eingaben\n        if (word1 == null) word1 = \"\";\n        if (word2 == null) word2 = \"\";\n        \n        int m = word1.Length;\n        int n = word2.Length;\n        \n        // Wenn eines der W√∂rter leer ist, ist die Distanz gleich der L√§nge des anderen Wortes\n        if (m == 0) return n;\n        if (n == 0) return m;\n        \n        // Erstelle eine DP-Tabelle\n        // dp[i,j] = minimale Operationen, um word1[0..i-1] in word2[0..j-1] umzuwandeln\n        int[,] dp = new int[m + 1, n + 1];\n        \n        // Initialisiere die erste Zeile und Spalte\n        // Dies repr√§sentiert das Umwandeln in oder von einem leeren String\n        for (int i = 0; i <= m; i++)\n        {\n            dp[i, 0] = i; // Es kostet i L√∂schungen, um word1[0..i-1] in einen leeren String umzuwandeln\n        }\n        \n        for (int j = 0; j <= n; j++)\n        {\n            dp[0, j] = j; // Es kostet j Einf√ºgungen, um einen leeren String in word2[0..j-1] umzuwandeln\n        }\n        \n        // F√ºlle die DP-Tabelle aus\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                // Wenn die aktuellen Zeichen gleich sind, keine Operation notwendig\n                if (word1[i - 1] == word2[j - 1])\n                {\n                    dp[i, j] = dp[i - 1, j - 1];\n                }\n                else\n                {\n                    // W√§hle die beste Operation: Einf√ºgen, L√∂schen oder Ersetzen\n                    dp[i, j] = 1 + Math.Min(\n                        Math.Min(\n                            dp[i - 1, j],   // L√∂schen\n                            dp[i, j - 1]),  // Einf√ºgen\n                        dp[i - 1, j - 1]    // Ersetzen\n                    );\n                }\n            }\n        }\n        \n        // Das Ergebnis ist in der unteren rechten Ecke der Tabelle\n        return dp[m, n];\n    }\n}",
  "tests": "using System;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: Minimale Editierdistanz\");\n        Console.WriteLine(new string('=', 50));\n\n        TestBasicCases();\n        TestEdgeCases();\n        TestEmptyStrings();\n        TestSameStrings();\n        TestLargeStrings();\n        TestNullInput();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestBasicCases()\n    {\n        Test(\"Beispiele aus der Aufgabenstellung\", () => {\n            int distance = EditDistance.MinDistance(\"horse\", \"ros\");\n            AssertEqual(3, distance, \"Die Editierdistanz zwischen 'horse' und 'ros' sollte 3 sein\");\n            \n            distance = EditDistance.MinDistance(\"intention\", \"execution\");\n            AssertEqual(5, distance, \"Die Editierdistanz zwischen 'intention' und 'execution' sollte 5 sein\");\n        });\n    }\n\n    private static void TestEdgeCases()\n    {\n        Test(\"Einfache Operationen\", () => {\n            // Einzelne Einf√ºgung\n            int distance = EditDistance.MinDistance(\"abc\", \"abcd\");\n            AssertEqual(1, distance, \"Eine Einf√ºgung sollte die Distanz 1 haben\");\n            \n            // Einzelne L√∂schung\n            distance = EditDistance.MinDistance(\"abcd\", \"abc\");\n            AssertEqual(1, distance, \"Eine L√∂schung sollte die Distanz 1 haben\");\n            \n            // Einzelne Ersetzung\n            distance = EditDistance.MinDistance(\"abc\", \"abd\");\n            AssertEqual(1, distance, \"Eine Ersetzung sollte die Distanz 1 haben\");\n        });\n    }\n\n    private static void TestEmptyStrings()\n    {\n        Test(\"Leere Strings\", () => {\n            // Leerer String zu nicht-leerem String\n            int distance = EditDistance.MinDistance(\"\", \"abc\");\n            AssertEqual(3, distance, \"Die Distanz von leerem String zu 'abc' sollte 3 sein (3 Einf√ºgungen)\");\n            \n            // Nicht-leerer String zu leerem String\n            distance = EditDistance.MinDistance(\"abc\", \"\");\n            AssertEqual(3, distance, \"Die Distanz von 'abc' zu leerem String sollte 3 sein (3 L√∂schungen)\");\n            \n            // Beide Strings leer\n            distance = EditDistance.MinDistance(\"\", \"\");\n            AssertEqual(0, distance, \"Die Distanz zwischen zwei leeren Strings sollte 0 sein\");\n        });\n    }\n\n    private static void TestSameStrings()\n    {\n        Test(\"Identische Strings\", () => {\n            int distance = EditDistance.MinDistance(\"abc\", \"abc\");\n            AssertEqual(0, distance, \"Die Distanz zwischen identischen Strings sollte 0 sein\");\n            \n            distance = EditDistance.MinDistance(\"abcdefghij\", \"abcdefghij\");\n            AssertEqual(0, distance, \"Die Distanz zwischen identischen l√§ngeren Strings sollte 0 sein\");\n        });\n    }\n\n    private static void TestLargeStrings()\n    {\n        Test(\"Gr√∂√üere Strings\", () => {\n            // Lange Strings mit Unterschieden am Anfang, in der Mitte und am Ende\n            int distance = EditDistance.MinDistance(\"abcdefghijklmno\", \"pqcdefghijklz\");\n            AssertEqual(5, distance, \"Die Distanz sollte korrekt f√ºr l√§ngere Strings berechnet werden\");\n            \n            // V√∂llig unterschiedliche Strings\n            distance = EditDistance.MinDistance(\"abcdefg\", \"hijklmn\");\n            AssertEqual(7, distance, \"Die Distanz sollte korrekt f√ºr v√∂llig unterschiedliche Strings berechnet werden\");\n        });\n    }\n\n    private static void TestNullInput()\n    {\n        Test(\"Null-Eingaben\", () => {\n            int distance = EditDistance.MinDistance(null, \"abc\");\n            AssertEqual(3, distance, \"Die Distanz von null zu 'abc' sollte 3 sein (null wird als leerer String behandelt)\");\n            \n            distance = EditDistance.MinDistance(\"abc\", null);\n            AssertEqual(3, distance, \"Die Distanz von 'abc' zu null sollte 3 sein (null wird als leerer String behandelt)\");\n            \n            distance = EditDistance.MinDistance(null, null);\n            AssertEqual(0, distance, \"Die Distanz zwischen zwei null-Strings sollte 0 sein (beide werden als leere Strings behandelt)\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEqual<T>(T expected, T actual, string message = null)\n    {\n        if (!Equals(expected, actual))\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {expected}, Erhalten: {actual}\");\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "MinimaleEditierdistanz",
  "functionName": "MinimaleEditierdistanz",
  "reportedIssueNumber": 56,
  "reportedIssueUrl": "https://github.com/Jodo2410/Code-Challenge/issues/56",
  "isHidden": true
}
