{
  "id": "skyline-problem-mcbt3tow",
  "title": "Skyline Problem",
  "description": "Eine Stadt besteht aus mehreren Geb√§uden unterschiedlicher H√∂he. Die Skyline der Stadt ist die √§u√üere Kontur, die von allen Geb√§uden zusammen gebildet wird, wenn man sie von der Seite betrachtet.\n\nGegeben ist eine Liste von Geb√§uden in der Form `[[Li, Ri, Hi]]`, wobei:\n- `Li`: die x-Koordinate der linken Seite des i-ten Geb√§udes\n- `Ri`: die x-Koordinate der rechten Seite des i-ten Geb√§udes\n- `Hi`: die H√∂he des i-ten Geb√§udes\n\nImplementiere eine Funktion, die die Skyline in Form einer Liste von \"Schl√ºsselpunkten\" zur√ºckgibt, sortiert nach x-Koordinate. Ein Schl√ºsselpunkt ist definiert als eine x-Koordinate, an der sich die H√∂he der Skyline √§ndert. Das Format der Ausgabe ist eine Liste von Paaren `[x, y]`, wobei `x` die x-Koordinate ist und `y` die H√∂he der Skyline an dieser Position.\n\nBeispiel:\nEingabe: `[[2, 9, 10], [3, 7, 15], [5, 12, 12], [15, 20, 10], [19, 24, 8]]`\nAusgabe: `[[2, 10], [3, 15], [7, 12], [12, 0], [15, 10], [20, 8], [24, 0]]`\n\nErkl√§rung:\n- Bei x=2 beginnt das erste Geb√§ude mit H√∂he 10\n- Bei x=3 beginnt das zweite Geb√§ude mit H√∂he 15 (√ºberschreibt das erste)\n- Bei x=7 endet das zweite Geb√§ude, das dritte Geb√§ude ist sichtbar mit H√∂he 12\n- Bei x=12 endet das dritte Geb√§ude, die H√∂he f√§llt auf 0\n- Bei x=15 beginnt das vierte Geb√§ude mit H√∂he 10\n- Bei x=20 endet das vierte Geb√§ude, das f√ºnfte Geb√§ude ist sichtbar mit H√∂he 8\n- Bei x=24 endet das f√ºnfte Geb√§ude, die H√∂he f√§llt auf 0\n\n![Skyline Visualisierung](https://assets.leetcode.com/uploads/2020/12/01/merged.jpg)",
  "difficulty": "hard",
  "language": "csharp",
  "tags": [
    "algorithms",
    "divide-and-conquer",
    "heap",
    "priority-queue",
    "line-sweep",
    "csharp",
    "hard",
    "geometry"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:23:33.629Z",
  "status": "approved",
  "starterCode": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class SkylineSolver\n{\n    /// <summary>\n    /// Berechnet die Skyline einer Stadt aus einer Liste von Geb√§uden.\n    /// </summary>\n    /// <param name=\"buildings\">Liste von Geb√§uden im Format [Li, Ri, Hi]</param>\n    /// <returns>Skyline als Liste von Schl√ºsselpunkten [x, y]</returns>\n    public static List<int[]> GetSkyline(int[][] buildings)\n    {\n        // TODO: Implementiere deine L√∂sung hier\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class SkylineSolver\n{\n    /// <summary>\n    /// Berechnet die Skyline einer Stadt aus einer Liste von Geb√§uden.\n    /// </summary>\n    /// <param name=\"buildings\">Liste von Geb√§uden im Format [Li, Ri, Hi]</param>\n    /// <returns>Skyline als Liste von Schl√ºsselpunkten [x, y]</returns>\n    public static List<int[]> GetSkyline(int[][] buildings)\n    {\n        List<int[]> result = new List<int[]>();\n        \n        // Sonderfall: Keine Geb√§ude\n        if (buildings == null || buildings.Length == 0)\n        {\n            return result;\n        }\n        \n        // Liste aller kritischen Punkte (linke und rechte Kante jedes Geb√§udes)\n        List<BuildingPoint> points = new List<BuildingPoint>();\n        \n        // F√ºge alle linken und rechten Kanten der Geb√§ude hinzu\n        foreach (var building in buildings)\n        {\n            // Linke Kante (negativer H√∂henwert f√ºr Sortierung)\n            points.Add(new BuildingPoint(building[0], -building[2], 0));\n            // Rechte Kante (positiver H√∂henwert f√ºr Sortierung)\n            points.Add(new BuildingPoint(building[1], building[2], 1));\n        }\n        \n        // Sortiere die Punkte nach x-Koordinate\n        // Bei gleicher x-Koordinate: links vor rechts und h√∂heres Geb√§ude vor niedrigerem\n        points.Sort((a, b) => {\n            if (a.X != b.X) return a.X - b.X;\n            if (a.Type != b.Type) return a.Type - b.Type;\n            if (a.Type == 0) return a.Height - b.Height; // linke Kanten: h√∂here zuerst\n            return b.Height - a.Height; // rechte Kanten: niedrigere zuerst\n        });\n        \n        // Max-Heap f√ºr die aktuellen H√∂hen\n        // In C# gibt es keine direkte Max-Heap-Implementierung, daher verwenden wir eine SortedSet\n        // mit negativen Werten als Workaround\n        SortedSet<int> heights = new SortedSet<int>(Comparer<int>.Create((a, b) => b.CompareTo(a)));\n        heights.Add(0); // F√ºge Bodenh√∂he hinzu\n        \n        int prevMaxHeight = 0;\n        \n        // Verarbeite alle Punkte\n        foreach (var point in points)\n        {\n            if (point.Type == 0) // Linke Kante\n            {\n                heights.Add(-point.Height); // F√ºge die H√∂he zum Max-Heap hinzu (negativ, weil wir einen Max-Heap simulieren)\n            }\n            else // Rechte Kante\n            {\n                heights.Remove(-point.Height); // Entferne die H√∂he aus dem Max-Heap\n            }\n            \n            // Aktuelle maximale H√∂he\n            int currentMaxHeight = heights.Min(); // Da wir negative Werte verwenden, ist das Minimum tats√§chlich das Maximum\n            \n            // Wenn sich die maximale H√∂he ge√§ndert hat, f√ºge einen neuen Schl√ºsselpunkt hinzu\n            if (currentMaxHeight != prevMaxHeight)\n            {\n                result.Add(new int[] { point.X, currentMaxHeight });\n                prevMaxHeight = currentMaxHeight;\n            }\n        }\n        \n        return result;\n    }\n    \n    private class BuildingPoint\n    {\n        public int X { get; set; }      // x-Koordinate\n        public int Height { get; set; } // H√∂he des Geb√§udes\n        public int Type { get; set; }   // 0 = linke Kante, 1 = rechte Kante\n        \n        public BuildingPoint(int x, int height, int type)\n        {\n            X = x;\n            Height = height;\n            Type = type;\n        }\n    }\n}",
  "tests": "using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: Skyline Problem\");\n        Console.WriteLine(new string('=', 50));\n\n        TestEmptyInput();\n        TestSingleBuilding();\n        TestNonOverlappingBuildings();\n        TestOverlappingBuildings();\n        TestExampleCase();\n        TestComplexCase();\n        TestSameHeightBuildings();\n        TestBuildingsWithSameStartOrEnd();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestEmptyInput()\n    {\n        Test(\"Leere Eingabe\", () => {\n            int[][] buildings = new int[0][];\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            AssertEmptyList(result, \"Bei leerer Eingabe sollte eine leere Liste zur√ºckgegeben werden\");\n        });\n    }\n\n    private static void TestSingleBuilding()\n    {\n        Test(\"Einzelnes Geb√§ude\", () => {\n            int[][] buildings = new int[][] { new int[] { 1, 5, 10 } };\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            List<int[]> expected = new List<int[]> { new int[] { 1, 10 }, new int[] { 5, 0 } };\n            AssertListEquals(expected, result, \"Skyline f√ºr ein einzelnes Geb√§ude\");\n        });\n    }\n\n    private static void TestNonOverlappingBuildings()\n    {\n        Test(\"Nicht √ºberlappende Geb√§ude\", () => {\n            int[][] buildings = new int[][] {\n                new int[] { 1, 3, 10 },\n                new int[] { 5, 8, 15 },\n                new int[] { 10, 13, 8 }\n            };\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            List<int[]> expected = new List<int[]> {\n                new int[] { 1, 10 },\n                new int[] { 3, 0 },\n                new int[] { 5, 15 },\n                new int[] { 8, 0 },\n                new int[] { 10, 8 },\n                new int[] { 13, 0 }\n            };\n            AssertListEquals(expected, result, \"Skyline f√ºr nicht √ºberlappende Geb√§ude\");\n        });\n    }\n\n    private static void TestOverlappingBuildings()\n    {\n        Test(\"√úberlappende Geb√§ude\", () => {\n            int[][] buildings = new int[][] {\n                new int[] { 1, 5, 10 },\n                new int[] { 3, 7, 15 }\n            };\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            List<int[]> expected = new List<int[]> {\n                new int[] { 1, 10 },\n                new int[] { 3, 15 },\n                new int[] { 7, 0 }\n            };\n            AssertListEquals(expected, result, \"Skyline f√ºr √ºberlappende Geb√§ude\");\n        });\n    }\n\n    private static void TestExampleCase()\n    {\n        Test(\"Beispielfall aus Aufgabenstellung\", () => {\n            int[][] buildings = new int[][] {\n                new int[] { 2, 9, 10 },\n                new int[] { 3, 7, 15 },\n                new int[] { 5, 12, 12 },\n                new int[] { 15, 20, 10 },\n                new int[] { 19, 24, 8 }\n            };\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            List<int[]> expected = new List<int[]> {\n                new int[] { 2, 10 },\n                new int[] { 3, 15 },\n                new int[] { 7, 12 },\n                new int[] { 12, 0 },\n                new int[] { 15, 10 },\n                new int[] { 20, 8 },\n                new int[] { 24, 0 }\n            };\n            AssertListEquals(expected, result, \"Skyline f√ºr den Beispielfall\");\n        });\n    }\n\n    private static void TestComplexCase()\n    {\n        Test(\"Komplexer Fall\", () => {\n            int[][] buildings = new int[][] {\n                new int[] { 1, 3, 5 },\n                new int[] { 2, 4, 10 },\n                new int[] { 3, 5, 15 },\n                new int[] { 4, 6, 8 },\n                new int[] { 5, 8, 12 },\n                new int[] { 7, 9, 7 }\n            };\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            List<int[]> expected = new List<int[]> {\n                new int[] { 1, 5 },\n                new int[] { 2, 10 },\n                new int[] { 3, 15 },\n                new int[] { 5, 12 },\n                new int[] { 8, 7 },\n                new int[] { 9, 0 }\n            };\n            AssertListEquals(expected, result, \"Skyline f√ºr komplexen Fall\");\n        });\n    }\n\n    private static void TestSameHeightBuildings()\n    {\n        Test(\"Geb√§ude mit gleicher H√∂he\", () => {\n            int[][] buildings = new int[][] {\n                new int[] { 1, 5, 10 },\n                new int[] { 6, 10, 10 }\n            };\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            List<int[]> expected = new List<int[]> {\n                new int[] { 1, 10 },\n                new int[] { 5, 0 },\n                new int[] { 6, 10 },\n                new int[] { 10, 0 }\n            };\n            AssertListEquals(expected, result, \"Skyline f√ºr Geb√§ude mit gleicher H√∂he\");\n        });\n    }\n\n    private static void TestBuildingsWithSameStartOrEnd()\n    {\n        Test(\"Geb√§ude mit gleichem Start oder Ende\", () => {\n            int[][] buildings = new int[][] {\n                new int[] { 1, 5, 10 },\n                new int[] { 1, 3, 12 },\n                new int[] { 3, 5, 8 }\n            };\n            List<int[]> result = SkylineSolver.GetSkyline(buildings);\n            List<int[]> expected = new List<int[]> {\n                new int[] { 1, 12 },\n                new int[] { 3, 10 },\n                new int[] { 5, 0 }\n            };\n            AssertListEquals(expected, result, \"Skyline f√ºr Geb√§ude mit gleichem Start oder Ende\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEmptyList(List<int[]> list, string message = null)\n    {\n        if (list == null || list.Count > 0)\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: leere Liste, Erhalten: {(list == null ? \"null\" : $\"Liste mit {list.Count} Elementen\")}\");\n        }\n    }\n\n    private static void AssertListEquals(List<int[]> expected, List<int[]> actual, string message = null)\n    {\n        if (expected == null && actual == null) return;\n        if (expected == null || actual == null)\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {(expected == null ? \"null\" : \"nicht null\")}, Erhalten: {(actual == null ? \"null\" : \"nicht null\")}\");\n        }\n        \n        if (expected.Count != actual.Count)\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartete Listenl√§nge: {expected.Count}, Erhaltene Listenl√§nge: {actual.Count}\");\n        }\n        \n        for (int i = 0; i < expected.Count; i++)\n        {\n            if (expected[i].Length != actual[i].Length)\n            {\n                throw new Exception($\"{message ?? \"\"}\\nArrayl√§nge unterschiedlich bei Index {i}\");\n            }\n            \n            for (int j = 0; j < expected[i].Length; j++)\n            {\n                if (expected[i][j] != actual[i][j])\n                {\n                    throw new Exception($\"{message ?? \"\"}\\nArrays unterschiedlich bei Index {i}:\\nErwartet: [{string.Join(\", \", expected[i])}], Erhalten: [{string.Join(\", \", actual[i])}]\");\n                }\n            }\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "SkylineProblem",
  "functionName": "SkylineProblem",
  "lastUpdated": 1751006869.386671
}
