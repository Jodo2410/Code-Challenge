{
  "id": "regul-rer-ausdrucksabgleich-mcbt8fxs",
  "title": "Regul√§rer Ausdrucksabgleich",
  "description": "Implementiere einen regul√§ren Ausdrucksabgleich mit Unterst√ºtzung f√ºr '.' und '*'.\n\n- '.' entspricht einem beliebigen einzelnen Zeichen.\n- '*' entspricht null oder mehr des vorherigen Elements.\n\nDer Abgleich sollte den gesamten String s abdecken, nicht nur einen Teil davon.\n\nBeispiele:\n\n```\ns = \"aa\", p = \"a\" ‚Üí false (Ein einzelnes 'a' passt nicht zu \"aa\")\ns = \"aa\", p = \"a*\" ‚Üí true ('*' bedeutet, dass 'a' beliebig oft vorkommen kann, also auch zweimal)\ns = \"ab\", p = \".*\" ‚Üí true ('.' bedeutet beliebiges Zeichen und '*' bedeutet beliebig oft, also passt \".*\" zu beliebigen Strings)\ns = \"aab\", p = \"c*a*b\" ‚Üí true ('c*' entspricht 0 Vorkommen von 'c', 'a*' entspricht 2 Vorkommen von 'a', und 'b' entspricht 'b')\ns = \"mississippi\", p = \"mis*is*p*.\" ‚Üí false (passt nicht zum gesamten String)\n```\n\nDie L√∂sung sollte effizient sein und sowohl Zeit- als auch Speicherkomplexit√§t ber√ºcksichtigen.",
  "difficulty": "hard",
  "language": "csharp",
  "tags": [
    "dynamic-programming",
    "string-matching",
    "regex",
    "algorithms",
    "csharp",
    "hard"
  ],
  "author": "Jodo2410",
  "createdAt": "2025-06-25T10:27:09.038Z",
  "status": "reported",
  "starterCode": "using System;\n\npublic class RegexMatcher\n{\n    /// <summary>\n    /// Pr√ºft, ob ein String mit einem regul√§ren Ausdruck √ºbereinstimmt.\n    /// </summary>\n    /// <param name=\"s\">Der zu pr√ºfende String</param>\n    /// <param name=\"p\">Das regul√§re Ausdrucksmuster</param>\n    /// <returns>True, wenn der String mit dem Muster √ºbereinstimmt, sonst False</returns>\n    public static bool IsMatch(string s, string p)\n    {\n        // TODO: Implementiere deine L√∂sung hier\n        throw new NotImplementedException();\n    }\n}",
  "solution": "using System;\n\npublic class RegexMatcher\n{\n    /// <summary>\n    /// Pr√ºft, ob ein String mit einem regul√§ren Ausdruck √ºbereinstimmt.\n    /// </summary>\n    /// <param name=\"s\">Der zu pr√ºfende String</param>\n    /// <param name=\"p\">Das regul√§re Ausdrucksmuster</param>\n    /// <returns>True, wenn der String mit dem Muster √ºbereinstimmt, sonst False</returns>\n    public static bool IsMatch(string s, string p)\n    {\n        // Behandle null-Eingaben\n        if (s == null || p == null)\n        {\n            return false;\n        }\n        \n        int m = s.Length;\n        int n = p.Length;\n        \n        // DP-Tabelle: dp[i,j] bedeutet, ob s[0...i-1] und p[0...j-1] √ºbereinstimmen\n        bool[,] dp = new bool[m + 1, n + 1];\n        \n        // Basisfall: Leerer String passt zu leerem Muster\n        dp[0, 0] = true;\n        \n        // Behandle F√§lle, wo s leer ist, aber p '*' enth√§lt\n        // z.B. p = \"a*\" oder \"a*b*\" - diese k√∂nnen auf leeren String passen\n        for (int j = 1; j <= n; j++)\n        {\n            // Wenn das aktuelle Zeichen ein '*' ist und das vorherige Zeichen+\"*\" zu leerem String passt\n            if (p[j - 1] == '*' && j > 1)\n            {\n                dp[0, j] = dp[0, j - 2]; // Ignoriere das aktuelle Zeichen und das vorherige Zeichen\n            }\n        }\n        \n        // Hauptlogik f√ºr die DP-Tabelle\n        for (int i = 1; i <= m; i++)\n        {\n            for (int j = 1; j <= n; j++)\n            {\n                char currentChar = p[j - 1];\n                \n                if (currentChar == '*')\n                {\n                    // Wenn der aktuelle Char '*' ist, haben wir zwei Optionen:\n                    // 1. Ignoriere das '*' und das vorherige Zeichen (j-2)\n                    // 2. Wenn das vorherige Zeichen mit dem aktuellen String-Zeichen √ºbereinstimmt, \n                    //    k√∂nnen wir entweder den aktuellen String-Zeichen verwenden oder nicht\n                    \n                    if (j > 1) // Stelle sicher, dass es ein vorheriges Zeichen gibt\n                    {\n                        // Option 1: Ignoriere das '*' und das vorherige Zeichen\n                        dp[i, j] = dp[i, j - 2];\n                        \n                        // Option 2: Verwende das '*' mit dem vorherigen Zeichen\n                        char prevChar = p[j - 2];\n                        \n                        // Wenn das vorherige Zeichen mit dem aktuellen String-Zeichen √ºbereinstimmt\n                        // oder das vorherige Zeichen ein '.' ist (passt zu allem)\n                        if (prevChar == '.' || prevChar == s[i - 1])\n                        {\n                            // Entweder ignorieren oder den aktuellen String-Zeichen verwenden\n                            dp[i, j] = dp[i, j] || dp[i - 1, j];\n                        }\n                    }\n                }\n                else if (currentChar == '.' || currentChar == s[i - 1])\n                {\n                    // Wenn der aktuelle Char '.' ist oder direkt mit dem String-Zeichen √ºbereinstimmt,\n                    // h√§ngt die √úbereinstimmung davon ab, ob die vorherigen Zeichen √ºbereinstimmen\n                    dp[i, j] = dp[i - 1, j - 1];\n                }\n                // Andernfalls bleibt dp[i, j] false\n            }\n        }\n        \n        return dp[m, n];\n    }\n}",
  "tests": "using System;\n\npublic class Tests\n{\n    private static int testsPassed = 0;\n    private static int totalTests = 0;\n\n    public static void RunAllTests()\n    {\n        Console.WriteLine(\"üß™ Starte Tests f√ºr: Regul√§rer Ausdrucksabgleich\");\n        Console.WriteLine(new string('=', 50));\n\n        TestBasicMatching();\n        TestDotMatching();\n        TestStarMatching();\n        TestComplexPatterns();\n        TestEdgeCases();\n        TestLargeInputs();\n\n        Console.WriteLine($\"\\n{testsPassed}/{totalTests} Tests bestanden\");\n        \n        if (testsPassed == totalTests)\n        {\n            Console.WriteLine(\"üéâ Alle Tests bestanden!\");\n        }\n        else\n        {\n            Console.WriteLine(\"‚ùå Einige Tests fehlgeschlagen.\");\n            Environment.Exit(1);\n        }\n    }\n\n    private static void TestBasicMatching()\n    {\n        Test(\"Einfache √úbereinstimmungen\", () => {\n            AssertEqual(true, RegexMatcher.IsMatch(\"abc\", \"abc\"), \"Exakte √úbereinstimmung sollte funktionieren\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"abc\", \"abcd\"), \"Unterschiedliche L√§ngen ohne Sonderzeichen sollten nicht √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"abc\", \"abd\"), \"Unterschiedliche Zeichen sollten nicht √ºbereinstimmen\");\n        });\n    }\n\n    private static void TestDotMatching()\n    {\n        Test(\"Punkt-√úbereinstimmungen\", () => {\n            AssertEqual(true, RegexMatcher.IsMatch(\"abc\", \"a.c\"), \"'.' sollte mit einem beliebigen Zeichen √ºbereinstimmen\");\n            AssertEqual(true, RegexMatcher.IsMatch(\"abc\", \"...\"), \"Mehrere '.' sollten mit mehreren beliebigen Zeichen √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"abc\", \"....\"), \"Zu viele '.' sollten nicht mit einem k√ºrzeren String √ºbereinstimmen\");\n        });\n    }\n\n    private static void TestStarMatching()\n    {\n        Test(\"Stern-√úbereinstimmungen\", () => {\n            AssertEqual(true, RegexMatcher.IsMatch(\"aaa\", \"a*\"), \"'a*' sollte mit beliebig vielen 'a' √ºbereinstimmen\");\n            AssertEqual(true, RegexMatcher.IsMatch(\"\", \"a*\"), \"'a*' sollte auch mit einem leeren String √ºbereinstimmen\");\n            AssertEqual(true, RegexMatcher.IsMatch(\"aaa\", \"a*a\"), \"'a*a' sollte mit 'aaa' √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"aab\", \"a*c\"), \"'a*c' sollte nicht mit 'aab' √ºbereinstimmen\");\n        });\n    }\n\n    private static void TestComplexPatterns()\n    {\n        Test(\"Komplexe Muster\", () => {\n            AssertEqual(true, RegexMatcher.IsMatch(\"aab\", \"c*a*b\"), \"'c*a*b' sollte mit 'aab' √ºbereinstimmen\");\n            AssertEqual(true, RegexMatcher.IsMatch(\"ab\", \".*\"), \"'.*' sollte mit jedem String √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"mississippi\", \"mis*is*p*.\"), \"'mis*is*p*.' sollte nicht mit 'mississippi' √ºbereinstimmen\");\n            AssertEqual(true, RegexMatcher.IsMatch(\"mississippi\", \"mis*is*ip*i\"), \"'mis*is*ip*i' sollte mit 'mississippi' √ºbereinstimmen\");\n        });\n    }\n\n    private static void TestEdgeCases()\n    {\n        Test(\"Randf√§lle\", () => {\n            AssertEqual(true, RegexMatcher.IsMatch(\"\", \"\"), \"Leerer String sollte mit leerem Muster √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"a\", \"\"), \"Nicht-leerer String sollte nicht mit leerem Muster √ºbereinstimmen\");\n            AssertEqual(true, RegexMatcher.IsMatch(\"\", \"a*\"), \"Leerer String sollte mit 'a*' √ºbereinstimmen\");\n            AssertEqual(true, RegexMatcher.IsMatch(\"\", \".*\"), \"Leerer String sollte mit '.*' √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"\", \".\"), \"Leerer String sollte nicht mit '.' √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(null, \"a*\"), \"Null-String sollte nicht mit 'a*' √ºbereinstimmen\");\n            AssertEqual(false, RegexMatcher.IsMatch(\"a\", null), \"String sollte nicht mit null-Muster √ºbereinstimmen\");\n        });\n    }\n\n    private static void TestLargeInputs()\n    {\n        Test(\"Gro√üe Eingaben\", () => {\n            // Teste mit einem l√§ngeren String und Muster\n            string longString = new string('a', 100);\n            string longPattern = \"a*\" + new string('.', 50) + \"a*\";\n            AssertEqual(true, RegexMatcher.IsMatch(longString, longPattern), \"Lange Eingabe sollte korrekt verarbeitet werden\");\n            \n            // Teste mit einem komplexen wiederholenden Muster\n            string complexString = \"ababababab\";\n            string complexPattern = \"(a*b*)*\";\n            AssertEqual(true, RegexMatcher.IsMatch(complexString, \"a*b*a*b*a*b*a*b*a*b*\"), \"Komplexes Muster sollte korrekt verarbeitet werden\");\n        });\n    }\n\n    private static void Test(string description, Action testAction)\n    {\n        totalTests++;\n        try\n        {\n            testAction();\n            Console.WriteLine($\"  ‚úÖ {description}\");\n            testsPassed++;\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine($\"  ‚ùå {description}: {ex.Message}\");\n        }\n    }\n\n    private static void AssertEqual<T>(T expected, T actual, string message = null)\n    {\n        if (!Equals(expected, actual))\n        {\n            throw new Exception($\"{message ?? \"\"}\\nErwartet: {expected}, Erhalten: {actual}\");\n        }\n    }\n}",
  "testClassName": "Tests",
  "mainClassName": "RegulrerAusdrucksabgleich",
  "functionName": "RegulrerAusdrucksabgleich",
  "reportedIssueNumber": 59,
  "reportedIssueUrl": "https://github.com/Jodo2410/Code-Challenge/issues/59",
  "isHidden": true
}