# C++ Template Challenge Makefile (mit build/ Ordner)
# Template-Version: 2.0
# Kompatibel mit: C++17

# Compiler und Flags
CXX = g++
CXXFLAGS = -std=c++17 -Wall -Wextra -O2 -I.
DEBUG_FLAGS = -g -DDEBUG -O0
RELEASE_FLAGS = -O3 -DNDEBUG -march=native
PROFILE_FLAGS = -pg -O2

# Verzeichnisse
BUILD_DIR = build
SRC_DIR = .
HEADERS_DIR = .

# Dateien
TARGET = test_runner
SOURCES = test_runner.cpp Challenge.cpp Tests.cpp
HEADERS = Challenge.h Tests.h

# Build-Artefakte in build/ Ordner
BUILD_OBJECTS = $(SOURCES:%.cpp=$(BUILD_DIR)/%.o)
BUILD_DEPS = $(BUILD_OBJECTS:%.o=%.d)
BUILD_TARGET = $(BUILD_DIR)/$(TARGET)

# Farben f√ºr Output
GREEN = \033[0;32m
YELLOW = \033[1;33m
RED = \033[0;31m
BLUE = \033[0;34m
PURPLE = \033[0;35m
CYAN = \033[0;36m
NC = \033[0m # No Color

# Standard-Target
all: $(BUILD_TARGET)
	@echo "$(GREEN)‚úÖ C++ Template-Challenge erfolgreich kompiliert!$(NC)"
	@echo "$(YELLOW)üìÅ Build-Artefakte in $(BUILD_DIR)/$(NC)"
	@echo "$(YELLOW)üìÅ Verwende 'make test' zum Ausf√ºhren der Tests$(NC)"

# Build-Verzeichnis erstellen
$(BUILD_DIR):
	@echo "$(CYAN)üìÅ Erstelle Build-Verzeichnis: $(BUILD_DIR)$(NC)"
	@mkdir -p $(BUILD_DIR)

# Test Runner kompilieren (im build/ Ordner)
$(BUILD_TARGET): $(BUILD_OBJECTS) | $(BUILD_DIR)
	@echo "$(YELLOW)üîó Linke Executable im Build-Ordner...$(NC)"
	$(CXX) $(CXXFLAGS) -o $(BUILD_TARGET) $(BUILD_OBJECTS)
	@echo "$(GREEN)‚úÖ Linking erfolgreich: $(BUILD_TARGET)$(NC)"

# Object-Dateien kompilieren (in build/ Ordner)
$(BUILD_DIR)/%.o: $(SRC_DIR)/%.cpp $(HEADERS) | $(BUILD_DIR)
	@echo "$(CYAN)üîß Kompiliere $< ‚Üí $@$(NC)"
	$(CXX) $(CXXFLAGS) -MMD -MP -c $< -o $@

# Dependencies einbinden
-include $(BUILD_DEPS)

# Tests ausf√ºhren
test: $(BUILD_TARGET)
	@echo "$(YELLOW)üß™ F√ºhre C++ Template Tests aus...$(NC)"
	@echo "$(YELLOW)================================================$(NC)"
	$(BUILD_TARGET)
	@echo "$(YELLOW)================================================$(NC)"
	@echo "$(GREEN)üéâ Tests abgeschlossen!$(NC)"

# Tests ausf√ºhren und Executable nach Root kopieren (f√ºr Kompatibilit√§t)
test-local: $(BUILD_TARGET)
	@echo "$(CYAN)üìã Kopiere Executable f√ºr lokale Ausf√ºhrung...$(NC)"
	@cp $(BUILD_TARGET) $(TARGET)
	@echo "$(YELLOW)üß™ F√ºhre C++ Template Tests aus...$(NC)"
	@echo "$(YELLOW)================================================$(NC)"
	./$(TARGET)
	@echo "$(YELLOW)================================================$(NC)"
	@echo "$(GREEN)üéâ Tests abgeschlossen!$(NC)"
	@echo "$(YELLOW)üí° Executable auch verf√ºgbar als: $(TARGET)$(NC)"

# Debug-Version kompilieren
debug: CXXFLAGS += $(DEBUG_FLAGS)
debug: clean $(BUILD_TARGET)
	@echo "$(PURPLE)üêõ Debug-Version kompiliert in $(BUILD_DIR)/$(NC)"
	@echo "$(YELLOW)üí° Verwende 'make debug-run' oder 'gdb $(BUILD_TARGET)'$(NC)"

# Debug-Version ausf√ºhren
debug-run: debug
	@echo "$(PURPLE)üêõ F√ºhre Debug-Version aus...$(NC)"
	$(BUILD_TARGET)

# Release-Version kompilieren
release: CXXFLAGS += $(RELEASE_FLAGS)
release: clean $(BUILD_TARGET)
	@echo "$(GREEN)üöÄ Release-Version kompiliert (optimiert) in $(BUILD_DIR)/$(NC)"

# Release-Version ausf√ºhren
release-run: release
	@echo "$(GREEN)üöÄ F√ºhre Release-Version aus...$(NC)"
	$(BUILD_TARGET)

# Profiling-Version kompilieren
profile: CXXFLAGS += $(PROFILE_FLAGS)
profile: clean $(BUILD_TARGET)
	@echo "$(BLUE)üìä Profiling-Version kompiliert in $(BUILD_DIR)/$(NC)"
	@echo "$(YELLOW)üí° F√ºhre 'make profile-run' aus und nutze 'gprof $(BUILD_TARGET)' zur Analyse$(NC)"

# Profiling-Version ausf√ºhren
profile-run: profile
	@echo "$(BLUE)üìä F√ºhre Profiling-Version aus...$(NC)"
	$(BUILD_TARGET)
	@if [ -f gmon.out ]; then \
		echo "$(BLUE)üìä Profiling-Daten in gmon.out generiert$(NC)"; \
		echo "$(YELLOW)üí° Analyse mit: gprof $(BUILD_TARGET) gmon.out$(NC)"; \
	fi

# Aufr√§umen - nur Build-Artefakte
clean:
	@echo "$(YELLOW)üßπ R√§ume Build-Artefakte auf...$(NC)"
	@if [ -d "$(BUILD_DIR)" ]; then \
		rm -rf $(BUILD_DIR); \
		echo "$(GREEN)‚úÖ $(BUILD_DIR)/ Ordner entfernt$(NC)"; \
	fi
	@rm -f $(TARGET)
	@rm -f *.exe
	@rm -f core
	@rm -f gmon.out
	@echo "$(GREEN)‚úÖ Aufger√§umt!$(NC)"

# Deep Clean (auch tempor√§re Editor-Dateien)
distclean: clean
	@echo "$(YELLOW)üóëÔ∏è  Deep Clean...$(NC)"
	@rm -f *~
	@rm -f *.bak
	@rm -f *.tmp
	@rm -f .*.swp
	@rm -f .*.swo
	@rm -f *.s
	@rm -f *.i
	@echo "$(GREEN)‚úÖ Deep Clean abgeschlossen!$(NC)"

# Template-Validierung
validate:
	@echo "$(YELLOW)üîç Validiere Template-Struktur...$(NC)"
	@if [ ! -f "Challenge.h" ]; then \
		echo "$(RED)‚ùå Challenge.h fehlt$(NC)"; \
		exit 1; \
	fi
	@if [ ! -f "Challenge.cpp" ]; then \
		echo "$(RED)‚ùå Challenge.cpp fehlt$(NC)"; \
		exit 1; \
	fi
	@if [ ! -f "Tests.h" ]; then \
		echo "$(RED)‚ùå Tests.h fehlt$(NC)"; \
		exit 1; \
	fi
	@if [ ! -f "Tests.cpp" ]; then \
		echo "$(RED)‚ùå Tests.cpp fehlt$(NC)"; \
		exit 1; \
	fi
	@if [ ! -f "test_runner.cpp" ]; then \
		echo "$(RED)‚ùå test_runner.cpp fehlt$(NC)"; \
		exit 1; \
	fi
	@if [ ! -f "challenge-info.json" ]; then \
		echo "$(RED)‚ùå challenge-info.json fehlt$(NC)"; \
		exit 1; \
	fi
	@echo "$(GREEN)‚úÖ Template-Struktur vollst√§ndig$(NC)"

# Syntax-Check ohne Ausf√ºhrung
check:
	@echo "$(YELLOW)üîç Syntax-Check...$(NC)"
	$(CXX) $(CXXFLAGS) -fsyntax-only $(SOURCES)
	@echo "$(GREEN)‚úÖ Syntax korrekt$(NC)"

# Header-Dependencies pr√ºfen
deps:
	@echo "$(YELLOW)üîç Analysiere Dependencies...$(NC)"
	$(CXX) $(CXXFLAGS) -MM $(SOURCES)

# Code-Formatting (falls clang-format verf√ºgbar)
format:
	@if command -v clang-format >/dev/null 2>&1; then \
		echo "$(YELLOW)üé® Formatiere Code...$(NC)"; \
		clang-format -i *.cpp *.h; \
		echo "$(GREEN)‚úÖ Code formatiert$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  clang-format nicht gefunden - √ºbersprungen$(NC)"; \
	fi

# Code-Linting (falls cppcheck verf√ºgbar)
lint:
	@if command -v cppcheck >/dev/null 2>&1; then \
		echo "$(YELLOW)üîç Code-Analyse mit cppcheck...$(NC)"; \
		cppcheck --enable=all --std=c++17 --suppress=missingIncludeSystem *.cpp *.h; \
		echo "$(GREEN)‚úÖ Code-Analyse abgeschlossen$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  cppcheck nicht gefunden - √ºbersprungen$(NC)"; \
	fi

# Memory-Check mit Valgrind (falls verf√ºgbar)
memcheck: debug
	@if command -v valgrind >/dev/null 2>&1; then \
		echo "$(PURPLE)üîç Memory-Check mit Valgrind...$(NC)"; \
		valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes $(BUILD_TARGET); \
		echo "$(GREEN)‚úÖ Memory-Check abgeschlossen$(NC)"; \
	else \
		echo "$(YELLOW)‚ö†Ô∏è  Valgrind nicht gefunden - √ºbersprungen$(NC)"; \
	fi

# Benchmark ausf√ºhren
benchmark: release
	@echo "$(BLUE)üìä F√ºhre Performance-Benchmark aus...$(NC)"
	@for i in 1 2 3 4 5; do \
		echo "$(CYAN)Run $$i:$(NC)"; \
		time $(BUILD_TARGET); \
		echo ""; \
	done
	@echo "$(GREEN)‚úÖ Benchmark abgeschlossen$(NC)"

# Template-Info anzeigen
info:
	@echo "$(YELLOW)üìã C++ Template Challenge Info:$(NC)"
	@echo "   Template-Version: 2.0"
	@echo "   C++ Standard: C++17"
	@echo "   Datei-Struktur: Separate .h/.cpp Files"
	@echo "   Build-Ordner: $(BUILD_DIR)/"
	@echo "   Compiler: $(CXX)"
	@echo "   Flags: $(CXXFLAGS)"
	@echo "   Target: $(BUILD_TARGET)"
	@echo ""
	@echo "$(YELLOW)üìÅ Projekt-Struktur:$(NC)"
	@echo "   Source Files: $(SOURCES)"
	@echo "   Header Files: $(HEADERS)"
	@echo "   Build Objects: $(BUILD_OBJECTS)"
	@echo "   Build Target: $(BUILD_TARGET)"
	@echo ""
	@echo "$(YELLOW)üìÇ Verf√ºgbare Dateien:$(NC)"
	@ls -la *.h *.cpp *.json Makefile 2>/dev/null || echo "   Dateien werden erstellt..."
	@if [ -d "$(BUILD_DIR)" ]; then \
		echo "$(YELLOW)üìÇ Build-Artefakte:$(NC)"; \
		ls -la $(BUILD_DIR)/ 2>/dev/null || echo "   Build-Ordner leer"; \
	else \
		echo "$(YELLOW)üìÇ Build-Ordner: Noch nicht erstellt$(NC)"; \
	fi
	@echo ""
	@echo "$(YELLOW)üéØ Verf√ºgbare Make-Targets:$(NC)"
	@echo "   make           - Standard kompilierung in $(BUILD_DIR)/"
	@echo "   make test      - Kompilieren + Tests ausf√ºhren"
	@echo "   make test-local- Tests mit lokalem Executable"
	@echo "   make debug     - Debug-Version (-g -O0)"
	@echo "   make debug-run - Debug kompilieren + ausf√ºhren"
	@echo "   make release   - Release-Version (-O3 optimiert)"
	@echo "   make release-run- Release kompilieren + ausf√ºhren"
	@echo "   make profile   - Profiling-Version (-pg)"
	@echo "   make profile-run- Profiling kompilieren + ausf√ºhren"
	@echo "   make clean     - Build-Ordner aufr√§umen"
	@echo "   make distclean - Deep Clean"
	@echo "   make validate  - Template validieren"
	@echo "   make check     - Syntax pr√ºfen"
	@echo "   make deps      - Dependencies anzeigen"
	@echo "   make format    - Code formatieren (clang-format)"
	@echo "   make lint      - Code-Analyse (cppcheck)"
	@echo "   make memcheck  - Memory-Check (valgrind)"
	@echo "   make benchmark - Performance-Test"
	@echo "   make info      - Diese Info anzeigen"

# Installation von Dependencies (falls ben√∂tigt)
install-deps:
	@echo "$(YELLOW)üì¶ Pr√ºfe C++ Dependencies...$(NC)"
	@if ! command -v g++ >/dev/null 2>&1; then \
		echo "$(RED)‚ùå g++ nicht gefunden!$(NC)"; \
		echo "$(YELLOW)üí° Installation:$(NC)"; \
		echo "   Ubuntu/Debian: sudo apt install build-essential"; \
		echo "   CentOS/RHEL:   sudo yum groupinstall 'Development Tools'"; \
		echo "   macOS:         xcode-select --install"; \
		echo "   Windows:       Install MSYS2 or MinGW"; \
		exit 1; \
	fi
	@echo "$(GREEN)‚úÖ g++ verf√ºgbar: $$(g++ --version | head -n1)$(NC)"
	@echo "$(YELLOW)üì¶ Optionale Tools pr√ºfen...$(NC)"
	@command -v clang-format >/dev/null 2>&1 && echo "$(GREEN)‚úÖ clang-format verf√ºgbar$(NC)" || echo "$(YELLOW)‚ö†Ô∏è  clang-format nicht verf√ºgbar$(NC)"
	@command -v cppcheck >/dev/null 2>&1 && echo "$(GREEN)‚úÖ cppcheck verf√ºgbar$(NC)" || echo "$(YELLOW)‚ö†Ô∏è  cppcheck nicht verf√ºgbar$(NC)"
	@command -v valgrind >/dev/null 2>&1 && echo "$(GREEN)‚úÖ valgrind verf√ºgbar$(NC)" || echo "$(YELLOW)‚ö†Ô∏è  valgrind nicht verf√ºgbar$(NC)"
	@command -v gdb >/dev/null 2>&1 && echo "$(GREEN)‚úÖ gdb verf√ºgbar$(NC)" || echo "$(YELLOW)‚ö†Ô∏è  gdb nicht verf√ºgbar$(NC)"

# Help-Target
help: info

# Assembly-Output generieren (im build/ Ordner)
asm: | $(BUILD_DIR)
	@echo "$(CYAN)üîß Generiere Assembly-Output...$(NC)"
	$(CXX) $(CXXFLAGS) -S -fverbose-asm -o $(BUILD_DIR)/Challenge.s Challenge.cpp
	@echo "$(GREEN)‚úÖ Assembly in $(BUILD_DIR)/Challenge.s generiert$(NC)"

# Preprocessor-Output generieren (im build/ Ordner)
preprocess: | $(BUILD_DIR)
	@echo "$(CYAN)üîß Generiere Preprocessor-Output...$(NC)"
	$(CXX) $(CXXFLAGS) -E -o $(BUILD_DIR)/Challenge.i Challenge.cpp
	@echo "$(GREEN)‚úÖ Preprocessor-Output in $(BUILD_DIR)/Challenge.i generiert$(NC)"

# Object-File-Info anzeigen
objdump: $(BUILD_TARGET)
	@echo "$(CYAN)üîç Object-File Informationen:$(NC)"
	@for obj in $(BUILD_OBJECTS); do \
		if [ -f "$$obj" ]; then \
			echo "$(YELLOW)--- $$obj ---$(NC)"; \
			objdump -t $$obj | head -20; \
			echo ""; \
		fi; \
	done

# Gr√∂√üe der generierten Dateien anzeigen
size: $(BUILD_TARGET)
	@echo "$(CYAN)üìè Datei-Gr√∂√üen:$(NC)"
	@echo "$(YELLOW)Executable:$(NC)"
	@ls -lh $(BUILD_TARGET)
	@echo "$(YELLOW)Object Files:$(NC)"
	@ls -lh $(BUILD_OBJECTS) 2>/dev/null || echo "   Keine Object-Files gefunden"
	@echo "$(YELLOW)Gr√∂√üen-Details:$(NC)"
	@size $(BUILD_TARGET)

# Build-Struktur anzeigen
tree:
	@echo "$(CYAN)üå≥ Projekt-Struktur:$(NC)"
	@echo "."
	@echo "‚îú‚îÄ‚îÄ Source Files"
	@for src in $(SOURCES); do echo "‚îÇ   ‚îú‚îÄ‚îÄ $$src"; done
	@echo "‚îú‚îÄ‚îÄ Header Files"
	@for hdr in $(HEADERS); do echo "‚îÇ   ‚îú‚îÄ‚îÄ $$hdr"; done
	@echo "‚îú‚îÄ‚îÄ Config Files"
	@echo "‚îÇ   ‚îú‚îÄ‚îÄ Makefile"
	@echo "‚îÇ   ‚îî‚îÄ‚îÄ challenge-info.json"
	@if [ -d "$(BUILD_DIR)" ]; then \
		echo "‚îî‚îÄ‚îÄ $(BUILD_DIR)/ (Build Artifacts)"; \
		for obj in $(BUILD_OBJECTS); do \
			if [ -f "$$obj" ]; then echo "    ‚îú‚îÄ‚îÄ $$(basename $$obj)"; fi; \
		done; \
		if [ -f "$(BUILD_TARGET)" ]; then echo "    ‚îî‚îÄ‚îÄ $(TARGET) (executable)"; fi; \
	else \
		echo "‚îî‚îÄ‚îÄ $(BUILD_DIR)/ (not created yet)"; \
	fi

# Workspace aufr√§umen und neu bauen
rebuild: distclean all
	@echo "$(GREEN)üîÑ Rebuild abgeschlossen!$(NC)"

# Schneller rebuild ohne Deep Clean
fast-rebuild: clean all
	@echo "$(GREEN)‚ö° Fast Rebuild abgeschlossen!$(NC)"

# Watch-Mode (erfordert inotify-tools)
watch:
	@if command -v inotifywait >/dev/null 2>&1; then \
		echo "$(CYAN)üëÅÔ∏è  Watch-Mode aktiv - √Ñnderungen an .cpp/.h Dateien werden √ºberwacht$(NC)"; \
		echo "$(YELLOW)üí° Beenden mit Ctrl+C$(NC)"; \
		while true; do \
			inotifywait -e modify *.cpp *.h 2>/dev/null; \
			echo "$(YELLOW)üîÑ Datei ge√§ndert - Rebuilding...$(NC)"; \
			make --no-print-directory fast-rebuild; \
			echo "$(GREEN)‚úÖ Rebuild abgeschlossen$(NC)"; \
		done; \
	else \
		echo "$(RED)‚ùå inotifywait nicht gefunden$(NC)"; \
		echo "$(YELLOW)üí° Installation: sudo apt install inotify-tools$(NC)"; \
	fi

# Phony targets (keine echten Dateien)
.PHONY: all test test-local debug debug-run release release-run profile profile-run clean distclean validate check deps format lint memcheck benchmark info help install-deps asm preprocess objdump size tree rebuild fast-rebuild watch

# Default-Target falls nichts angegeben
.DEFAULT_GOAL := all

# Automatische Abh√§ngigkeiten f√ºr bessere Builds
.PRECIOUS: %.o $(BUILD_DIR)/%.o

# Parallelisierung aktivieren falls unterst√ºtzt
MAKEFLAGS += -j$(shell nproc 2>/dev/null || echo 1)

# Verbose Output bei V=1
ifeq ($(V),1)
	Q :=
else
	Q := @
endif

# Build-Ordner als Order-Only Prerequisite f√ºr bessere Performance
$(BUILD_OBJECTS): | $(BUILD_DIR)
