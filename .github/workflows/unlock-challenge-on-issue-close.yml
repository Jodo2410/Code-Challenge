# GitHub Actions Workflow fÃ¼r automatische Challenge-Status-Updates
# Wird ausgelÃ¶st wenn ein Issue mit "challenge-error" Label geschlossen wird

name: ğŸ”§ Challenge Issue Handler

on:
  issues:
    types: [closed]

# âœ… WICHTIG: Token-Berechtigungen definieren
permissions:
  contents: write        # Zum Ã„ndern von Dateien
  issues: write         # Zum Kommentieren von Issues
  metadata: read        # Standard-Berechtigung

jobs:
  reset-challenge-status:
    name: ğŸ”„ Reset Challenge Status
    runs-on: ubuntu-latest
    
    # Nur ausfÃ¼hren wenn Issue das "challenge-error" Label hat
    if: contains(github.event.issue.labels.*.name, 'challenge-error')
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: ğŸ” Extract Challenge ID from Issue
        id: extract-challenge
        run: |
          # Challenge ID aus Issue-Body oder Titel extrahieren
          ISSUE_BODY="${{ github.event.issue.body }}"
          ISSUE_TITLE="${{ github.event.issue.title }}"
          
          echo "ğŸ” Analysiere Issue #${{ github.event.issue.number }}"
          echo "ğŸ“‹ Titel: $ISSUE_TITLE"
          
          # Pattern 1: Challenge ID aus Issue Body extrahieren
          CHALLENGE_ID=""
          
          # Suche nach "Challenge ID: xyz" oder "ID: xyz" im Body
          if echo "$ISSUE_BODY" | grep -q "Challenge.*ID.*:"; then
            CHALLENGE_ID=$(echo "$ISSUE_BODY" | grep -o "Challenge.*ID.*:\s*\`[^`]*\`" | sed 's/.*`\([^`]*\)`.*/\1/')
          elif echo "$ISSUE_BODY" | grep -q "ID.*:"; then
            CHALLENGE_ID=$(echo "$ISSUE_BODY" | grep -o "ID.*:\s*\`[^`]*\`" | sed 's/.*`\([^`]*\)`.*/\1/')
          fi
          
          # Pattern 2: Aus Issue-Titel extrahieren (Format: "Challenge Error: Title (language)")
          if [ -z "$CHALLENGE_ID" ] && echo "$ISSUE_TITLE" | grep -q "Challenge Error:"; then
            # Extrahiere Challenge-Namen aus Titel und konvertiere zu ID
            CHALLENGE_NAME=$(echo "$ISSUE_TITLE" | sed 's/.*Challenge Error:\s*\([^(]*\).*/\1/' | sed 's/[[:space:]]*$//')
            echo "ğŸ“ Challenge Name gefunden: $CHALLENGE_NAME"
            
            # Suche nach challenge.json Dateien mit diesem Titel
            for challenge_dir in challenges/*/; do
              if [ -f "$challenge_dir/challenge.json" ]; then
                TITLE_IN_FILE=$(cat "$challenge_dir/challenge.json" | grep -o '"title":\s*"[^"]*"' | sed 's/"title":\s*"\([^"]*)"/\1/')
                if [ "$TITLE_IN_FILE" = "$CHALLENGE_NAME" ]; then
                  CHALLENGE_ID=$(basename "$challenge_dir")
                  echo "âœ… Challenge ID gefunden: $CHALLENGE_ID"
                  break
                fi
              fi
            done
          fi
          
          # Pattern 3: Challenge ID direkt aus verfÃ¼gbaren Ordnern ableiten
          if [ -z "$CHALLENGE_ID" ]; then
            echo "âš ï¸ Challenge ID nicht aus Issue extrahiert. Suche in challenges/ Verzeichnis..."
            
            # Liste alle Challenge-Verzeichnisse und suche nach passendem Titel
            for challenge_dir in challenges/*/; do
              if [ -f "$challenge_dir/challenge.json" ]; then
                # PrÃ¼fe ob diese Challenge als "reported" markiert ist
                STATUS=$(cat "$challenge_dir/challenge.json" | grep -o '"status":\s*"[^"]*"' | sed 's/"status":\s*"\([^"]*\)"/\1/')
                ISSUE_NUM=$(cat "$challenge_dir/challenge.json" | grep -o '"reportedIssueNumber":\s*[0-9]*' | sed 's/"reportedIssueNumber":\s*\([0-9]*\)/\1/')
                
                if [ "$STATUS" = "reported" ] && [ "$ISSUE_NUM" = "${{ github.event.issue.number }}" ]; then
                  CHALLENGE_ID=$(basename "$challenge_dir")
                  echo "âœ… Challenge ID Ã¼ber Issue-Nummer gefunden: $CHALLENGE_ID"
                  break
                fi
              fi
            done
          fi
          
          if [ -z "$CHALLENGE_ID" ]; then
            echo "âŒ Challenge ID konnte nicht bestimmt werden!"
            echo "ğŸ” VerfÃ¼gbare Challenge-Verzeichnisse:"
            ls -la challenges/ || echo "Kein challenges/ Verzeichnis gefunden"
            exit 1
          fi
          
          echo "ğŸ¯ Challenge ID: $CHALLENGE_ID"
          echo "challenge_id=$CHALLENGE_ID" >> $GITHUB_OUTPUT

      - name: ğŸ“‚ Verify Challenge Directory
        id: verify-challenge
        run: |
          CHALLENGE_ID="${{ steps.extract-challenge.outputs.challenge_id }}"
          CHALLENGE_PATH="challenges/$CHALLENGE_ID"
          
          echo "ğŸ” PrÃ¼fe Challenge-Verzeichnis: $CHALLENGE_PATH"
          
          if [ ! -d "$CHALLENGE_PATH" ]; then
            echo "âŒ Challenge-Verzeichnis nicht gefunden: $CHALLENGE_PATH"
            echo "ğŸ“ VerfÃ¼gbare Verzeichnisse:"
            ls -la challenges/ || echo "Kein challenges/ Verzeichnis gefunden"
            exit 1
          fi
          
          if [ ! -f "$CHALLENGE_PATH/challenge.json" ]; then
            echo "âŒ challenge.json nicht gefunden in: $CHALLENGE_PATH"
            echo "ğŸ“ Verzeichnisinhalt:"
            ls -la "$CHALLENGE_PATH"
            exit 1
          fi
          
          echo "âœ… Challenge-Verzeichnis und challenge.json gefunden"
          echo "challenge_path=$CHALLENGE_PATH" >> $GITHUB_OUTPUT

      - name: ğŸ“„ Read Current Challenge Config
        id: read-config
        run: |
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          CONFIG_FILE="$CHALLENGE_PATH/challenge.json"
          
          echo "ğŸ“– Lese aktuelle Konfiguration aus: $CONFIG_FILE"
          
          # Aktuelle Konfiguration anzeigen
          echo "ğŸ“‹ Aktuelle challenge.json:"
          cat "$CONFIG_FILE" | jq '.' || cat "$CONFIG_FILE"
          
          # Status prÃ¼fen
          CURRENT_STATUS=$(cat "$CONFIG_FILE" | jq -r '.status // "unknown"')
          REPORTED_ISSUE=$(cat "$CONFIG_FILE" | jq -r '.reportedIssueNumber // "none"')
          IS_HIDDEN=$(cat "$CONFIG_FILE" | jq -r '.isHidden // false')
          
          echo "ğŸ“Š Aktueller Status: $CURRENT_STATUS"
          echo "ğŸ”— Gemeldetes Issue: $REPORTED_ISSUE"
          echo "ğŸ‘ï¸ Versteckt: $IS_HIDDEN"
          
          echo "current_status=$CURRENT_STATUS" >> $GITHUB_OUTPUT
          echo "reported_issue=$REPORTED_ISSUE" >> $GITHUB_OUTPUT
          echo "is_hidden=$IS_HIDDEN" >> $GITHUB_OUTPUT

      - name: ğŸ”„ Update Challenge Status
        id: update-status
        run: |
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          CONFIG_FILE="$CHALLENGE_PATH/challenge.json"
          CURRENT_STATUS="${{ steps.read-config.outputs.current_status }}"
          
          echo "ğŸ”§ Aktualisiere Challenge-Status..."
          echo "ğŸ“ Datei: $CONFIG_FILE"
          echo "ğŸ“Š Aktueller Status: $CURRENT_STATUS"
          
          # Backup der ursprÃ¼nglichen Datei erstellen
          cp "$CONFIG_FILE" "$CONFIG_FILE.backup"
          echo "ğŸ’¾ Backup erstellt: $CONFIG_FILE.backup"
          
          # Status auf "approved" setzen und Issue-Referenzen entfernen
          cat "$CONFIG_FILE" | jq '
            .status = "approved" |
            del(.reportedIssueNumber) |
            del(.reportedIssueUrl) |
            del(.isHidden) |
            .lastUpdated = now |
            .resolvedAt = now |
            .resolvedBy = "github-actions"
          ' > "$CONFIG_FILE.tmp"
          
          # PrÃ¼fen ob jq erfolgreich war
          if [ $? -eq 0 ] && [ -s "$CONFIG_FILE.tmp" ]; then
            mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
            echo "âœ… Challenge-Status erfolgreich aktualisiert"
            
            echo "ğŸ“‹ Neue Konfiguration:"
            cat "$CONFIG_FILE" | jq '.'
            
            # PrÃ¼fe ob Status wirklich geÃ¤ndert wurde
            NEW_STATUS=$(cat "$CONFIG_FILE" | jq -r '.status')
            if [ "$NEW_STATUS" = "approved" ]; then
              echo "âœ… Status-Update bestÃ¤tigt: $NEW_STATUS"
              echo "status_updated=true" >> $GITHUB_OUTPUT
            else
              echo "âŒ Status-Update fehlgeschlagen: $NEW_STATUS"
              echo "status_updated=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "âŒ jq-Bearbeitung fehlgeschlagen"
            echo "ğŸ”„ Stelle Backup wieder her..."
            mv "$CONFIG_FILE.backup" "$CONFIG_FILE"
            echo "status_updated=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: ğŸ” Handle Error Report File
        id: handle-error-report
        run: |
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          ERROR_REPORT_FILE="$CHALLENGE_PATH/error-report.json"
          
          echo "ğŸ” Suche nach error-report.json..."
          
          if [ -f "$ERROR_REPORT_FILE" ]; then
            echo "ğŸ“„ error-report.json gefunden: $ERROR_REPORT_FILE"
            
            # Error Report als resolved markieren (nicht lÃ¶schen fÃ¼r Audit-Trail)
            cat "$ERROR_REPORT_FILE" | jq '
              .isResolved = true |
              .resolvedAt = now |
              .resolvedBy = "github-actions" |
              .resolvedViaIssue = ${{ github.event.issue.number }}
            ' > "$ERROR_REPORT_FILE.tmp"
            
            if [ $? -eq 0 ] && [ -s "$ERROR_REPORT_FILE.tmp" ]; then
              mv "$ERROR_REPORT_FILE.tmp" "$ERROR_REPORT_FILE"
              echo "âœ… Error Report als resolved markiert"
              echo "error_report_updated=true" >> $GITHUB_OUTPUT
            else
              echo "âš ï¸ Fehler beim Aktualisieren des Error Reports"
              rm -f "$ERROR_REPORT_FILE.tmp"
              echo "error_report_updated=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "â„¹ï¸ Kein error-report.json gefunden (OK)"
            echo "error_report_updated=false" >> $GITHUB_OUTPUT
          fi

      - name: ğŸ“ Create Resolution Log
        run: |
          CHALLENGE_ID="${{ steps.extract-challenge.outputs.challenge_id }}"
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          RESOLUTION_LOG="$CHALLENGE_PATH/resolution-log.json"
          
          echo "ğŸ“ Erstelle Resolution Log..."
          
          # Resolution Log erstellen oder erweitern
          if [ -f "$RESOLUTION_LOG" ]; then
            # Bestehenden Log erweitern
            cat "$RESOLUTION_LOG" | jq --arg issue_num "${{ github.event.issue.number }}" --arg issue_url "${{ github.event.issue.html_url }}" '
              .resolutions += [{
                "issueNumber": ($issue_num | tonumber),
                "issueUrl": $issue_url,
                "resolvedAt": now,
                "resolvedBy": "github-actions",
                "workflow": "challenge-issue-handler"
              }]
            ' > "$RESOLUTION_LOG.tmp"
          else
            # Neuen Log erstellen
            jq -n --arg challenge_id "$CHALLENGE_ID" --arg issue_num "${{ github.event.issue.number }}" --arg issue_url "${{ github.event.issue.html_url }}" '{
              "challengeId": $challenge_id,
              "resolutions": [{
                "issueNumber": ($issue_num | tonumber),
                "issueUrl": $issue_url,
                "resolvedAt": now,
                "resolvedBy": "github-actions",
                "workflow": "challenge-issue-handler"
              }]
            }' > "$RESOLUTION_LOG.tmp"
          fi
          
          if [ $? -eq 0 ] && [ -s "$RESOLUTION_LOG.tmp" ]; then
            mv "$RESOLUTION_LOG.tmp" "$RESOLUTION_LOG"
            echo "âœ… Resolution Log erstellt/aktualisiert"
          else
            echo "âš ï¸ Fehler beim Erstellen des Resolution Logs"
            rm -f "$RESOLUTION_LOG.tmp"
          fi

      - name: ğŸš€ Commit Changes
        run: |
          CHALLENGE_ID="${{ steps.extract-challenge.outputs.challenge_id }}"
          
          # Git-Konfiguration
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # Ã„nderungen stagen
          git add "challenges/$CHALLENGE_ID/"
          
          # PrÃ¼fen ob es Ã„nderungen gibt
          if git diff --staged --quiet; then
            echo "â„¹ï¸ Keine Ã„nderungen zum Committen"
          else
            echo "ğŸ“¤ Committe Ã„nderungen..."
            
            # Commit mit detaillierter Nachricht
            git commit -m "ğŸ”§ Reset challenge status after issue resolution
            
            âœ… Challenge: $CHALLENGE_ID
            ğŸ”— Resolved Issue: #${{ github.event.issue.number }}
            ğŸ“Š Status: reported â†’ approved
            ğŸ‘ï¸ Visibility: restored
            ğŸ¤– Automated by: GitHub Actions
            
            The challenge is now available again for users.
            Challenge-specific error has been resolved."
            
            # Push Ã„nderungen
            git push
            
            echo "âœ… Ã„nderungen erfolgreich committed und gepusht"
          fi

      - name: ğŸ“Š Summary Report
        run: |
          echo "ğŸ‰ Challenge Issue Handler - Zusammenfassung"
          echo "=============================================="
          echo "ğŸ¯ Challenge ID: ${{ steps.extract-challenge.outputs.challenge_id }}"
          echo "ğŸ”— Issue: #${{ github.event.issue.number }} - ${{ github.event.issue.title }}"
          echo "ğŸ“Š Status Update: ${{ steps.update-status.outputs.status_updated }}"
          echo "ğŸ“„ Error Report: ${{ steps.handle-error-report.outputs.error_report_updated }}"
          echo "â° Zeitpunkt: $(date -u)"
          echo ""
          echo "âœ… Challenge ist wieder verfÃ¼gbar fÃ¼r Benutzer!"
          echo "ğŸ”§ Das gemeldete Problem wurde als gelÃ¶st markiert."

      - name: ğŸ’¬ Comment on Issue
        uses: actions/github-script@v7
        with:
          script: |
            const challengeId = '${{ steps.extract-challenge.outputs.challenge_id }}';
            const statusUpdated = '${{ steps.update-status.outputs.status_updated }}' === 'true';
            
            if (statusUpdated) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `ğŸ¤– **Automatische Challenge-Wiederherstellung**

âœ… **Challenge Status aktualisiert**
- **Challenge ID:** \`${challengeId}\`
- **Status:** \`reported\` â†’ \`approved\`
- **Sichtbarkeit:** Wiederhergestellt

ğŸ¯ **Ergebnis:** Die Challenge ist jetzt wieder fÃ¼r alle Benutzer verfÃ¼gbar!

---
ğŸ”§ *Automatisch verarbeitet durch GitHub Actions*`
              });
              
              console.log('âœ… BestÃ¤tigungskommentar hinzugefÃ¼gt');
            } else {
              console.log('âš ï¸ Status nicht aktualisiert - kein Kommentar hinzugefÃ¼gt');
            }

  # Fallback Job fÃ¼r Debugging bei Fehlern
  debug-info:
    name: ğŸ› Debug Information
    runs-on: ubuntu-latest
    if: failure() && contains(github.event.issue.labels.*.name, 'challenge-error')
    needs: [reset-challenge-status]
    
    steps:
      - name: ğŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        
      - name: ğŸ” Debug Information
        run: |
          echo "ğŸ› Debug-Informationen fÃ¼r fehlgeschlagenen Workflow"
          echo "===================================================="
          echo "ğŸ“‹ Issue #${{ github.event.issue.number }}"
          echo "ğŸ·ï¸ Labels: ${{ join(github.event.issue.labels.*.name, ', ') }}"
          echo "ğŸ“ Titel: ${{ github.event.issue.title }}"
          echo ""
          echo "ğŸ“ VerfÃ¼gbare Challenge-Verzeichnisse:"
          ls -la challenges/ || echo "âŒ Kein challenges/ Verzeichnis"
          echo ""
          echo "ğŸ” Challenge-Verzeichnisse mit 'reported' Status:"
          for dir in challenges/*/; do
            if [ -f "$dir/challenge.json" ]; then
              status=$(cat "$dir/challenge.json" | grep -o '"status":\s*"[^"]*"' | head -1)
              echo "  $(basename $dir): $status"
            fi
          done
