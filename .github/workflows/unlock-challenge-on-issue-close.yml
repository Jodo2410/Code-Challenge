name: ğŸ”“ Unlock Challenge bei Issue-SchlieÃŸung

on:
  issues:
    types: [closed]

# âœ… FIX: Token-Permissions explizit setzen
permissions:
  issues: write
  contents: write
  pull-requests: write

jobs:
  unlock-challenge:
    # Robuste Trigger-Bedingungen (mehrere Fallbacks)
    if: |
      contains(github.event.issue.labels.*.name, 'challenge-error') ||
      contains(github.event.issue.title, 'Challenge Error Report') ||
      contains(github.event.issue.body, 'ğŸš¨ Challenge Error Report') ||
      contains(github.event.issue.body, '**ID:**')
    runs-on: ubuntu-latest
    
    steps:
      - name: ğŸ“¦ Repository auschecken
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: ğŸ” Debug Issue Information
        run: |
          echo "ğŸ” DEBUG: Issue-Informationen"
          echo "Issue Nummer: ${{ github.event.issue.number }}"
          echo "Issue Titel: ${{ github.event.issue.title }}"
          echo "Issue State: ${{ github.event.issue.state }}"
          echo "Issue Action: ${{ github.event.action }}"
          echo ""
          echo "ğŸ“‹ Issue Labels:"
          echo '${{ toJSON(github.event.issue.labels) }}' | jq -r '.[].name' 2>/dev/null || echo "Keine Labels oder jq fehlt"
          echo ""
          echo "ğŸ“„ Issue Body (erste 1000 Zeichen):"
          echo "${{ github.event.issue.body }}" | head -c 1000
          echo ""
      
      - name: ğŸ” Challenge-ID aus Issue extrahieren (Robust)
        id: extract
        run: |
          echo "ğŸ“„ Robust Challenge-ID Extraktion..."
          
          # Issue-Body sicher in Variable speichern
          ISSUE_BODY='${{ github.event.issue.body }}'
          
          echo "ğŸ” Teste verschiedene Extraktions-Methoden..."
          
          # Methode 1: **ID:** pattern (hÃ¤ufigster Fall)
          ID=$(echo "$ISSUE_BODY" | grep -oE '\*\*ID:\*\*[[:space:]]*[a-zA-Z0-9_-]+' | sed 's/.*\*\*ID:\*\*[[:space:]]*//' | head -1 | xargs || echo "")
          echo "Test 1 (**ID:** pattern): '$ID'"
          
          # Methode 2: Falls Methode 1 fehlschlÃ¤gt - suche nach ID: ohne Markdown
          if [ -z "$ID" ]; then
            ID=$(echo "$ISSUE_BODY" | grep -E '^ID:' | cut -d ':' -f2 | xargs || echo "")
            echo "Test 2 (ID: pattern): '$ID'"
          fi
          
          # Methode 3: Regex mit grep -P (falls verfÃ¼gbar)
          if [ -z "$ID" ]; then
            ID=$(echo "$ISSUE_BODY" | grep -oP '\*\*ID:\*\*\s*\K[a-zA-Z0-9_-]+' 2>/dev/null | head -1 || echo "")
            echo "Test 3 (grep -P): '$ID'"
          fi
          
          # Methode 4: Suche nach challenge-id pattern Ã¼berall im Text
          if [ -z "$ID" ]; then
            ID=$(echo "$ISSUE_BODY" | grep -oE '[a-zA-Z0-9]+-[a-zA-Z0-9]+-[a-zA-Z0-9]+-[a-zA-Z0-9]+-[a-zA-Z0-9]+' | grep -E '.*-mcbt[0-9a-z]+' | head -1 || echo "")
            echo "Test 4 (mcbt pattern): '$ID'"
          fi
          
          # Methode 5: Letzter Fallback - manuell parsen
          if [ -z "$ID" ]; then
            echo "âš ï¸ Alle automatischen Methoden fehlgeschlagen"
            echo "ğŸ“‹ VollstÃ¤ndiger Issue-Body fÃ¼r manuelle Analyse:"
            echo "$ISSUE_BODY"
            echo "ğŸ“‹ Challenge-ID manuell suchen..."
            
            # Versuche alles was wie eine Challenge-ID aussieht
            ID=$(echo "$ISSUE_BODY" | grep -oE '[a-z]+-[a-z0-9-]+-mcbt[a-z0-9]+' | head -1 || echo "")
            echo "Test 5 (manuell): '$ID'"
          fi
          
          # Validierung der gefundenen ID
          if [ -n "$ID" ]; then
            echo "âœ… Challenge-ID erfolgreich extrahiert: '$ID'"
            
            # PrÃ¼fe ob ID das erwartete Format hat
            if echo "$ID" | grep -qE '^[a-zA-Z0-9]+-.*-mcbt[a-zA-Z0-9]+$'; then
              echo "âœ… ID-Format validiert (enthÃ¤lt mcbt)"
            else
              echo "âš ï¸ Unerwartetes ID-Format, aber versuche trotzdem"
            fi
            
            echo "challenge_id=$ID" >> $GITHUB_OUTPUT
          else
            echo "âŒ Keine Challenge-ID gefunden!"
            echo ""
            echo "ğŸ” DEBUG: Issue-Body zur manuellen PrÃ¼fung:"
            echo "=============================="
            echo "$ISSUE_BODY"
            echo "=============================="
            echo ""
            echo "ğŸ’¡ Erwartetes Format: **ID:** your-challenge-id-here"
            exit 1
          fi
      
      - name: âœ… PrÃ¼fe ob Challenge existiert
        id: check
        run: |
          ID=${{ steps.extract.outputs.challenge_id }}
          CHALLENGE_DIR="challenges/$ID"
          CONFIG_FILE="$CHALLENGE_DIR/challenge.json"
          
          echo "ğŸ” PrÃ¼fe Challenge-Existenz fÃ¼r ID: $ID"
          echo "ğŸ“ Challenge-Verzeichnis: $CHALLENGE_DIR"
          echo "ğŸ“„ Config-Datei: $CONFIG_FILE"
          
          if [ ! -d "$CHALLENGE_DIR" ]; then
            echo "âŒ Challenge-Ordner nicht gefunden: $CHALLENGE_DIR"
            echo "ğŸ“ VerfÃ¼gbare Challenges:"
            ls -la challenges/ 2>/dev/null || echo "Challenges-Ordner existiert nicht"
            exit 1
          fi
          
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "âŒ Challenge-Konfiguration nicht gefunden: $CONFIG_FILE"
            echo "ğŸ“ Ordner-Inhalt:"
            ls -la "$CHALLENGE_DIR"
            exit 1
          fi
          
          echo "âœ… Challenge existiert: $CONFIG_FILE"
          
          # Aktueller Status prÃ¼fen (mit jq fallback)
          if command -v jq >/dev/null 2>&1; then
            CURRENT_STATUS=$(jq -r '.status // "unknown"' "$CONFIG_FILE")
            echo "ğŸ“Š Aktueller Status: $CURRENT_STATUS"
            echo "current_status=$CURRENT_STATUS" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ jq nicht verfÃ¼gbar, Ã¼berspringe Status-Check"
            echo "current_status=unknown" >> $GITHUB_OUTPUT
          fi
      
      - name: ğŸ”§ Challenge-Status zurÃ¼cksetzen
        run: |
          ID=${{ steps.extract.outputs.challenge_id }}
          CONFIG_FILE="challenges/$ID/challenge.json"
          
          echo "ğŸ› ï¸ Setze Challenge-Status zurÃ¼ck in: $CONFIG_FILE"
          
          # Backup erstellen
          cp "$CONFIG_FILE" "$CONFIG_FILE.backup"
          echo "ğŸ“‹ Backup erstellt: $CONFIG_FILE.backup"
          
          # Status zurÃ¼cksetzen - mit und ohne jq
          if command -v jq >/dev/null 2>&1; then
            echo "ğŸ”§ Verwende jq fÃ¼r Status-Update"
            jq '
              .status = "approved" |
              .hasErrors = false |
              .isHidden = false |
              del(.reportedIssueNumber) |
              del(.reportedIssueUrl) |
              del(.errorReport) |
              .lastUpdated = now | strftime("%Y-%m-%dT%H:%M:%SZ")
            ' "$CONFIG_FILE" > "$CONFIG_FILE.tmp" && mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
          else
            echo "ğŸ”§ Verwende sed fÃ¼r Status-Update (jq nicht verfÃ¼gbar)"
            # Einfaches sed-basiertes Update als Fallback
            sed -i 's/"status"[[:space:]]*:[[:space:]]*"[^"]*"/"status": "approved"/g' "$CONFIG_FILE"
            sed -i 's/"hasErrors"[[:space:]]*:[[:space:]]*true/"hasErrors": false/g' "$CONFIG_FILE"
            sed -i 's/"isHidden"[[:space:]]*:[[:space:]]*true/"isHidden": false/g' "$CONFIG_FILE"
          fi
          
          echo "âœ… Challenge-Status aktualisiert"
          echo "ğŸ“‹ Neue Datei-GrÃ¶ÃŸe: $(wc -c < "$CONFIG_FILE") bytes"
      
      - name: ğŸ“ Error-Report als gelÃ¶st markieren (optional)
        run: |
          ID=${{ steps.extract.outputs.challenge_id }}
          ERROR_FILE="challenges/$ID/error-report.json"
          
          if [ -f "$ERROR_FILE" ]; then
            echo "ğŸ“ Markiere Error-Report als gelÃ¶st: $ERROR_FILE"
            
            if command -v jq >/dev/null 2>&1; then
              jq '
                .isResolved = true |
                .resolvedAt = now | strftime("%Y-%m-%dT%H:%M:%SZ") |
                .resolvedBy = "github-action" |
                .resolvedIssue = ${{ github.event.issue.number }}
              ' "$ERROR_FILE" > "$ERROR_FILE.tmp" && mv "$ERROR_FILE.tmp" "$ERROR_FILE"
              echo "âœ… Error-Report mit jq aktualisiert"
            else
              echo "â„¹ï¸ jq nicht verfÃ¼gbar, Ã¼berspringe Error-Report Update"
            fi
          else
            echo "â„¹ï¸ Kein Error-Report gefunden ($ERROR_FILE)"
          fi
      
      - name: ğŸ¯ Git-Konfiguration setzen
        run: |
          git config user.name "Challenge-Unlock-Bot"
          git config user.email "action@github.com"
      
      - name: ğŸ’¾ Ã„nderungen committen und pushen
        run: |
          ID=${{ steps.extract.outputs.challenge_id }}
          
          # Status prÃ¼fen
          if git diff --quiet; then
            echo "â„¹ï¸ Keine Ã„nderungen zu committen"
          else
            echo "ğŸ“ Committe Ã„nderungen..."
            
            # Ã„nderungen hinzufÃ¼gen
            git add "challenges/$ID/"
            
            # Commit erstellen
            git commit -m "ğŸ”“ Unlock Challenge '$ID' nach Issue-SchlieÃŸung
            
            âœ… Challenge wieder freigegeben nach Issue #${{ github.event.issue.number }}
            ğŸ“‹ Status: approved
            ğŸ—“ï¸ Freigegeben: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
            ğŸ¤– Automatisch durch GitHub Action"
            
            echo "âœ… Ã„nderungen committet"
            
            # Push versuchen
            echo "ğŸ“¤ Pushe Ã„nderungen..."
            if git push origin main; then
              echo "âœ… Ã„nderungen erfolgreich gepusht"
            else
              echo "âŒ Push fehlgeschlagen, versuche mit force"
              git push --force-with-lease origin main
            fi
          fi
      
      - name: ğŸ’¬ Erfolgs-Kommentar hinzufÃ¼gen
        uses: actions/github-script@v7
        with:
          script: |
            const challengeId = '${{ steps.extract.outputs.challenge_id }}';
            const currentStatus = '${{ steps.check.outputs.current_status }}';
            
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `## âœ… Challenge automatisch freigegeben!
                
                **Challenge-ID:** \`${challengeId}\`
                **Vorheriger Status:** \`${currentStatus}\`
                **Neuer Status:** \`approved\`
                
                ### ğŸ‰ Was passiert ist:
                - âœ… Challenge-Status wurde auf \`approved\` zurÃ¼ckgesetzt
                - ğŸ”“ Challenge ist wieder fÃ¼r Benutzer sichtbar
                - ğŸ“ Error-Report als gelÃ¶st markiert
                - ğŸ—‘ï¸ Fehler-Flags entfernt
                
                ### ğŸš€ NÃ¤chste Schritte:
                Die Challenge \`${challengeId}\` ist jetzt wieder verfÃ¼gbar und kann in der VS Code Extension geladen werden.
                
                ---
                ğŸ¤– *Automatisch ausgefÃ¼hrt durch GitHub Action*`
              });
              
              console.log('âœ… Erfolgs-Kommentar hinzugefÃ¼gt');
            } catch (error) {
              console.error('âŒ Fehler beim HinzufÃ¼gen des Kommentars:', error);
              // Fehler nicht weiterwerfen, da Haupt-Task erfolgreich war
            }
      
      - name: ğŸ·ï¸ Issue-Labels aktualisieren  
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // 'resolved' Label hinzufÃ¼gen
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['resolved', 'auto-fixed']
              });
              
              console.log('âœ… Labels hinzugefÃ¼gt: resolved, auto-fixed');
            } catch (error) {
              console.error('âŒ Fehler beim HinzufÃ¼gen der Labels:', error);
              // Fehler nicht weiterwerfen, da Haupt-Task erfolgreich war
            }

  # âœ… FIX: Verbesserter Fehlerbehandlungs-Job
  handle-failure:
    if: |
      failure() && (
        contains(github.event.issue.labels.*.name, 'challenge-error') ||
        contains(github.event.issue.title, 'Challenge Error Report') ||
        contains(github.event.issue.body, 'ğŸš¨ Challenge Error Report')
      )
    runs-on: ubuntu-latest
    needs: unlock-challenge
    
    # âœ… FIX: Explizite Permissions fÃ¼r Fehlerbehandlung
    permissions:
      issues: write
    
    steps:
      - name: ğŸ’¬ Detaillierter Fehler-Kommentar
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                body: `## âŒ Automatische Challenge-Freigabe fehlgeschlagen
                
                Der Versuch, diese Challenge automatisch freizugeben, ist fehlgeschlagen.
                
                ### ğŸ› ï¸ Manuelle Schritte erforderlich:
                1. **Challenge-ID extrahieren:** Suche nach \`**ID:** challenge-id-hier\` im Issue-Body
                2. **Datei bearbeiten:** Ã–ffne \`challenges/{challenge-id}/challenge.json\`
                3. **Status setzen:** Ã„ndere \`"status": "reported"\` zu \`"status": "approved"\`
                4. **Flags entfernen:** LÃ¶sche \`hasErrors\`, \`isHidden\`, \`reportedIssueNumber\`, \`reportedIssueUrl\`
                5. **Committen:** Speichere und pushe die Ã„nderungen
                
                ### ğŸ” Debugging-Info:
                - **Issue:** #${context.issue.number}
                - **Workflow-Run:** [${context.runId}](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
                - **Timestamp:** ${new Date().toISOString()}
                - **Fehler-Typ:** Siehe Workflow-Log fÃ¼r Details
                
                ### ğŸ“‹ Wahrscheinliche Ursachen:
                - Challenge-ID konnte nicht aus Issue-Body extrahiert werden
                - Challenge-Datei existiert nicht im erwarteten Pfad
                - Git-Permission oder jq-Tool Problem
                
                ---
                ğŸ¤– *Automatischer Fehlerkommentar - Manuelle Aktion erforderlich*`
              });
              
              // 'manual-action-required' Label hinzufÃ¼gen
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['manual-action-required', 'auto-unlock-failed']
              });
              
              console.log('âœ… Fehler-Kommentar und Labels hinzugefÃ¼gt');
            } catch (error) {
              console.error('âŒ Fehler beim Erstellen des Fehler-Kommentars:', error);
            }
