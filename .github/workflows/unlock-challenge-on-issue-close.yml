# GitHub Actions Workflow f√ºr automatische Challenge-Status-Updates
# Wird ausgel√∂st wenn ein Issue mit "challenge-error" Label geschlossen wird

name: üîß Challenge Issue Handler

on:
  issues:
    types: [closed]

# ‚úÖ WICHTIG: Token-Berechtigungen definieren
permissions:
  contents: write        # Zum √Ñndern von Dateien
  issues: write         # Zum Kommentieren von Issues
  metadata: read        # Standard-Berechtigung

jobs:
  reset-challenge-status:
    name: üîÑ Reset Challenge Status
    runs-on: ubuntu-latest
    
    # Nur ausf√ºhren wenn Issue das "challenge-error" Label hat
    if: contains(github.event.issue.labels.*.name, 'challenge-error')
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: üîç Extract Challenge ID from Issue
        id: extract-challenge
        run: |
          # Challenge ID aus Issue-Body oder Titel extrahieren
          ISSUE_BODY="${{ github.event.issue.body }}"
          ISSUE_TITLE="${{ github.event.issue.title }}"
          
          echo "üîç Analysiere Issue #${{ github.event.issue.number }}"
          echo "üìã Titel: $ISSUE_TITLE"
          
          # Pattern 1: Challenge ID aus Issue Body extrahieren
          CHALLENGE_ID=""
          
          # Suche nach "Challenge ID: xyz" oder "ID: xyz" im Body
          if echo "$ISSUE_BODY" | grep -q "Challenge.*ID.*:"; then
            CHALLENGE_ID=$(echo "$ISSUE_BODY" | grep -o "Challenge.*ID.*:\s*\`[^`]*\`" | sed 's/.*`\([^`]*\)`.*/\1/')
          elif echo "$ISSUE_BODY" | grep -q "ID.*:"; then
            CHALLENGE_ID=$(echo "$ISSUE_BODY" | grep -o "ID.*:\s*\`[^`]*\`" | sed 's/.*`\([^`]*\)`.*/\1/')
          fi
          
          # Pattern 2: Aus Issue-Titel extrahieren (Format: "Challenge Error: Title (language)")
          if [ -z "$CHALLENGE_ID" ] && echo "$ISSUE_TITLE" | grep -q "Challenge Error:"; then
            # Extrahiere Challenge-Namen aus Titel und konvertiere zu ID
            CHALLENGE_NAME=$(echo "$ISSUE_TITLE" | sed 's/.*Challenge Error:\s*\([^(]*\).*/\1/' | sed 's/[[:space:]]*$//')
            echo "üìù Challenge Name gefunden: $CHALLENGE_NAME"
            
            # Suche nach challenge.json Dateien mit diesem Titel
            for challenge_dir in challenges/*/; do
              if [ -f "$challenge_dir/challenge.json" ]; then
                TITLE_IN_FILE=$(cat "$challenge_dir/challenge.json" | grep -o '"title":\s*"[^"]*"' | sed 's/"title":\s*"\([^"]*)"/\1/')
                if [ "$TITLE_IN_FILE" = "$CHALLENGE_NAME" ]; then
                  CHALLENGE_ID=$(basename "$challenge_dir")
                  echo "‚úÖ Challenge ID gefunden: $CHALLENGE_ID"
                  break
                fi
              fi
            done
          fi
          
          # Pattern 3: Challenge ID direkt aus verf√ºgbaren Ordnern ableiten
          if [ -z "$CHALLENGE_ID" ]; then
            echo "‚ö†Ô∏è Challenge ID nicht aus Issue extrahiert. Suche in challenges/ Verzeichnis..."
            
            # Liste alle Challenge-Verzeichnisse und suche nach passendem Titel
            for challenge_dir in challenges/*/; do
              if [ -f "$challenge_dir/challenge.json" ]; then
                # Pr√ºfe ob diese Challenge als "reported" markiert ist
                STATUS=$(cat "$challenge_dir/challenge.json" | grep -o '"status":\s*"[^"]*"' | sed 's/"status":\s*"\([^"]*\)"/\1/')
                ISSUE_NUM=$(cat "$challenge_dir/challenge.json" | grep -o '"reportedIssueNumber":\s*[0-9]*' | sed 's/"reportedIssueNumber":\s*\([0-9]*\)/\1/')
                
                if [ "$STATUS" = "reported" ] && [ "$ISSUE_NUM" = "${{ github.event.issue.number }}" ]; then
                  CHALLENGE_ID=$(basename "$challenge_dir")
                  echo "‚úÖ Challenge ID √ºber Issue-Nummer gefunden: $CHALLENGE_ID"
                  break
                fi
              fi
            done
          fi
          
          if [ -z "$CHALLENGE_ID" ]; then
            echo "‚ùå Challenge ID konnte nicht bestimmt werden!"
            echo "üîç Verf√ºgbare Challenge-Verzeichnisse:"
            ls -la challenges/ || echo "Kein challenges/ Verzeichnis gefunden"
            exit 1
          fi
          
          echo "üéØ Challenge ID: $CHALLENGE_ID"
          echo "challenge_id=$CHALLENGE_ID" >> $GITHUB_OUTPUT

      - name: üìÇ Verify Challenge Directory
        id: verify-challenge
        run: |
          CHALLENGE_ID="${{ steps.extract-challenge.outputs.challenge_id }}"
          CHALLENGE_PATH="challenges/$CHALLENGE_ID"
          
          echo "üîç Pr√ºfe Challenge-Verzeichnis: $CHALLENGE_PATH"
          
          if [ ! -d "$CHALLENGE_PATH" ]; then
            echo "‚ùå Challenge-Verzeichnis nicht gefunden: $CHALLENGE_PATH"
            echo "üìÅ Verf√ºgbare Verzeichnisse:"
            ls -la challenges/ || echo "Kein challenges/ Verzeichnis gefunden"
            exit 1
          fi
          
          if [ ! -f "$CHALLENGE_PATH/challenge.json" ]; then
            echo "‚ùå challenge.json nicht gefunden in: $CHALLENGE_PATH"
            echo "üìÅ Verzeichnisinhalt:"
            ls -la "$CHALLENGE_PATH"
            exit 1
          fi
          
          echo "‚úÖ Challenge-Verzeichnis und challenge.json gefunden"
          echo "challenge_path=$CHALLENGE_PATH" >> $GITHUB_OUTPUT

      - name: üìÑ Read Current Challenge Config
        id: read-config
        run: |
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          CONFIG_FILE="$CHALLENGE_PATH/challenge.json"
          
          echo "üìñ Lese aktuelle Konfiguration aus: $CONFIG_FILE"
          
          # Aktuelle Konfiguration anzeigen
          echo "üìã Aktuelle challenge.json:"
          cat "$CONFIG_FILE" | jq '.' || cat "$CONFIG_FILE"
          
          # Status pr√ºfen
          CURRENT_STATUS=$(cat "$CONFIG_FILE" | jq -r '.status // "unknown"')
          REPORTED_ISSUE=$(cat "$CONFIG_FILE" | jq -r '.reportedIssueNumber // "none"')
          IS_HIDDEN=$(cat "$CONFIG_FILE" | jq -r '.isHidden // false')
          
          echo "üìä Aktueller Status: $CURRENT_STATUS"
          echo "üîó Gemeldetes Issue: $REPORTED_ISSUE"
          echo "üëÅÔ∏è Versteckt: $IS_HIDDEN"
          
          echo "current_status=$CURRENT_STATUS" >> $GITHUB_OUTPUT
          echo "reported_issue=$REPORTED_ISSUE" >> $GITHUB_OUTPUT
          echo "is_hidden=$IS_HIDDEN" >> $GITHUB_OUTPUT

      - name: üîÑ Update Challenge Status
        id: update-status
        run: |
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          CONFIG_FILE="$CHALLENGE_PATH/challenge.json"
          CURRENT_STATUS="${{ steps.read-config.outputs.current_status }}"
          
          echo "üîß Aktualisiere Challenge-Status..."
          echo "üìÅ Datei: $CONFIG_FILE"
          echo "üìä Aktueller Status: $CURRENT_STATUS"
          
          # Backup der urspr√ºnglichen Datei erstellen
          cp "$CONFIG_FILE" "$CONFIG_FILE.backup"
          echo "üíæ Backup erstellt: $CONFIG_FILE.backup"
          
          # Status auf "approved" setzen und Issue-Referenzen entfernen
          cat "$CONFIG_FILE" | jq '
            .status = "approved" |
            del(.reportedIssueNumber) |
            del(.reportedIssueUrl) |
            del(.isHidden) |
            .lastUpdated = now |
            .resolvedAt = now |
            .resolvedBy = "github-actions"
          ' > "$CONFIG_FILE.tmp"
          
          # Pr√ºfen ob jq erfolgreich war
          if [ $? -eq 0 ] && [ -s "$CONFIG_FILE.tmp" ]; then
            mv "$CONFIG_FILE.tmp" "$CONFIG_FILE"
            echo "‚úÖ Challenge-Status erfolgreich aktualisiert"
            
            echo "üìã Neue Konfiguration:"
            cat "$CONFIG_FILE" | jq '.'
            
            # Pr√ºfe ob Status wirklich ge√§ndert wurde
            NEW_STATUS=$(cat "$CONFIG_FILE" | jq -r '.status')
            if [ "$NEW_STATUS" = "approved" ]; then
              echo "‚úÖ Status-Update best√§tigt: $NEW_STATUS"
              echo "status_updated=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Status-Update fehlgeschlagen: $NEW_STATUS"
              echo "status_updated=false" >> $GITHUB_OUTPUT
              exit 1
            fi
          else
            echo "‚ùå jq-Bearbeitung fehlgeschlagen"
            echo "üîÑ Stelle Backup wieder her..."
            mv "$CONFIG_FILE.backup" "$CONFIG_FILE"
            echo "status_updated=false" >> $GITHUB_OUTPUT
            exit 1
          fi

      - name: üîç Handle Error Report File
        id: handle-error-report
        run: |
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          ERROR_REPORT_FILE="$CHALLENGE_PATH/error-report.json"
          
          echo "üîç Suche nach error-report.json..."
          
          if [ -f "$ERROR_REPORT_FILE" ]; then
            echo "üìÑ error-report.json gefunden: $ERROR_REPORT_FILE"
            
            # Error Report als resolved markieren (nicht l√∂schen f√ºr Audit-Trail)
            cat "$ERROR_REPORT_FILE" | jq '
              .isResolved = true |
              .resolvedAt = now |
              .resolvedBy = "github-actions" |
              .resolvedViaIssue = ${{ github.event.issue.number }}
            ' > "$ERROR_REPORT_FILE.tmp"
            
            if [ $? -eq 0 ] && [ -s "$ERROR_REPORT_FILE.tmp" ]; then
              mv "$ERROR_REPORT_FILE.tmp" "$ERROR_REPORT_FILE"
              echo "‚úÖ Error Report als resolved markiert"
              echo "error_report_updated=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è Fehler beim Aktualisieren des Error Reports"
              rm -f "$ERROR_REPORT_FILE.tmp"
              echo "error_report_updated=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ÑπÔ∏è Kein error-report.json gefunden (OK)"
            echo "error_report_updated=false" >> $GITHUB_OUTPUT
          fi

      - name: üìù Create Resolution Log
        run: |
          CHALLENGE_ID="${{ steps.extract-challenge.outputs.challenge_id }}"
          CHALLENGE_PATH="${{ steps.verify-challenge.outputs.challenge_path }}"
          RESOLUTION_LOG="$CHALLENGE_PATH/resolution-log.json"
          
          echo "üìù Erstelle Resolution Log..."
          
          # Resolution Log erstellen oder erweitern
          if [ -f "$RESOLUTION_LOG" ]; then
            # Bestehenden Log erweitern
            cat "$RESOLUTION_LOG" | jq --arg issue_num "${{ github.event.issue.number }}" --arg issue_url "${{ github.event.issue.html_url }}" '
              .resolutions += [{
                "issueNumber": ($issue_num | tonumber),
                "issueUrl": $issue_url,
                "resolvedAt": now,
                "resolvedBy": "github-actions",
                "workflow": "challenge-issue-handler"
              }]
            ' > "$RESOLUTION_LOG.tmp"
          else
            # Neuen Log erstellen
            jq -n --arg challenge_id "$CHALLENGE_ID" --arg issue_num "${{ github.event.issue.number }}" --arg issue_url "${{ github.event.issue.html_url }}" '{
              "challengeId": $challenge_id,
              "resolutions": [{
                "issueNumber": ($issue_num | tonumber),
                "issueUrl": $issue_url,
                "resolvedAt": now,
                "resolvedBy": "github-actions",
                "workflow": "challenge-issue-handler"
              }]
            }' > "$RESOLUTION_LOG.tmp"
          fi
          
          if [ $? -eq 0 ] && [ -s "$RESOLUTION_LOG.tmp" ]; then
            mv "$RESOLUTION_LOG.tmp" "$RESOLUTION_LOG"
            echo "‚úÖ Resolution Log erstellt/aktualisiert"
          else
            echo "‚ö†Ô∏è Fehler beim Erstellen des Resolution Logs"
            rm -f "$RESOLUTION_LOG.tmp"
          fi

      - name: üöÄ Commit Changes
        run: |
          CHALLENGE_ID="${{ steps.extract-challenge.outputs.challenge_id }}"
          
          # Git-Konfiguration
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          
          # √Ñnderungen stagen
          git add "challenges/$CHALLENGE_ID/"
          
          # Pr√ºfen ob es √Ñnderungen gibt
          if git diff --staged --quiet; then
            echo "‚ÑπÔ∏è Keine √Ñnderungen zum Committen"
          else
            echo "üì§ Committe √Ñnderungen..."
            
            # Commit mit detaillierter Nachricht
            git commit -m "üîß Reset challenge status after issue resolution
            
            ‚úÖ Challenge: $CHALLENGE_ID
            üîó Resolved Issue: #${{ github.event.issue.number }}
            üìä Status: reported ‚Üí approved
            üëÅÔ∏è Visibility: restored
            ü§ñ Automated by: GitHub Actions
            
            The challenge is now available again for users.
            Challenge-specific error has been resolved."
            
            # Push √Ñnderungen
            git push
            
            echo "‚úÖ √Ñnderungen erfolgreich committed und gepusht"
          fi

      - name: üìä Summary Report
        run: |
          echo "üéâ Challenge Issue Handler - Zusammenfassung"
          echo "=============================================="
          echo "üéØ Challenge ID: ${{ steps.extract-challenge.outputs.challenge_id }}"
          echo "üîó Issue: #${{ github.event.issue.number }} - ${{ github.event.issue.title }}"
          echo "üìä Status Update: ${{ steps.update-status.outputs.status_updated }}"
          echo "üìÑ Error Report: ${{ steps.handle-error-report.outputs.error_report_updated }}"
          echo "‚è∞ Zeitpunkt: $(date -u)"
          echo ""
          echo "‚úÖ Challenge ist wieder verf√ºgbar f√ºr Benutzer!"
          echo "üîß Das gemeldete Problem wurde als gel√∂st markiert."

      - name: üí¨ Comment on Issue
        uses: actions/github-script@v7
        with:
          script: |
            const challengeId = '${{ steps.extract-challenge.outputs.challenge_id }}';
            const statusUpdated = '${{ steps.update-status.outputs.status_updated }}' === 'true';
            
            if (statusUpdated) {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: `ü§ñ **Automatische Challenge-Wiederherstellung**

‚úÖ **Challenge Status aktualisiert**
- **Challenge ID:** \`${challengeId}\`
- **Status:** \`reported\` ‚Üí \`approved\`
- **Sichtbarkeit:** Wiederhergestellt

üéØ **Ergebnis:** Die Challenge ist jetzt wieder f√ºr alle Benutzer verf√ºgbar!

---
üîß *Automatisch verarbeitet durch GitHub Actions*`
              });
              
              console.log('‚úÖ Best√§tigungskommentar hinzugef√ºgt');
            } else {
              console.log('‚ö†Ô∏è Status nicht aktualisiert - kein Kommentar hinzugef√ºgt');
            }

  # Fallback Job f√ºr Debugging bei Fehlern
  debug-info:
    name: üêõ Debug Information
    runs-on: ubuntu-latest
    if: failure() && contains(github.event.issue.labels.*.name, 'challenge-error')
    needs: [reset-challenge-status]
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        
      - name: üîç Debug Information
        run: |
          echo "üêõ Debug-Informationen f√ºr fehlgeschlagenen Workflow"
          echo "===================================================="
          echo "üìã Issue #${{ github.event.issue.number }}"
          echo "üè∑Ô∏è Labels: ${{ join(github.event.issue.labels.*.name, ', ') }}"
          echo "üìù Titel: ${{ github.event.issue.title }}"
          echo ""
          echo "üìÅ Verf√ºgbare Challenge-Verzeichnisse:"
          ls -la challenges/ || echo "‚ùå Kein challenges/ Verzeichnis"
          echo ""
          echo "üîç Challenge-Verzeichnisse mit 'reported' Status:"
          for dir in challenges/*/; do
            if [ -f "$dir/challenge.json" ]; then
              status=$(cat "$dir/challenge.json" | grep -o '"status":\s*"[^"]*"' | head -1)
              echo "  $(basename $dir): $status"
            fi
          done
