name: üîì Universal Challenge Unlock

on:
  issues:
    types: [closed]

permissions:
  issues: write
  contents: write

jobs:
  unlock-challenge:
    # Trigger nur bei Challenge Error Reports
    if: |
      contains(github.event.issue.labels.*.name, 'challenge-error') ||
      contains(github.event.issue.title, 'Challenge Error Report') ||
      contains(github.event.issue.body, 'üö® Challenge Error Report') ||
      contains(github.event.issue.body, '**ID:**')
    
    runs-on: ubuntu-latest
    
    steps:
      - name: üì¶ Repository auschecken
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0
      
      - name: üîç Challenge-ID Universal Extraktion
        id: extract_id
        run: |
          echo "üîç Starte universelle Challenge-ID Extraktion..."
          
          # Issue-Body sicher in Variable laden
          ISSUE_BODY='${{ github.event.issue.body }}'
          
          echo "üìÑ Issue-Body L√§nge: ${#ISSUE_BODY} Zeichen"
          
          # Methode 1: **ID:** Pattern (Standard Format)
          echo "üß™ Methode 1: **ID:** Pattern"
          ID1=$(echo "$ISSUE_BODY" | grep -oE '\*\*ID:\*\*[[:space:]]*[a-zA-Z0-9._-]+' | sed 's/.*\*\*ID:\*\*[[:space:]]*//' | head -1 | tr -d ' \t\n\r' 2>/dev/null || echo "")
          echo "   Gefunden: '$ID1'"
          
          # Methode 2: ID: Pattern (ohne Markdown)
          echo "üß™ Methode 2: ID: Pattern"
          ID2=$(echo "$ISSUE_BODY" | grep -E '^[[:space:]]*ID:[[:space:]]*[a-zA-Z0-9._-]+' | sed 's/.*ID:[[:space:]]*//' | head -1 | tr -d ' \t\n\r' 2>/dev/null || echo "")
          echo "   Gefunden: '$ID2'"
          
          # Methode 3: mcbt Pattern (Challenge-ID Format)
          echo "üß™ Methode 3: mcbt Pattern"
          ID3=$(echo "$ISSUE_BODY" | grep -oE '[a-zA-Z0-9-]+mcbt[a-zA-Z0-9]+' | head -1 | tr -d ' \t\n\r' 2>/dev/null || echo "")
          echo "   Gefunden: '$ID3'"
          
          # Methode 4: Generisches Challenge-ID Pattern (mit Bindestrichen)
          echo "üß™ Methode 4: Generic Challenge Pattern"
          ID4=$(echo "$ISSUE_BODY" | grep -oE '[a-z][a-z0-9-]{10,50}[a-z0-9]' | grep -E '.*-.*-.*' | head -1 | tr -d ' \t\n\r' 2>/dev/null || echo "")
          echo "   Gefunden: '$ID4'"
          
          # Methode 5: Suche nach allem zwischen Anf√ºhrungszeichen nach "ID"
          echo "üß™ Methode 5: Quoted ID Pattern"
          ID5=$(echo "$ISSUE_BODY" | grep -oE 'ID[[:space:]]*[:\"]\*\*[[:space:]]*[a-zA-Z0-9._-]+' | sed 's/.*[[:space:]]//' | tr -d '"*: \t\n\r' 2>/dev/null || echo "")
          echo "   Gefunden: '$ID5'"
          
          # Bestimme die beste ID
          FINAL_ID=""
          
          # Priorit√§t: ID1 > ID3 > ID2 > ID4 > ID5
          if [ -n "$ID1" ]; then
            FINAL_ID="$ID1"
            echo "‚úÖ Verwende ID aus Methode 1: $FINAL_ID"
          elif [ -n "$ID3" ]; then
            FINAL_ID="$ID3"
            echo "‚úÖ Verwende ID aus Methode 3: $FINAL_ID"
          elif [ -n "$ID2" ]; then
            FINAL_ID="$ID2"
            echo "‚úÖ Verwende ID aus Methode 2: $FINAL_ID"
          elif [ -n "$ID4" ]; then
            FINAL_ID="$ID4"
            echo "‚úÖ Verwende ID aus Methode 4: $FINAL_ID"
          elif [ -n "$ID5" ]; then
            FINAL_ID="$ID5"
            echo "‚úÖ Verwende ID aus Methode 5: $FINAL_ID"
          fi
          
          # Validierung
          if [ -z "$FINAL_ID" ]; then
            echo "‚ùå Keine Challenge-ID gefunden!"
            echo ""
            echo "üîç Debug: Issue-Body Inhalt (erste 500 Zeichen):"
            echo "$ISSUE_BODY" | head -c 500
            echo ""
            echo "üí° Erwartete Formate:"
            echo "   - **ID:** challenge-id-hier"
            echo "   - ID: challenge-id-hier"
            echo "   - Beliebiger Text mit challenge-id-mcbtXXXX"
            exit 1
          fi
          
          # ID bereinigen (f√ºr Sicherheit)
          CLEAN_ID=$(echo "$FINAL_ID" | tr -cd 'a-zA-Z0-9._-')
          
          if [ "$CLEAN_ID" != "$FINAL_ID" ]; then
            echo "‚ö†Ô∏è ID bereinigt: '$FINAL_ID' ‚Üí '$CLEAN_ID'"
            FINAL_ID="$CLEAN_ID"
          fi
          
          echo "üéØ Finale Challenge-ID: $FINAL_ID"
          echo "challenge_id=$FINAL_ID" >> $GITHUB_OUTPUT
      
      - name: ‚úÖ Challenge-Existenz pr√ºfen
        id: validate
        run: |
          ID=${{ steps.extract_id.outputs.challenge_id }}
          CHALLENGE_DIR="challenges/$ID"
          CONFIG_FILE="$CHALLENGE_DIR/challenge.json"
          
          echo "üîç Pr√ºfe Challenge-Existenz..."
          echo "üìÅ Challenge-Verzeichnis: $CHALLENGE_DIR"
          echo "üìÑ Config-Datei: $CONFIG_FILE"
          
          # Pr√ºfe ob Challenges-Ordner existiert
          if [ ! -d "challenges" ]; then
            echo "‚ùå Challenges-Hauptordner existiert nicht!"
            echo "üìÅ Repository-Struktur:"
            ls -la
            exit 1
          fi
          
          # Pr√ºfe ob Challenge-Ordner existiert
          if [ ! -d "$CHALLENGE_DIR" ]; then
            echo "‚ùå Challenge-Ordner nicht gefunden: $CHALLENGE_DIR"
            echo ""
            echo "üìÅ Verf√ºgbare Challenges (erste 10):"
            find challenges/ -maxdepth 1 -type d -name "*" | head -10 || echo "Keine Challenge-Ordner gefunden"
            echo ""
            echo "üîç Suche nach √§hnlichen IDs:"
            find challenges/ -maxdepth 1 -type d -name "*${ID:0:10}*" 2>/dev/null || echo "Keine √§hnlichen IDs gefunden"
            exit 1
          fi
          
          # Pr√ºfe ob Config-Datei existiert
          if [ ! -f "$CONFIG_FILE" ]; then
            echo "‚ùå Challenge-Konfiguration nicht gefunden: $CONFIG_FILE"
            echo ""
            echo "üìÅ Ordner-Inhalt:"
            ls -la "$CHALLENGE_DIR/"
            exit 1
          fi
          
          echo "‚úÖ Challenge existiert und ist g√ºltig"
          
          # Aktuellen Status auslesen (falls m√∂glich)
          if command -v jq >/dev/null 2>&1; then
            CURRENT_STATUS=$(jq -r '.status // "unknown"' "$CONFIG_FILE" 2>/dev/null || echo "unknown")
            echo "üìä Aktueller Status: $CURRENT_STATUS"
            echo "current_status=$CURRENT_STATUS" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è jq nicht verf√ºgbar - Status-Check √ºbersprungen"
            echo "current_status=unknown" >> $GITHUB_OUTPUT
          fi
      
      - name: üîß Challenge-Status zur√ºcksetzen
        run: |
          ID=${{ steps.extract_id.outputs.challenge_id }}
          CONFIG_FILE="challenges/$ID/challenge.json"
          
          echo "üõ†Ô∏è Setze Challenge-Status zur√ºck..."
          echo "üìÑ Datei: $CONFIG_FILE"
          
          # Backup erstellen
          cp "$CONFIG_FILE" "$CONFIG_FILE.backup"
          echo "üíæ Backup erstellt: $CONFIG_FILE.backup"
          
          # Status zur√ºcksetzen mit sed (funktioniert ohne jq)
          echo "üîß Aktualisiere Status-Felder..."
          
          # Status auf approved setzen
          sed -i 's/"status"[[:space:]]*:[[:space:]]*"[^"]*"/"status": "approved"/g' "$CONFIG_FILE"
          
          # Fehler-Flags entfernen/zur√ºcksetzen
          sed -i 's/"hasErrors"[[:space:]]*:[[:space:]]*true/"hasErrors": false/g' "$CONFIG_FILE"
          sed -i 's/"isHidden"[[:space:]]*:[[:space:]]*true/"isHidden": false/g' "$CONFIG_FILE"
          
          # Gemeldete Issue-Referenzen entfernen
          sed -i '/"reportedIssueNumber"/d' "$CONFIG_FILE"
          sed -i '/"reportedIssueUrl"/d' "$CONFIG_FILE"
          sed -i '/"errorReport"/d' "$CONFIG_FILE"
          
          # Zus√§tzliche Bereinigung f√ºr m√∂gliche andere Status-Werte
          sed -i 's/"status"[[:space:]]*:[[:space:]]*"reported"/"status": "approved"/g' "$CONFIG_FILE"
          sed -i 's/"status"[[:space:]]*:[[:space:]]*"pending"/"status": "approved"/g' "$CONFIG_FILE"
          sed -i 's/"status"[[:space:]]*:[[:space:]]*"rejected"/"status": "approved"/g' "$CONFIG_FILE"
          
          echo "‚úÖ Status-Update abgeschlossen"
          
          # Validierung (falls jq verf√ºgbar)
          if command -v jq >/dev/null 2>&1; then
            if jq . "$CONFIG_FILE" >/dev/null 2>&1; then
              NEW_STATUS=$(jq -r '.status' "$CONFIG_FILE" 2>/dev/null || echo "unknown")
              echo "üìä Neuer Status: $NEW_STATUS"
            else
              echo "‚ö†Ô∏è JSON-Validation fehlgeschlagen - verwende Backup"
              mv "$CONFIG_FILE.backup" "$CONFIG_FILE"
              exit 1
            fi
          fi
          
          echo "üìÑ Neue Dateigr√∂√üe: $(wc -c < "$CONFIG_FILE") bytes"
      
      - name: üìù Error-Report aktualisieren (optional)
        run: |
          ID=${{ steps.extract_id.outputs.challenge_id }}
          ERROR_FILE="challenges/$ID/error-report.json"
          
          if [ -f "$ERROR_FILE" ]; then
            echo "üìù Aktualisiere Error-Report: $ERROR_FILE"
            
            # Einfache sed-basierte Aktualisierung
            sed -i 's/"isResolved"[[:space:]]*:[[:space:]]*false/"isResolved": true/g' "$ERROR_FILE"
            
            # Falls jq verf√ºgbar, erweiterte Aktualisierung
            if command -v jq >/dev/null 2>&1; then
              TIMESTAMP=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
              jq --arg timestamp "$TIMESTAMP" --argjson issue "${{ github.event.issue.number }}" '
                .isResolved = true |
                .resolvedAt = $timestamp |
                .resolvedBy = "github-action" |
                .resolvedIssue = $issue
              ' "$ERROR_FILE" > "$ERROR_FILE.tmp" && mv "$ERROR_FILE.tmp" "$ERROR_FILE"
              echo "‚úÖ Error-Report mit jq aktualisiert"
            else
              echo "‚ÑπÔ∏è Error-Report mit sed aktualisiert"
            fi
          else
            echo "‚ÑπÔ∏è Kein Error-Report gefunden: $ERROR_FILE"
          fi
      
      - name: üíæ Git-Konfiguration und Commit
        run: |
          ID=${{ steps.extract_id.outputs.challenge_id }}
          
          # Git konfigurieren
          git config user.name "challenge-unlock-bot"
          git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          echo "üîç Pr√ºfe auf √Ñnderungen..."
          
          if git diff --quiet; then
            echo "‚ÑπÔ∏è Keine √Ñnderungen zu committen"
          else
            echo "üìù Committen der √Ñnderungen..."
            
            # Nur die Challenge-Dateien hinzuf√ºgen
            git add "challenges/$ID/"
            
            # Commit mit aussagekr√§ftiger Nachricht
            git commit -m "üîì Challenge automatisch entsperrt: $ID

Entsperrt nach Issue-Schlie√üung #${{ github.event.issue.number }}
‚úÖ Status: approved
üóìÔ∏è Entsperrt: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
ü§ñ Automatisch durch GitHub Actions

Co-authored-by: ${{ github.event.issue.user.login }} <${{ github.event.issue.user.id }}+${{ github.event.issue.user.login }}@users.noreply.github.com>"
            
            echo "üì§ Push der √Ñnderungen..."
            git push origin main
            
            echo "‚úÖ Challenge $ID erfolgreich entsperrt und gepusht"
          fi
      
      - name: üí¨ Erfolgs-Kommentar hinzuf√ºgen
        uses: actions/github-script@v7
        with:
          script: |
            const challengeId = '${{ steps.extract_id.outputs.challenge_id }}';
            const currentStatus = '${{ steps.validate.outputs.current_status }}' || 'unknown';
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ‚úÖ Challenge automatisch entsperrt!
              
              **üéØ Challenge-ID:** \`${challengeId}\`  
              **üìä Vorheriger Status:** \`${currentStatus}\`  
              **üìä Neuer Status:** \`approved\`  
              **üïí Entsperrt:** ${new Date().toLocaleString('de-DE', {timeZone: 'Europe/Berlin'})}
              
              ### üéâ Was ist passiert:
              - ‚úÖ Challenge-Status wurde auf \`approved\` zur√ºckgesetzt
              - üîì Challenge ist wieder f√ºr alle Benutzer sichtbar  
              - üìù Error-Report als gel√∂st markiert
              - üóëÔ∏è Fehler-Flags und Issue-Referenzen entfernt
              
              ### üöÄ N√§chste Schritte:
              Die Challenge \`${challengeId}\` ist jetzt wieder verf√ºgbar und kann in der **VS Code Coding Challenges Extension** geladen werden.
              
              ---
              ü§ñ *Automatisch entsperrt durch GitHub Actions*`
            });
            
            console.log('‚úÖ Erfolgs-Kommentar hinzugef√ºgt');
      
      - name: üè∑Ô∏è Issue-Labels aktualisieren
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Labels hinzuf√ºgen
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
                labels: ['resolved', 'auto-unlocked', 'challenge-restored']
              });
              
              console.log('‚úÖ Labels hinzugef√ºgt: resolved, auto-unlocked, challenge-restored');
            } catch (error) {
              console.error('‚ö†Ô∏è Fehler beim Hinzuf√ºgen der Labels:', error);
            }

  # Fehlerbehandlung
  handle-failure:
    if: failure()
    needs: unlock-challenge
    runs-on: ubuntu-latest
    permissions:
      issues: write
    
    steps:
      - name: üí¨ Detaillierter Fehler-Kommentar
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## ‚ùå Automatische Challenge-Entsperrung fehlgeschlagen
              
              Der Versuch, die Challenge automatisch zu entsperren, ist fehlgeschlagen.
              
              ### üõ†Ô∏è Manuelle Schritte erforderlich:
              
              #### 1. Challenge-ID finden
              Suche im Issue-Body nach der Challenge-ID (Format: \`**ID:** challenge-id-hier\`)
              
              #### 2. Datei bearbeiten
              √ñffne die Datei: \`challenges/{challenge-id}/challenge.json\`
              
              #### 3. Status √§ndern
              √Ñndere folgende Werte:
              \`\`\`json
              {
                "status": "approved",
                "hasErrors": false,
                "isHidden": false
              }
              \`\`\`
              
              #### 4. Referenzen entfernen
              L√∂sche diese Zeilen (falls vorhanden):
              \`\`\`json
              "reportedIssueNumber": ${context.issue.number},
              "reportedIssueUrl": "...",
              "errorReport": { ... }
              \`\`\`
              
              #### 5. Speichern
              Committe und pushe die √Ñnderungen
              
              ### üîç Debugging-Informationen:
              - **Issue:** #${context.issue.number}
              - **Workflow-Run:** [${context.runId}](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})
              - **Fehler-Zeit:** ${new Date().toISOString()}
              
              ### üìã H√§ufige Ursachen:
              - Challenge-ID konnte nicht aus Issue-Body extrahiert werden
              - Challenge-Ordner existiert nicht im Repository
              - Datei-Permissions oder Git-Fehler
              - JSON-Format ung√ºltig
              
              **üí° Tipp:** Pr√ºfe die Workflow-Logs f√ºr detaillierte Fehlermeldungen.
              
              ---
              ü§ñ *Fehlerbehandlung - Manuelle Aktion erforderlich*`
            });
            
            // Fehler-Labels hinzuf√ºgen
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              labels: ['manual-unlock-required', 'auto-unlock-failed']
            });
            
            console.log('‚úÖ Fehler-Kommentar und Labels hinzugef√ºgt');
